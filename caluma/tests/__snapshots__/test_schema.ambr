# name: test_schema_introspect_direct
  '
  type ActionButtonQuestion implements Question & Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    slug: String!
    label: String!
  
    """Required expression is only evaluated when question is not hidden."""
    isRequired: QuestionJexl!
    isHidden: QuestionJexl!
    isArchived: Boolean!
    infoText: String
    meta: GenericScalar!
    source: Question
    forms(
      offset: Int = null
      before: String = null
      after: String = null
      first: Int = null
      last: Int = null
      slug: String = null
      name: String = null
      description: String = null
      isPublished: Boolean = null
      isArchived: Boolean = null
      questions: [String] = null
      createdByUser: String = null
      createdByGroup: String = null
      modifiedByUser: String = null
      modifiedByGroup: String = null
  
      """Only return entries created after the given DateTime (Exclusive)"""
      createdBefore: DateTime = null
  
      """
      Only return entries created at or before the given DateTime (Inclusive)
      """
      createdAfter: DateTime = null
      metaHasKey: String = null
      metaValue: [JSONValueFilterType] = null
      search: String = null
  
      """FormOrdering"""
      orderBy: [FormOrdering] = null
      slugs: [String] = null
    ): FormConnection
  
    """The ID of the object"""
    id: ID!
    action: ButtonAction!
    color: ButtonColor!
    validateOnEnter: Boolean!
  }
  
  input AddFormQuestionInput {
    form: ID!
    question: ID!
    clientMutationId: String
  }
  
  """Add question at the end of form."""
  type AddFormQuestionPayload {
    form: Form
    clientMutationId: String
  }
  
  input AddWorkflowFlowInput {
    workflow: ID!
    tasks: [ID]!
    next: FlowJexl!
    redoable: FlowJexl
    clientMutationId: String
  }
  
  type AddWorkflowFlowPayload {
    workflow: Workflow
    clientMutationId: String
  }
  
  """A cell represents one value in the analytics output."""
  type AnalyticsCell {
    alias: String
    value: String
  }
  
  type AnalyticsField implements Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
  
    """The ID of the object"""
    id: ID!
    alias: String!
    meta: GenericScalar
    dataSource: String!
    table: AnalyticsTable!
    filters: [String]
  }
  
  type AnalyticsFieldConnection {
    """Pagination data for this connection."""
    pageInfo: PageInfo!
  
    """Contains the nodes in this connection."""
    edges: [AnalyticsFieldEdge]!
    totalCount: Int
  }
  
  """A Relay edge containing a `AnalyticsField` and its cursor."""
  type AnalyticsFieldEdge {
    """The item at the end of the edge"""
    node: AnalyticsField
  
    """A cursor for use in pagination"""
    cursor: String!
  }
  
  input AnalyticsFieldFilterSetType {
    alias: String
    table: ID
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    createdBefore: DateTime
    createdAfter: DateTime
    metaHasKey: String
    metaValue: [JSONValueFilterType]
    search: String
    slugs: [String]
    invert: Boolean
  }
  
  type AnalyticsOutput {
    records(before: String = null, after: String = null, first: Int = null, last: Int = null): AnalyticsTableContentConnection
  }
  
  type AnalyticsRowConnection {
    """Pagination data for this connection."""
    pageInfo: PageInfo!
  
    """Contains the nodes in this connection."""
    edges: [AnalyticsRowEdge]!
  }
  
  """A Relay edge containing a `AnalyticsRow` and its cursor."""
  type AnalyticsRowEdge {
    """The item at the end of the edge"""
    node: AnalyticsCell
  
    """A cursor for use in pagination"""
    cursor: String!
  }
  
  type AnalyticsTable implements Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    slug: String!
    meta: JSONString!
    disableVisibilities: Boolean!
    name: String!
    startingObject: CalumaAnalyticsAnalyticsTableStartingObjectChoices!
    fields(offset: Int = null, before: String = null, after: String = null, first: Int = null, last: Int = null): AnalyticsFieldConnection!
  
    """The ID of the object"""
    id: ID!
    availableFields(prefix: String = null, depth: Int = null, before: String = null, after: String = null, first: Int = null, last: Int = null): AvailableFieldConnection
    resultData: AnalyticsOutput
  }
  
  type AnalyticsTableConnection {
    """Pagination data for this connection."""
    pageInfo: PageInfo!
  
    """Contains the nodes in this connection."""
    edges: [AnalyticsTableEdge]!
    totalCount: Int
  }
  
  type AnalyticsTableContentConnection {
    """Pagination data for this connection."""
    pageInfo: PageInfo!
  
    """Contains the nodes in this connection."""
    edges: [AnalyticsTableContentEdge]!
  }
  
  """A Relay edge containing a `AnalyticsTableContent` and its cursor."""
  type AnalyticsTableContentEdge {
    """The item at the end of the edge"""
    node: AnalyticsRowConnection
  
    """A cursor for use in pagination"""
    cursor: String!
  }
  
  """A Relay edge containing a `AnalyticsTable` and its cursor."""
  type AnalyticsTableEdge {
    """The item at the end of the edge"""
    node: AnalyticsTable
  
    """A cursor for use in pagination"""
    cursor: String!
  }
  
  input AnalyticsTableFilterSetType {
    slug: String
    name: String
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    createdBefore: DateTime
    createdAfter: DateTime
    metaHasKey: String
    metaValue: [JSONValueFilterType]
    search: String
    slugs: [String]
    invert: Boolean
  }
  
  input AnalyticsTableOrderSetType {
    meta: String
    attribute: SortableAnalyticsTableAttributes
    direction: AscDesc
  }
  
  interface Answer {
    id: ID
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    question: Question!
    meta: GenericScalar!
  }
  
  type AnswerConnection {
    """Pagination data for this connection."""
    pageInfo: PageInfo!
  
    """Contains the nodes in this connection."""
    edges: [AnswerEdge]!
    totalCount: Int
  }
  
  """A Relay edge containing a `Answer` and its cursor."""
  type AnswerEdge {
    """The item at the end of the edge"""
    node: Answer
  
    """A cursor for use in pagination"""
    cursor: String!
  }
  
  input AnswerFilterSetType {
    question: ID
    search: String
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    createdBefore: DateTime
    createdAfter: DateTime
    metaHasKey: String
    metaValue: [JSONValueFilterType]
  
    """"""
    orderBy: [AnswerOrdering]
    questions: [ID]
    visibleInContext: Boolean
    invert: Boolean
  }
  
  enum AnswerHierarchyMode {
    DIRECT
    FAMILY
  }
  
  enum AnswerLookupMode {
    EXACT
    STARTSWITH
    CONTAINS
    ICONTAINS
    INTERSECTS
    ISNULL
    IN
    GTE
    GT
    LTE
    LT
  }
  
  input AnswerOrderSetType {
    meta: String
    attribute: SortableAnswerAttributes
    direction: AscDesc
  }
  
  """An enumeration."""
  enum AnswerOrdering {
    """Created at"""
    CREATED_AT_ASC
  
    """Created at (descending)"""
    CREATED_AT_DESC
  
    """Modified at"""
    MODIFIED_AT_ASC
  
    """Modified at (descending)"""
    MODIFIED_AT_DESC
  
    """Created by user"""
    CREATED_BY_USER_ASC
  
    """Created by user (descending)"""
    CREATED_BY_USER_DESC
  
    """Created by group"""
    CREATED_BY_GROUP_ASC
  
    """Created by group (descending)"""
    CREATED_BY_GROUP_DESC
  
    """Modified by user"""
    MODIFIED_BY_USER_ASC
  
    """Modified by user (descending)"""
    MODIFIED_BY_USER_DESC
  
    """Modified by group"""
    MODIFIED_BY_GROUP_ASC
  
    """Modified by group (descending)"""
    MODIFIED_BY_GROUP_DESC
  
    """Meta test-key"""
    META_TEST_KEY_ASC
  
    """Meta test-key (descending)"""
    META_TEST_KEY_DESC
  
    """Meta foobar"""
    META_FOOBAR_ASC
  
    """Meta foobar (descending)"""
    META_FOOBAR_DESC
  }
  
  enum AscDesc {
    ASC
    DESC
  }
  
  """
  Available fields show users what can be selected in an analysis.
  
  The main identifier is the source path, but for display purposes,
  a label (field at current position) and a full_label (including
  parent fields' labels) is available.
  
  Frontends should query sub-fields (via prefix/depth) if is_leaf is
  False. Some fields can be non-leafs as well as values, such as
  dates: Dates can be extracted "as is", or we can extract a
  date part (such as year, quarter, ...) from it.
  """
  type AvailableField implements Node {
    """The ID of the object"""
    id: ID!
    label: String
    fullLabel: String
    sourcePath: String
    isLeaf: Boolean
    isValue: Boolean
  }
  
  type AvailableFieldConnection {
    """Pagination data for this connection."""
    pageInfo: PageInfo!
  
    """Contains the nodes in this connection."""
    edges: [AvailableFieldEdge]!
    totalCount: Int
  }
  
  """A Relay edge containing a `AvailableField` and its cursor."""
  type AvailableFieldEdge {
    """The item at the end of the edge"""
    node: AvailableField
  
    """A cursor for use in pagination"""
    cursor: String!
  }
  
  """An enumeration."""
  enum ButtonAction {
    COMPLETE
    SKIP
  }
  
  """An enumeration."""
  enum ButtonColor {
    PRIMARY
    SECONDARY
    DEFAULT
  }
  
  type CalculatedFloatQuestion implements Question & Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    slug: String!
    label: String!
  
    """Required expression is only evaluated when question is not hidden."""
    isRequired: QuestionJexl!
    isHidden: QuestionJexl!
    isArchived: Boolean!
    infoText: String
    hintText: String
    meta: GenericScalar!
    source: Question
    forms(
      offset: Int = null
      before: String = null
      after: String = null
      first: Int = null
      last: Int = null
      slug: String = null
      name: String = null
      description: String = null
      isPublished: Boolean = null
      isArchived: Boolean = null
      questions: [String] = null
      createdByUser: String = null
      createdByGroup: String = null
      modifiedByUser: String = null
      modifiedByGroup: String = null
  
      """Only return entries created after the given DateTime (Exclusive)"""
      createdBefore: DateTime = null
  
      """
      Only return entries created at or before the given DateTime (Inclusive)
      """
      createdAfter: DateTime = null
      metaHasKey: String = null
      metaValue: [JSONValueFilterType] = null
      search: String = null
  
      """FormOrdering"""
      orderBy: [FormOrdering] = null
      slugs: [String] = null
    ): FormConnection
    calcExpression: String
  
    """The ID of the object"""
    id: ID!
  }
  
  """An enumeration."""
  enum CalumaAnalyticsAnalyticsTableStartingObjectChoices {
    """Cases"""
    CASES
  }
  
  """An enumeration."""
  enum CalumaFormHistoricalAnswerHistoryQuestionTypeChoices {
    """multiple_choice"""
    MULTIPLE_CHOICE
  
    """integer"""
    INTEGER
  
    """float"""
    FLOAT
  
    """date"""
    DATE
  
    """choice"""
    CHOICE
  
    """textarea"""
    TEXTAREA
  
    """text"""
    TEXT
  
    """table"""
    TABLE
  
    """form"""
    FORM
  
    """file"""
    FILE
  
    """dynamic_choice"""
    DYNAMIC_CHOICE
  
    """dynamic_multiple_choice"""
    DYNAMIC_MULTIPLE_CHOICE
  
    """static"""
    STATIC
  
    """calculated_float"""
    CALCULATED_FLOAT
  
    """action_button"""
    ACTION_BUTTON
  }
  
  input CancelCaseInput {
    id: ID!
  
    """Provide extra context for dynamic jexl transforms and events"""
    context: JSONString
    clientMutationId: String
  }
  
  type CancelCasePayload {
    case: Case
    clientMutationId: String
  }
  
  input CancelWorkItemInput {
    id: ID!
  
    """Provide extra context for dynamic jexl transforms and events"""
    context: JSONString
    clientMutationId: String
  }
  
  type CancelWorkItemPayload {
    workItem: WorkItem
    clientMutationId: String
  }
  
  type Case implements Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
  
    """The ID of the object"""
    id: ID!
  
    """Time when case has either been canceled or completed"""
    closedAt: DateTime
    closedByUser: String
    closedByGroup: String
    workflow: Workflow!
    status: CaseStatus!
    meta: GenericScalar
    document: Document
    workItems(
      offset: Int = null
      before: String = null
      after: String = null
      first: Int = null
      last: Int = null
      metaValue: [JSONValueFilterType] = null
      status: WorkItemStatusArgument = null
      name: String = null
      task: ID = null
      tasks: [String] = null
      case: ID = null
      createdAt: DateTime = null
      closedAt: DateTime = null
      modifiedAt: DateTime = null
      deadline: DateTime = null
      hasDeadline: Boolean = null
      caseFamily: ID = null
  
      """WorkItemOrdering"""
      orderBy: [WorkItemOrdering] = null
      filter: [WorkItemFilterSetType] = null
      order: [WorkItemOrderSetType] = null
      createdByUser: String = null
      createdByGroup: String = null
      modifiedByUser: String = null
      modifiedByGroup: String = null
  
      """Only return entries created after the given DateTime (Exclusive)"""
      createdBefore: DateTime = null
  
      """
      Only return entries created at or before the given DateTime (Inclusive)
      """
      createdAfter: DateTime = null
      metaHasKey: String = null
      id: ID = null
      addressedGroups: [String] = null
      controllingGroups: [String] = null
      assignedUsers: [String] = null
      documentHasAnswer: [HasAnswerFilterType] = null
      caseDocumentHasAnswer: [HasAnswerFilterType] = null
      caseMetaValue: [JSONValueFilterType] = null
      rootCaseMetaValue: [JSONValueFilterType] = null
    ): WorkItemConnection
    parentWorkItem: WorkItem
    familyWorkItems(
      offset: Int = null
      before: String = null
      after: String = null
      first: Int = null
      last: Int = null
      metaValue: [JSONValueFilterType] = null
      status: WorkItemStatusArgument = null
  
      """WorkItemOrdering"""
      orderBy: [WorkItemOrdering] = null
      filter: [WorkItemFilterSetType] = null
      order: [WorkItemOrderSetType] = null
      documentHasAnswer: [HasAnswerFilterType] = null
      caseDocumentHasAnswer: [HasAnswerFilterType] = null
      caseMetaValue: [JSONValueFilterType] = null
      rootCaseMetaValue: [JSONValueFilterType] = null
      name: String = null
      task: ID = null
      tasks: [String] = null
      case: ID = null
      createdAt: DateTime = null
      closedAt: DateTime = null
      modifiedAt: DateTime = null
      deadline: DateTime = null
      hasDeadline: Boolean = null
      caseFamily: ID = null
      createdByUser: String = null
      createdByGroup: String = null
      modifiedByUser: String = null
      modifiedByGroup: String = null
  
      """Only return entries created after the given DateTime (Exclusive)"""
      createdBefore: DateTime = null
  
      """
      Only return entries created at or before the given DateTime (Inclusive)
      """
      createdAfter: DateTime = null
      metaHasKey: String = null
      id: ID = null
      addressedGroups: [String] = null
      controllingGroups: [String] = null
      assignedUsers: [String] = null
    ): WorkItemConnection
  }
  
  type CaseConnection {
    """Pagination data for this connection."""
    pageInfo: PageInfo!
  
    """Contains the nodes in this connection."""
    edges: [CaseEdge]!
    totalCount: Int
  }
  
  """A Relay edge containing a `Case` and its cursor."""
  type CaseEdge {
    """The item at the end of the edge"""
    node: Case
  
    """A cursor for use in pagination"""
    cursor: String!
  }
  
  input CaseFilterSetType {
    workflow: ID
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    createdBefore: DateTime
    createdAfter: DateTime
    metaHasKey: String
    metaValue: [JSONValueFilterType]
    id: ID
  
    """"""
    orderBy: [CaseOrdering]
    documentForm: String
    documentForms: [String]
    hasAnswer: [HasAnswerFilterType]
    workItemDocumentHasAnswer: [HasAnswerFilterType]
    rootCase: ID
    searchAnswers: [SearchAnswersFilterType]
    status: [CaseStatusArgument]
    orderByQuestionAnswerValue: String
    invert: Boolean
  }
  
  input CaseOrderSetType {
    meta: String
    attribute: SortableCaseAttributes
    documentAnswer: String
    direction: AscDesc
  }
  
  """An enumeration."""
  enum CaseOrdering {
    """Status"""
    STATUS_ASC
  
    """Status (descending)"""
    STATUS_DESC
  
    """Created at"""
    CREATED_AT_ASC
  
    """Created at (descending)"""
    CREATED_AT_DESC
  
    """Modified at"""
    MODIFIED_AT_ASC
  
    """Modified at (descending)"""
    MODIFIED_AT_DESC
  
    """Created by user"""
    CREATED_BY_USER_ASC
  
    """Created by user (descending)"""
    CREATED_BY_USER_DESC
  
    """Created by group"""
    CREATED_BY_GROUP_ASC
  
    """Created by group (descending)"""
    CREATED_BY_GROUP_DESC
  
    """Modified by user"""
    MODIFIED_BY_USER_ASC
  
    """Modified by user (descending)"""
    MODIFIED_BY_USER_DESC
  
    """Modified by group"""
    MODIFIED_BY_GROUP_ASC
  
    """Modified by group (descending)"""
    MODIFIED_BY_GROUP_DESC
  
    """Meta test-key"""
    META_TEST_KEY_ASC
  
    """Meta test-key (descending)"""
    META_TEST_KEY_DESC
  
    """Meta foobar"""
    META_FOOBAR_ASC
  
    """Meta foobar (descending)"""
    META_FOOBAR_DESC
  }
  
  """An enumeration."""
  enum CaseStatus {
    RUNNING
    COMPLETED
    CANCELED
    SUSPENDED
  }
  
  """An enumeration."""
  enum CaseStatusArgument {
    """Case is running and work items need to be completed."""
    RUNNING
  
    """Case is done."""
    COMPLETED
  
    """Case is canceled."""
    CANCELED
  
    """Case is suspended."""
    SUSPENDED
  }
  
  type ChoiceQuestion implements Question & Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    slug: String!
    label: String!
  
    """Required expression is only evaluated when question is not hidden."""
    isRequired: QuestionJexl!
    isHidden: QuestionJexl!
    isArchived: Boolean!
    infoText: String
    hintText: String
    meta: GenericScalar!
    source: Question
    defaultAnswer: StringAnswer
    forms(
      offset: Int = null
      before: String = null
      after: String = null
      first: Int = null
      last: Int = null
      slug: String = null
      name: String = null
      description: String = null
      isPublished: Boolean = null
      isArchived: Boolean = null
      questions: [String] = null
      createdByUser: String = null
      createdByGroup: String = null
      modifiedByUser: String = null
      modifiedByGroup: String = null
  
      """Only return entries created after the given DateTime (Exclusive)"""
      createdBefore: DateTime = null
  
      """
      Only return entries created at or before the given DateTime (Inclusive)
      """
      createdAfter: DateTime = null
      metaHasKey: String = null
      metaValue: [JSONValueFilterType] = null
      search: String = null
  
      """FormOrdering"""
      orderBy: [FormOrdering] = null
      slugs: [String] = null
    ): FormConnection
    options(
      offset: Int = null
      before: String = null
      after: String = null
      first: Int = null
      last: Int = null
      metaValue: [JSONValueFilterType] = null
      slug: String = null
      label: String = null
      isArchived: Boolean = null
      createdByUser: String = null
      createdByGroup: String = null
      modifiedByUser: String = null
      modifiedByGroup: String = null
  
      """Only return entries created after the given DateTime (Exclusive)"""
      createdBefore: DateTime = null
  
      """
      Only return entries created at or before the given DateTime (Inclusive)
      """
      createdAfter: DateTime = null
      metaHasKey: String = null
      search: String = null
  
      """OptionOrdering"""
      orderBy: [OptionOrdering] = null
    ): OptionConnection
  
    """The ID of the object"""
    id: ID!
  }
  
  type CompleteTaskFormTask implements Task & Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    slug: String!
    name: String!
    description: String
    meta: GenericScalar!
    addressGroups: GroupJexl
    controlGroups: GroupJexl
    isArchived: Boolean!
  
    """Time in seconds task may take to be processed."""
    leadTime: Int
    isMultipleInstance: Boolean!
    continueAsync: Boolean
    form: Form!
  
    """The ID of the object"""
    id: ID!
  }
  
  input CompleteWorkItemInput {
    id: ID!
  
    """Provide extra context for dynamic jexl transforms and events"""
    context: JSONString
    clientMutationId: String
  }
  
  type CompleteWorkItemPayload {
    workItem: WorkItem
    clientMutationId: String
  }
  
  type CompleteWorkflowFormTask implements Task & Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    slug: String!
    name: String!
    description: String
    meta: GenericScalar!
    addressGroups: GroupJexl
    controlGroups: GroupJexl
    isArchived: Boolean!
  
    """Time in seconds task may take to be processed."""
    leadTime: Int
    isMultipleInstance: Boolean!
    continueAsync: Boolean
  
    """The ID of the object"""
    id: ID!
  }
  
  input CopyDocumentInput {
    source: ID!
    clientMutationId: String
  }
  
  type CopyDocumentPayload {
    document: Document
    clientMutationId: String
  }
  
  input CopyFormInput {
    slug: String!
    name: String!
    description: String
    source: ID!
    isPublished: Boolean
    clientMutationId: String
  }
  
  type CopyFormPayload {
    form: Form
    clientMutationId: String
  }
  
  input CopyOptionInput {
    slug: String!
    label: String!
    source: ID!
    clientMutationId: String
  }
  
  type CopyOptionPayload {
    option: Option
    clientMutationId: String
  }
  
  input CopyQuestionInput {
    slug: String!
    label: String!
    source: ID!
    clientMutationId: String
  }
  
  type CopyQuestionPayload {
    question: Question
    clientMutationId: String
  }
  
  input CreateWorkItemInput {
    case: ID!
    multipleInstanceTask: ID!
  
    """Will be set from Task, if not provided."""
    name: String
  
    """Will be set from Task, if not provided."""
    description: String
  
    """Users responsible to undertake given work item."""
    assignedUsers: [String]
    addressedGroups: [String]
    controllingGroups: [String]
    deadline: DateTime
    meta: JSONString
  
    """Provide extra context for dynamic jexl transforms and events"""
    context: JSONString
    clientMutationId: String
  }
  
  type CreateWorkItemPayload {
    workItem: WorkItem
    clientMutationId: String
  }
  
  type DataSource {
    info: String
    name: String!
  }
  
  type DataSourceConnection {
    """Pagination data for this connection."""
    pageInfo: PageInfo!
  
    """Contains the nodes in this connection."""
    edges: [DataSourceEdge]!
    totalCount: Int
  }
  
  type DataSourceData {
    label: String!
    slug: String!
  }
  
  type DataSourceDataConnection {
    """Pagination data for this connection."""
    pageInfo: PageInfo!
  
    """Contains the nodes in this connection."""
    edges: [DataSourceDataEdge]!
    totalCount: Int
  }
  
  """A Relay edge containing a `DataSourceData` and its cursor."""
  type DataSourceDataEdge {
    """The item at the end of the edge"""
    node: DataSourceData
  
    """A cursor for use in pagination"""
    cursor: String!
  }
  
  """A Relay edge containing a `DataSource` and its cursor."""
  type DataSourceEdge {
    """The item at the end of the edge"""
    node: DataSource
  
    """A cursor for use in pagination"""
    cursor: String!
  }
  
  """
  The `Date` scalar type represents a Date
  value as specified by
  [iso8601](https://en.wikipedia.org/wiki/ISO_8601).
  """
  scalar Date
  
  type DateAnswer implements Answer & Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
  
    """The ID of the object"""
    id: ID!
    question: Question!
    value: Date
    meta: GenericScalar!
    date: Date
  }
  
  type DateQuestion implements Question & Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    slug: String!
    label: String!
  
    """Required expression is only evaluated when question is not hidden."""
    isRequired: QuestionJexl!
    isHidden: QuestionJexl!
    isArchived: Boolean!
    infoText: String
    hintText: String
    meta: GenericScalar!
    source: Question
    defaultAnswer: DateAnswer
    forms(
      offset: Int = null
      before: String = null
      after: String = null
      first: Int = null
      last: Int = null
      slug: String = null
      name: String = null
      description: String = null
      isPublished: Boolean = null
      isArchived: Boolean = null
      questions: [String] = null
      createdByUser: String = null
      createdByGroup: String = null
      modifiedByUser: String = null
      modifiedByGroup: String = null
  
      """Only return entries created after the given DateTime (Exclusive)"""
      createdBefore: DateTime = null
  
      """
      Only return entries created at or before the given DateTime (Inclusive)
      """
      createdAfter: DateTime = null
      metaHasKey: String = null
      metaValue: [JSONValueFilterType] = null
      search: String = null
  
      """FormOrdering"""
      orderBy: [FormOrdering] = null
      slugs: [String] = null
    ): FormConnection
  
    """The ID of the object"""
    id: ID!
  }
  
  """
  The `DateTime` scalar type represents a DateTime
  value as specified by
  [iso8601](https://en.wikipedia.org/wiki/ISO_8601).
  """
  scalar DateTime
  
  """Debugging information for the current query."""
  type DjangoDebug {
    """Executed SQL queries for this API query."""
    sql: [DjangoDebugSQL]
  }
  
  """Represents a single database query made to a Django managed DB."""
  type DjangoDebugSQL {
    """The type of database being used (e.g. postrgesql, mysql, sqlite)."""
    vendor: String!
  
    """The Django database alias (e.g. 'default')."""
    alias: String!
  
    """The actual SQL sent to this database."""
    sql: String
  
    """Duration of this database query in seconds."""
    duration: Float!
  
    """The raw SQL of this query, without params."""
    rawSql: String!
  
    """JSON encoded database query parameters."""
    params: String!
  
    """Start time of this database query."""
    startTime: Float!
  
    """Stop time of this database query."""
    stopTime: Float!
  
    """Whether this database query took more than 10 seconds."""
    isSlow: Boolean!
  
    """Whether this database query was a SELECT."""
    isSelect: Boolean!
  
    """Postgres transaction ID if available."""
    transId: String
  
    """Postgres transaction status if available."""
    transStatus: String
  
    """Postgres isolation level if available."""
    isoLevel: String
  
    """Postgres connection encoding if available."""
    encoding: String
  }
  
  type Document implements Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
  
    """The ID of the object"""
    id: ID!
    form: Form!
  
    """Reference this document has been copied from"""
    source: Document
    meta: GenericScalar
  
    """Reference this document has been copied from"""
    copies(offset: Int = null, before: String = null, after: String = null, first: Int = null, last: Int = null): DocumentConnection!
    answers(
      offset: Int = null
      before: String = null
      after: String = null
      first: Int = null
      last: Int = null
      metaValue: [JSONValueFilterType] = null
      question: ID = null
      search: String = null
  
      """AnswerOrdering"""
      orderBy: [AnswerOrdering] = null
      filter: [AnswerFilterSetType] = null
      order: [AnswerOrderSetType] = null
      createdByUser: String = null
      createdByGroup: String = null
      modifiedByUser: String = null
      modifiedByGroup: String = null
  
      """Only return entries created after the given DateTime (Exclusive)"""
      createdBefore: DateTime = null
  
      """
      Only return entries created at or before the given DateTime (Inclusive)
      """
      createdAfter: DateTime = null
      metaHasKey: String = null
      questions: [ID] = null
      visibleInContext: Boolean = null
    ): AnswerConnection
    case: Case
    workItem: WorkItem
    modifiedContentAt: DateTime
    modifiedContentByUser: String
    modifiedContentByGroup: String
  }
  
  type DocumentConnection {
    """Pagination data for this connection."""
    pageInfo: PageInfo!
  
    """Contains the nodes in this connection."""
    edges: [DocumentEdge]!
    totalCount: Int
  }
  
  """A Relay edge containing a `Document` and its cursor."""
  type DocumentEdge {
    """The item at the end of the edge"""
    node: Document
  
    """A cursor for use in pagination"""
    cursor: String!
  }
  
  input DocumentFilterSetType {
    form: ID
    forms: [ID]
    search: String
    id: ID
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    createdBefore: DateTime
    createdAfter: DateTime
    metaHasKey: String
    metaValue: [JSONValueFilterType]
  
    """"""
    orderBy: [DocumentOrdering]
    rootDocument: ID
    hasAnswer: [HasAnswerFilterType]
    searchAnswers: [SearchAnswersFilterType]
    invert: Boolean
  }
  
  input DocumentOrderSetType {
    meta: String
    answerValue: String
    attribute: SortableDocumentAttributes
    direction: AscDesc
  }
  
  """An enumeration."""
  enum DocumentOrdering {
    """Created at"""
    CREATED_AT_ASC
  
    """Created at (descending)"""
    CREATED_AT_DESC
  
    """Modified at"""
    MODIFIED_AT_ASC
  
    """Modified at (descending)"""
    MODIFIED_AT_DESC
  
    """Created by user"""
    CREATED_BY_USER_ASC
  
    """Created by user (descending)"""
    CREATED_BY_USER_DESC
  
    """Created by group"""
    CREATED_BY_GROUP_ASC
  
    """Created by group (descending)"""
    CREATED_BY_GROUP_DESC
  
    """Modified by user"""
    MODIFIED_BY_USER_ASC
  
    """Modified by user (descending)"""
    MODIFIED_BY_USER_DESC
  
    """Modified by group"""
    MODIFIED_BY_GROUP_ASC
  
    """Modified by group (descending)"""
    MODIFIED_BY_GROUP_DESC
  
    """Meta test-key"""
    META_TEST_KEY_ASC
  
    """Meta test-key (descending)"""
    META_TEST_KEY_DESC
  
    """Meta foobar"""
    META_FOOBAR_ASC
  
    """Meta foobar (descending)"""
    META_FOOBAR_DESC
  }
  
  type DocumentValidityConnection {
    """Pagination data for this connection."""
    pageInfo: PageInfo!
  
    """Contains the nodes in this connection."""
    edges: [DocumentValidityEdge]!
    totalCount: Int
  }
  
  """A Relay edge containing a `DocumentValidity` and its cursor."""
  type DocumentValidityEdge {
    """The item at the end of the edge"""
    node: ValidationResult
  
    """A cursor for use in pagination"""
    cursor: String!
  }
  
  type DynamicChoiceQuestion implements Question & DynamicQuestion & Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    slug: String!
    label: String!
  
    """Required expression is only evaluated when question is not hidden."""
    isRequired: QuestionJexl!
    isHidden: QuestionJexl!
    isArchived: Boolean!
    infoText: String
    hintText: String
    meta: GenericScalar!
    source: Question
    forms(
      offset: Int = null
      before: String = null
      after: String = null
      first: Int = null
      last: Int = null
      slug: String = null
      name: String = null
      description: String = null
      isPublished: Boolean = null
      isArchived: Boolean = null
      questions: [String] = null
      createdByUser: String = null
      createdByGroup: String = null
      modifiedByUser: String = null
      modifiedByGroup: String = null
  
      """Only return entries created after the given DateTime (Exclusive)"""
      createdBefore: DateTime = null
  
      """
      Only return entries created at or before the given DateTime (Inclusive)
      """
      createdAfter: DateTime = null
      metaHasKey: String = null
      metaValue: [JSONValueFilterType] = null
      search: String = null
  
      """FormOrdering"""
      orderBy: [FormOrdering] = null
      slugs: [String] = null
    ): FormConnection
    options(before: String = null, after: String = null, first: Int = null, last: Int = null): DataSourceDataConnection
    dataSource: String!
  
    """The ID of the object"""
    id: ID!
  }
  
  type DynamicMultipleChoiceQuestion implements Question & DynamicQuestion & Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    slug: String!
    label: String!
  
    """Required expression is only evaluated when question is not hidden."""
    isRequired: QuestionJexl!
    isHidden: QuestionJexl!
    isArchived: Boolean!
    infoText: String
    hintText: String
    meta: GenericScalar!
    source: Question
    forms(
      offset: Int = null
      before: String = null
      after: String = null
      first: Int = null
      last: Int = null
      slug: String = null
      name: String = null
      description: String = null
      isPublished: Boolean = null
      isArchived: Boolean = null
      questions: [String] = null
      createdByUser: String = null
      createdByGroup: String = null
      modifiedByUser: String = null
      modifiedByGroup: String = null
  
      """Only return entries created after the given DateTime (Exclusive)"""
      createdBefore: DateTime = null
  
      """
      Only return entries created at or before the given DateTime (Inclusive)
      """
      createdAfter: DateTime = null
      metaHasKey: String = null
      metaValue: [JSONValueFilterType] = null
      search: String = null
  
      """FormOrdering"""
      orderBy: [FormOrdering] = null
      slugs: [String] = null
    ): FormConnection
    options(before: String = null, after: String = null, first: Int = null, last: Int = null): DataSourceDataConnection
    dataSource: String!
  
    """The ID of the object"""
    id: ID!
  }
  
  type DynamicOption implements Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
  
    """The ID of the object"""
    id: ID!
    slug: String!
    label: String!
    document: Document!
    question: DynamicQuestion!
  }
  
  type DynamicOptionConnection {
    """Pagination data for this connection."""
    pageInfo: PageInfo!
  
    """Contains the nodes in this connection."""
    edges: [DynamicOptionEdge]!
    totalCount: Int
  }
  
  """A Relay edge containing a `DynamicOption` and its cursor."""
  type DynamicOptionEdge {
    """The item at the end of the edge"""
    node: DynamicOption
  
    """A cursor for use in pagination"""
    cursor: String!
  }
  
  input DynamicOptionFilterSetType {
    question: ID
    document: ID
    invert: Boolean
  }
  
  interface DynamicQuestion {
    options(before: String = null, after: String = null, first: Int = null, last: Int = null): DataSourceDataConnection
    dataSource: String!
    hintText: String
  }
  
  type File implements Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
  
    """The ID of the object"""
    id: ID!
    name: String!
    answer: FileAnswer
    uploadUrl: String
    downloadUrl: String
    metadata: GenericScalar
  }
  
  type FileAnswer implements Answer & Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
  
    """The ID of the object"""
    id: ID!
    question: Question!
    value: File!
    meta: GenericScalar!
    file: File
  }
  
  type FileQuestion implements Question & Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    slug: String!
    label: String!
  
    """Required expression is only evaluated when question is not hidden."""
    isRequired: QuestionJexl!
    isHidden: QuestionJexl!
    isArchived: Boolean!
    infoText: String
    hintText: String
    meta: GenericScalar!
    source: Question
    forms(
      offset: Int = null
      before: String = null
      after: String = null
      first: Int = null
      last: Int = null
      slug: String = null
      name: String = null
      description: String = null
      isPublished: Boolean = null
      isArchived: Boolean = null
      questions: [String] = null
      createdByUser: String = null
      createdByGroup: String = null
      modifiedByUser: String = null
      modifiedByGroup: String = null
  
      """Only return entries created after the given DateTime (Exclusive)"""
      createdBefore: DateTime = null
  
      """
      Only return entries created at or before the given DateTime (Inclusive)
      """
      createdAfter: DateTime = null
      metaHasKey: String = null
      metaValue: [JSONValueFilterType] = null
      search: String = null
  
      """FormOrdering"""
      orderBy: [FormOrdering] = null
      slugs: [String] = null
    ): FormConnection
  
    """The ID of the object"""
    id: ID!
  }
  
  type FloatAnswer implements Answer & Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
  
    """The ID of the object"""
    id: ID!
    question: Question!
    value: Float
    meta: GenericScalar!
  }
  
  type FloatQuestion implements Question & Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    slug: String!
    label: String!
  
    """Required expression is only evaluated when question is not hidden."""
    isRequired: QuestionJexl!
    isHidden: QuestionJexl!
    isArchived: Boolean!
    placeholder: String
    infoText: String
    hintText: String
    meta: GenericScalar!
    source: Question
    defaultAnswer: FloatAnswer
    forms(
      offset: Int = null
      before: String = null
      after: String = null
      first: Int = null
      last: Int = null
      slug: String = null
      name: String = null
      description: String = null
      isPublished: Boolean = null
      isArchived: Boolean = null
      questions: [String] = null
      createdByUser: String = null
      createdByGroup: String = null
      modifiedByUser: String = null
      modifiedByGroup: String = null
  
      """Only return entries created after the given DateTime (Exclusive)"""
      createdBefore: DateTime = null
  
      """
      Only return entries created at or before the given DateTime (Inclusive)
      """
      createdAfter: DateTime = null
      metaHasKey: String = null
      metaValue: [JSONValueFilterType] = null
      search: String = null
  
      """FormOrdering"""
      orderBy: [FormOrdering] = null
      slugs: [String] = null
    ): FormConnection
  
    """The ID of the object"""
    id: ID!
    minValue: Float
    maxValue: Float
  }
  
  type Flow implements Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
  
    """The ID of the object"""
    id: ID!
    next: FlowJexl!
    tasks: [Task]!
  }
  
  type FlowConnection {
    """Pagination data for this connection."""
    pageInfo: PageInfo!
  
    """Contains the nodes in this connection."""
    edges: [FlowEdge]!
    totalCount: Int
  }
  
  """A Relay edge containing a `Flow` and its cursor."""
  type FlowEdge {
    """The item at the end of the edge"""
    node: Flow
  
    """A cursor for use in pagination"""
    cursor: String!
  }
  
  input FlowFilterSetType {
    task: ID
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    createdBefore: DateTime
    createdAfter: DateTime
    invert: Boolean
  }
  
  """
  Flow jexl represents a jexl expression returning task slugs.
  
  Following transforms can be used:
  * task - return single task
  * tasks - return multiple tasks
  
  Examples:
  * 'task-slug'|task
  * ['task-slug1', 'task-slug2']|tasks
  """
  scalar FlowJexl
  
  type Form implements Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    slug: String!
    name: String!
    description: String
    meta: GenericScalar
    isPublished: Boolean!
    isArchived: Boolean!
    questions(
      offset: Int = null
      before: String = null
      after: String = null
      first: Int = null
      last: Int = null
      metaValue: [JSONValueFilterType] = null
      slug: String = null
      label: String = null
      isRequired: String = null
      isHidden: String = null
      isArchived: Boolean = null
      subForm: ID = null
      rowForm: ID = null
      createdByUser: String = null
      createdByGroup: String = null
      modifiedByUser: String = null
      modifiedByGroup: String = null
  
      """Only return entries created after the given DateTime (Exclusive)"""
      createdBefore: DateTime = null
  
      """
      Only return entries created at or before the given DateTime (Inclusive)
      """
      createdAfter: DateTime = null
      metaHasKey: String = null
      excludeForms: [ID] = null
      search: String = null
  
      """QuestionOrdering"""
      orderBy: [QuestionOrdering] = null
      slugs: [String] = null
    ): QuestionConnection
  
    """Reference this form has been copied from"""
    source: Form
    documents(offset: Int = null, before: String = null, after: String = null, first: Int = null, last: Int = null): DocumentConnection!
  
    """The ID of the object"""
    id: ID!
  }
  
  type FormConnection {
    """Pagination data for this connection."""
    pageInfo: PageInfo!
  
    """Contains the nodes in this connection."""
    edges: [FormEdge]!
    totalCount: Int
  }
  
  """A Relay edge containing a `Form` and its cursor."""
  type FormEdge {
    """The item at the end of the edge"""
    node: Form
  
    """A cursor for use in pagination"""
    cursor: String!
  }
  
  input FormFilterSetType {
    """"""
    orderBy: [FormOrdering]
    slug: String
    name: String
    description: String
    isPublished: Boolean
    isArchived: Boolean
    questions: [String]
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    createdBefore: DateTime
    createdAfter: DateTime
    metaHasKey: String
    metaValue: [JSONValueFilterType]
    search: String
    slugs: [String]
    invert: Boolean
  }
  
  input FormOrderSetType {
    meta: String
    attribute: SortableFormAttributes
    direction: AscDesc
  }
  
  """An enumeration."""
  enum FormOrdering {
    """Name"""
    NAME_ASC
  
    """Name (descending)"""
    NAME_DESC
  
    """Created at"""
    CREATED_AT_ASC
  
    """Created at (descending)"""
    CREATED_AT_DESC
  
    """Modified at"""
    MODIFIED_AT_ASC
  
    """Modified at (descending)"""
    MODIFIED_AT_DESC
  
    """Created by user"""
    CREATED_BY_USER_ASC
  
    """Created by user (descending)"""
    CREATED_BY_USER_DESC
  
    """Created by group"""
    CREATED_BY_GROUP_ASC
  
    """Created by group (descending)"""
    CREATED_BY_GROUP_DESC
  
    """Modified by user"""
    MODIFIED_BY_USER_ASC
  
    """Modified by user (descending)"""
    MODIFIED_BY_USER_DESC
  
    """Modified by group"""
    MODIFIED_BY_GROUP_ASC
  
    """Modified by group (descending)"""
    MODIFIED_BY_GROUP_DESC
  
    """Meta test-key"""
    META_TEST_KEY_ASC
  
    """Meta test-key (descending)"""
    META_TEST_KEY_DESC
  
    """Meta foobar"""
    META_FOOBAR_ASC
  
    """Meta foobar (descending)"""
    META_FOOBAR_DESC
  }
  
  type FormQuestion implements Question & Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    slug: String!
    label: String!
  
    """Required expression is only evaluated when question is not hidden."""
    isRequired: QuestionJexl!
    isHidden: QuestionJexl!
    isArchived: Boolean!
    infoText: String
    meta: GenericScalar!
    source: Question
    forms(
      offset: Int = null
      before: String = null
      after: String = null
      first: Int = null
      last: Int = null
      slug: String = null
      name: String = null
      description: String = null
      isPublished: Boolean = null
      isArchived: Boolean = null
      questions: [String] = null
      createdByUser: String = null
      createdByGroup: String = null
      modifiedByUser: String = null
      modifiedByGroup: String = null
  
      """Only return entries created after the given DateTime (Exclusive)"""
      createdBefore: DateTime = null
  
      """
      Only return entries created at or before the given DateTime (Inclusive)
      """
      createdAfter: DateTime = null
      metaHasKey: String = null
      metaValue: [JSONValueFilterType] = null
      search: String = null
  
      """FormOrdering"""
      orderBy: [FormOrdering] = null
      slugs: [String] = null
    ): FormConnection
  
    """Form referenced in a FormQuestion"""
    subForm: Form
  
    """The ID of the object"""
    id: ID!
  }
  
  type FormatValidator {
    slug: String!
    name: String!
    regex: String!
    errorMsg: String!
  }
  
  type FormatValidatorConnection {
    """Pagination data for this connection."""
    pageInfo: PageInfo!
  
    """Contains the nodes in this connection."""
    edges: [FormatValidatorEdge]!
    totalCount: Int
  }
  
  """A Relay edge containing a `FormatValidator` and its cursor."""
  type FormatValidatorEdge {
    """The item at the end of the edge"""
    node: FormatValidator
  
    """A cursor for use in pagination"""
    cursor: String!
  }
  
  """
  The `GenericScalar` scalar type represents a generic
  GraphQL scalar value that could be:
  String, Boolean, Int, Float, List or Object.
  """
  scalar GenericScalar
  
  """
  Group jexl represents a jexl expression returning group names.
  
  Following transforms can be used:
  * groups - return list of group names
  
  Examples:
  * ['group-name1', 'group-name2']|groups
  """
  scalar GroupJexl
  
  """
  Lookup type to search document structures.
  
  When using lookup `ISNULL`, the provided `value` will be ignored.
  """
  input HasAnswerFilterType {
    question: ID!
    value: GenericScalar
    lookup: AnswerLookupMode
    hierarchy: AnswerHierarchyMode
  }
  
  interface HistoricalAnswer {
    id: ID
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    question: Question!
    meta: GenericScalar!
    historyDate: DateTime!
    historyUserId: String
    historyType: String
  }
  
  type HistoricalAnswerConnection {
    """Pagination data for this connection."""
    pageInfo: PageInfo!
  
    """Contains the nodes in this connection."""
    edges: [HistoricalAnswerEdge]!
    totalCount: Int
  }
  
  """A Relay edge containing a `HistoricalAnswer` and its cursor."""
  type HistoricalAnswerEdge {
    """The item at the end of the edge"""
    node: HistoricalAnswer
  
    """A cursor for use in pagination"""
    cursor: String!
  }
  
  type HistoricalDateAnswer implements HistoricalAnswer & Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    historyQuestionType: CalumaFormHistoricalAnswerHistoryQuestionTypeChoices!
  
    """The ID of the object"""
    id: ID!
    value: Date
    meta: GenericScalar!
    historyUserId: String
    question: Question!
    historyId: UUID!
    historyDate: DateTime!
    historyChangeReason: String
    historyType: String
    date: Date
  }
  
  type HistoricalDocument implements Node {
    historyUserId: String
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
  
    """The ID of the object"""
    id: ID!
    meta: GenericScalar
    form: Form
  
    """Reference this document has been copied from"""
    source: Document
    historyDate: DateTime!
    historyType: String
    historicalAnswers(asOf: DateTime!, before: String = null, after: String = null, first: Int = null, last: Int = null): HistoricalAnswerConnection
    documentId: UUID
  }
  
  type HistoricalFile implements Node {
    """The ID of the object"""
    id: ID!
    name: String!
    downloadUrl: String
    metadata: GenericScalar
    historicalAnswer: HistoricalFileAnswer
    historyDate: DateTime!
    historyUserId: String
    historyType: String
  }
  
  type HistoricalFileAnswer implements HistoricalAnswer & Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    historyQuestionType: CalumaFormHistoricalAnswerHistoryQuestionTypeChoices!
  
    """The ID of the object"""
    id: ID!
    value(asOf: DateTime!): HistoricalFile
    meta: GenericScalar!
    historyUserId: String
    question: Question!
    historyId: UUID!
    historyDate: DateTime!
    historyChangeReason: String
    historyType: String
    file: File
  }
  
  type HistoricalFloatAnswer implements HistoricalAnswer & Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    historyQuestionType: CalumaFormHistoricalAnswerHistoryQuestionTypeChoices!
  
    """The ID of the object"""
    id: ID!
    value: Float
    meta: GenericScalar!
    historyUserId: String
    question: Question!
    historyId: UUID!
    historyDate: DateTime!
    historyChangeReason: String
    historyType: String
  }
  
  type HistoricalIntegerAnswer implements HistoricalAnswer & Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    historyQuestionType: CalumaFormHistoricalAnswerHistoryQuestionTypeChoices!
  
    """The ID of the object"""
    id: ID!
    value: Int
    meta: GenericScalar!
    historyUserId: String
    question: Question!
    historyId: UUID!
    historyDate: DateTime!
    historyChangeReason: String
    historyType: String
  }
  
  type HistoricalListAnswer implements HistoricalAnswer & Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    historyQuestionType: CalumaFormHistoricalAnswerHistoryQuestionTypeChoices!
  
    """The ID of the object"""
    id: ID!
    value: [String]
    meta: GenericScalar!
    historyUserId: String
    question: Question!
    historyId: UUID!
    historyDate: DateTime!
    historyChangeReason: String
    historyType: String
    selectedOptions(before: String = null, after: String = null, first: Int = null, last: Int = null): SelectedOptionConnection
  }
  
  type HistoricalStringAnswer implements HistoricalAnswer & Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    historyQuestionType: CalumaFormHistoricalAnswerHistoryQuestionTypeChoices!
  
    """The ID of the object"""
    id: ID!
    value: String
    meta: GenericScalar!
    historyUserId: String
    question: Question!
    historyId: UUID!
    historyDate: DateTime!
    historyChangeReason: String
    historyType: String
    selectedOption: SelectedOption
  }
  
  type HistoricalTableAnswer implements HistoricalAnswer & Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    historyQuestionType: CalumaFormHistoricalAnswerHistoryQuestionTypeChoices!
  
    """The ID of the object"""
    id: ID!
    value(asOf: DateTime!): [HistoricalDocument]
    meta: GenericScalar!
    historyUserId: String
    question: Question!
    historyId: UUID!
    historyDate: DateTime!
    historyChangeReason: String
    historyType: String
    document: Document
  }
  
  type IntegerAnswer implements Answer & Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
  
    """The ID of the object"""
    id: ID!
    question: Question!
    value: Int
    meta: GenericScalar!
  }
  
  type IntegerQuestion implements Question & Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    slug: String!
    label: String!
  
    """Required expression is only evaluated when question is not hidden."""
    isRequired: QuestionJexl!
    isHidden: QuestionJexl!
    isArchived: Boolean!
    placeholder: String
    infoText: String
    hintText: String
    meta: GenericScalar!
    source: Question
    defaultAnswer: IntegerAnswer
    forms(
      offset: Int = null
      before: String = null
      after: String = null
      first: Int = null
      last: Int = null
      slug: String = null
      name: String = null
      description: String = null
      isPublished: Boolean = null
      isArchived: Boolean = null
      questions: [String] = null
      createdByUser: String = null
      createdByGroup: String = null
      modifiedByUser: String = null
      modifiedByGroup: String = null
  
      """Only return entries created after the given DateTime (Exclusive)"""
      createdBefore: DateTime = null
  
      """
      Only return entries created at or before the given DateTime (Inclusive)
      """
      createdAfter: DateTime = null
      metaHasKey: String = null
      metaValue: [JSONValueFilterType] = null
      search: String = null
  
      """FormOrdering"""
      orderBy: [FormOrdering] = null
      slugs: [String] = null
    ): FormConnection
  
    """The ID of the object"""
    id: ID!
    maxValue: Int
    minValue: Int
  }
  
  enum JSONLookupMode {
    EXACT
    STARTSWITH
    CONTAINS
    ICONTAINS
    IN
    GTE
    GT
    LTE
    LT
  }
  
  """
  Allows use of a JSON String for input / output from the GraphQL schema.
  
  Use of this type is *not recommended* as you lose the benefits of having a defined, static
  schema (one of the key benefits of GraphQL).
  """
  scalar JSONString
  
  input JSONValueFilterType {
    key: String!
    value: GenericScalar!
    lookup: JSONLookupMode
  }
  
  type ListAnswer implements Answer & Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
  
    """The ID of the object"""
    id: ID!
    question: Question!
    value: [String]
    meta: GenericScalar!
    selectedOptions(before: String = null, after: String = null, first: Int = null, last: Int = null): SelectedOptionConnection
  }
  
  type MultipleChoiceQuestion implements Question & Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    slug: String!
    label: String!
  
    """Required expression is only evaluated when question is not hidden."""
    isRequired: QuestionJexl!
    isHidden: QuestionJexl!
    isArchived: Boolean!
    infoText: String
    hintText: String
    meta: GenericScalar!
    source: Question
    defaultAnswer: ListAnswer
    forms(
      offset: Int = null
      before: String = null
      after: String = null
      first: Int = null
      last: Int = null
      slug: String = null
      name: String = null
      description: String = null
      isPublished: Boolean = null
      isArchived: Boolean = null
      questions: [String] = null
      createdByUser: String = null
      createdByGroup: String = null
      modifiedByUser: String = null
      modifiedByGroup: String = null
  
      """Only return entries created after the given DateTime (Exclusive)"""
      createdBefore: DateTime = null
  
      """
      Only return entries created at or before the given DateTime (Inclusive)
      """
      createdAfter: DateTime = null
      metaHasKey: String = null
      metaValue: [JSONValueFilterType] = null
      search: String = null
  
      """FormOrdering"""
      orderBy: [FormOrdering] = null
      slugs: [String] = null
    ): FormConnection
    options(
      offset: Int = null
      before: String = null
      after: String = null
      first: Int = null
      last: Int = null
      metaValue: [JSONValueFilterType] = null
  
      """OptionOrdering"""
      orderBy: [OptionOrdering] = null
      slug: String = null
      label: String = null
      isArchived: Boolean = null
      createdByUser: String = null
      createdByGroup: String = null
      modifiedByUser: String = null
      modifiedByGroup: String = null
  
      """Only return entries created after the given DateTime (Exclusive)"""
      createdBefore: DateTime = null
  
      """
      Only return entries created at or before the given DateTime (Inclusive)
      """
      createdAfter: DateTime = null
      metaHasKey: String = null
      search: String = null
    ): OptionConnection
    staticContent: String
  
    """The ID of the object"""
    id: ID!
  }
  
  type Mutation {
    saveAnalyticsTable(input: SaveAnalyticsTableInput!): SaveAnalyticsTablePayload
    removeAnalyticsTable(input: RemoveAnalyticsTableInput!): RemoveAnalyticsTablePayload
    saveAnalyticsField(input: SaveAnalyticsFieldInput!): SaveAnalyticsFieldPayload
    removeAnalyticsField(input: RemoveAnalyticsFieldInput!): RemoveAnalyticsFieldPayload
    saveWorkflow(input: SaveWorkflowInput!): SaveWorkflowPayload
    addWorkflowFlow(input: AddWorkflowFlowInput!): AddWorkflowFlowPayload
    removeFlow(input: RemoveFlowInput!): RemoveFlowPayload
    saveSimpleTask(input: SaveSimpleTaskInput!): SaveSimpleTaskPayload
    saveCompleteWorkflowFormTask(input: SaveCompleteWorkflowFormTaskInput!): SaveCompleteWorkflowFormTaskPayload
    saveCompleteTaskFormTask(input: SaveCompleteTaskFormTaskInput!): SaveCompleteTaskFormTaskPayload
    startCase(input: StartCaseInput!): StartCasePayload @deprecated(reason: "Use SaveCase mutation instead")
    saveCase(input: SaveCaseInput!): SaveCasePayload
    cancelCase(input: CancelCaseInput!): CancelCasePayload
    suspendCase(input: SuspendCaseInput!): SuspendCasePayload
    resumeCase(input: ResumeCaseInput!): ResumeCasePayload
    completeWorkItem(input: CompleteWorkItemInput!): CompleteWorkItemPayload
    skipWorkItem(input: SkipWorkItemInput!): SkipWorkItemPayload
    cancelWorkItem(input: CancelWorkItemInput!): CancelWorkItemPayload
    suspendWorkItem(input: SuspendWorkItemInput!): SuspendWorkItemPayload
    resumeWorkItem(input: ResumeWorkItemInput!): ResumeWorkItemPayload
    redoWorkItem(input: RedoWorkItemInput!): RedoWorkItemPayload
    saveWorkItem(input: SaveWorkItemInput!): SaveWorkItemPayload
    createWorkItem(input: CreateWorkItemInput!): CreateWorkItemPayload
    saveForm(input: SaveFormInput!): SaveFormPayload
    copyForm(input: CopyFormInput!): CopyFormPayload
  
    """Add question at the end of form."""
    addFormQuestion(input: AddFormQuestionInput!): AddFormQuestionPayload
    removeFormQuestion(input: RemoveFormQuestionInput!): RemoveFormQuestionPayload
    reorderFormQuestions(input: ReorderFormQuestionsInput!): ReorderFormQuestionsPayload
    saveOption(input: SaveOptionInput!): SaveOptionPayload
    copyOption(input: CopyOptionInput!): CopyOptionPayload
    copyQuestion(input: CopyQuestionInput!): CopyQuestionPayload
    saveTextQuestion(input: SaveTextQuestionInput!): SaveTextQuestionPayload
    saveTextareaQuestion(input: SaveTextareaQuestionInput!): SaveTextareaQuestionPayload
    saveDateQuestion(input: SaveDateQuestionInput!): SaveDateQuestionPayload
    saveChoiceQuestion(input: SaveChoiceQuestionInput!): SaveChoiceQuestionPayload
    saveMultipleChoiceQuestion(input: SaveMultipleChoiceQuestionInput!): SaveMultipleChoiceQuestionPayload
    saveDynamicChoiceQuestion(input: SaveDynamicChoiceQuestionInput!): SaveDynamicChoiceQuestionPayload
    saveDynamicMultipleChoiceQuestion(input: SaveDynamicMultipleChoiceQuestionInput!): SaveDynamicMultipleChoiceQuestionPayload
    saveFloatQuestion(input: SaveFloatQuestionInput!): SaveFloatQuestionPayload
    saveIntegerQuestion(input: SaveIntegerQuestionInput!): SaveIntegerQuestionPayload
    saveTableQuestion(input: SaveTableQuestionInput!): SaveTableQuestionPayload
    saveFormQuestion(input: SaveFormQuestionInput!): SaveFormQuestionPayload
    saveFileQuestion(input: SaveFileQuestionInput!): SaveFileQuestionPayload
    saveStaticQuestion(input: SaveStaticQuestionInput!): SaveStaticQuestionPayload
    saveCalculatedFloatQuestion(input: SaveCalculatedFloatQuestionInput!): SaveCalculatedFloatQuestionPayload
    saveActionButtonQuestion(input: SaveActionButtonQuestionInput!): SaveActionButtonQuestionPayload
    copyDocument(input: CopyDocumentInput!): CopyDocumentPayload
    saveDocument(input: SaveDocumentInput!): SaveDocumentPayload
    saveDocumentStringAnswer(input: SaveDocumentStringAnswerInput!): SaveDocumentStringAnswerPayload
    saveDocumentIntegerAnswer(input: SaveDocumentIntegerAnswerInput!): SaveDocumentIntegerAnswerPayload
    saveDocumentFloatAnswer(input: SaveDocumentFloatAnswerInput!): SaveDocumentFloatAnswerPayload
    saveDocumentDateAnswer(input: SaveDocumentDateAnswerInput!): SaveDocumentDateAnswerPayload
    saveDocumentListAnswer(input: SaveDocumentListAnswerInput!): SaveDocumentListAnswerPayload
    saveDocumentTableAnswer(input: SaveDocumentTableAnswerInput!): SaveDocumentTableAnswerPayload
    saveDocumentFileAnswer(input: SaveDocumentFileAnswerInput!): SaveDocumentFileAnswerPayload
    saveDefaultStringAnswer(input: SaveDefaultStringAnswerInput!): SaveDefaultStringAnswerPayload
    saveDefaultIntegerAnswer(input: SaveDefaultIntegerAnswerInput!): SaveDefaultIntegerAnswerPayload
    saveDefaultFloatAnswer(input: SaveDefaultFloatAnswerInput!): SaveDefaultFloatAnswerPayload
    saveDefaultDateAnswer(input: SaveDefaultDateAnswerInput!): SaveDefaultDateAnswerPayload
    saveDefaultListAnswer(input: SaveDefaultListAnswerInput!): SaveDefaultListAnswerPayload
    saveDefaultTableAnswer(input: SaveDefaultTableAnswerInput!): SaveDefaultTableAnswerPayload
    removeAnswer(input: RemoveAnswerInput!): RemoveAnswerPayload
    removeDefaultAnswer(input: RemoveDefaultAnswerInput!): RemoveDefaultAnswerPayload
    removeDocument(input: RemoveDocumentInput!): RemoveDocumentPayload
  }
  
  """An object with an ID"""
  interface Node {
    """The ID of the object"""
    id: ID!
  }
  
  type Option implements Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    slug: String!
    label: String!
    isArchived: Boolean!
    meta: GenericScalar
  
    """Reference this option has been copied from"""
    source: Option
  
    """The ID of the object"""
    id: ID!
  }
  
  type OptionConnection {
    """Pagination data for this connection."""
    pageInfo: PageInfo!
  
    """Contains the nodes in this connection."""
    edges: [OptionEdge]!
    totalCount: Int
  }
  
  """A Relay edge containing a `Option` and its cursor."""
  type OptionEdge {
    """The item at the end of the edge"""
    node: Option
  
    """A cursor for use in pagination"""
    cursor: String!
  }
  
  """An enumeration."""
  enum OptionOrdering {
    """Label"""
    LABEL_ASC
  
    """Label (descending)"""
    LABEL_DESC
  
    """Created at"""
    CREATED_AT_ASC
  
    """Created at (descending)"""
    CREATED_AT_DESC
  
    """Modified at"""
    MODIFIED_AT_ASC
  
    """Modified at (descending)"""
    MODIFIED_AT_DESC
  
    """Created by user"""
    CREATED_BY_USER_ASC
  
    """Created by user (descending)"""
    CREATED_BY_USER_DESC
  
    """Created by group"""
    CREATED_BY_GROUP_ASC
  
    """Created by group (descending)"""
    CREATED_BY_GROUP_DESC
  
    """Modified by user"""
    MODIFIED_BY_USER_ASC
  
    """Modified by user (descending)"""
    MODIFIED_BY_USER_DESC
  
    """Modified by group"""
    MODIFIED_BY_GROUP_ASC
  
    """Modified by group (descending)"""
    MODIFIED_BY_GROUP_DESC
  
    """Meta test-key"""
    META_TEST_KEY_ASC
  
    """Meta test-key (descending)"""
    META_TEST_KEY_DESC
  
    """Meta foobar"""
    META_FOOBAR_ASC
  
    """Meta foobar (descending)"""
    META_FOOBAR_DESC
  }
  
  """
  The Relay compliant `PageInfo` type, containing data necessary to paginate this connection.
  """
  type PageInfo {
    """When paginating forwards, are there more items?"""
    hasNextPage: Boolean!
  
    """When paginating backwards, are there more items?"""
    hasPreviousPage: Boolean!
  
    """When paginating backwards, the cursor to continue."""
    startCursor: String
  
    """When paginating forwards, the cursor to continue."""
    endCursor: String
  }
  
  type Query {
    documentAsOf(id: ID!, asOf: DateTime!): HistoricalDocument
    allAnalyticsTables(
      offset: Int = null
      before: String = null
      after: String = null
      first: Int = null
      last: Int = null
      metaValue: [JSONValueFilterType] = null
      slug: String = null
      name: String = null
      filter: [AnalyticsTableFilterSetType] = null
      order: [AnalyticsTableOrderSetType] = null
      createdByUser: String = null
      createdByGroup: String = null
      modifiedByUser: String = null
      modifiedByGroup: String = null
  
      """Only return entries created after the given DateTime (Exclusive)"""
      createdBefore: DateTime = null
  
      """
      Only return entries created at or before the given DateTime (Inclusive)
      """
      createdAfter: DateTime = null
      metaHasKey: String = null
      search: String = null
      slugs: [String] = null
    ): AnalyticsTableConnection
    analyticsTable(slug: String!): AnalyticsTable
    allAnalyticsFields(
      offset: Int = null
      before: String = null
      after: String = null
      first: Int = null
      last: Int = null
      metaValue: [JSONValueFilterType] = null
      alias: String = null
      table: ID = null
      filter: [AnalyticsFieldFilterSetType] = null
      createdByUser: String = null
      createdByGroup: String = null
      modifiedByUser: String = null
      modifiedByGroup: String = null
  
      """Only return entries created after the given DateTime (Exclusive)"""
      createdBefore: DateTime = null
  
      """
      Only return entries created at or before the given DateTime (Inclusive)
      """
      createdAfter: DateTime = null
      metaHasKey: String = null
      search: String = null
      slugs: [String] = null
    ): AnalyticsFieldConnection
    allDataSources(before: String = null, after: String = null, first: Int = null, last: Int = null): DataSourceConnection
    dataSource(name: String!, before: String = null, after: String = null, first: Int = null, last: Int = null): DataSourceDataConnection
    allWorkflows(
      offset: Int = null
      before: String = null
      after: String = null
      first: Int = null
      last: Int = null
      metaValue: [JSONValueFilterType] = null
      slug: String = null
      name: String = null
      description: String = null
      isPublished: Boolean = null
      isArchived: Boolean = null
  
      """WorkflowOrdering"""
      orderBy: [WorkflowOrdering] = null
      filter: [WorkflowFilterSetType] = null
      order: [WorkflowOrderSetType] = null
      createdByUser: String = null
      createdByGroup: String = null
      modifiedByUser: String = null
      modifiedByGroup: String = null
  
      """Only return entries created after the given DateTime (Exclusive)"""
      createdBefore: DateTime = null
  
      """
      Only return entries created at or before the given DateTime (Inclusive)
      """
      createdAfter: DateTime = null
      metaHasKey: String = null
      search: String = null
    ): WorkflowConnection
    allTasks(
      offset: Int = null
      before: String = null
      after: String = null
      first: Int = null
      last: Int = null
      metaValue: [JSONValueFilterType] = null
      slug: String = null
      name: String = null
      description: String = null
      type: TaskTypeArgument = null
      isArchived: Boolean = null
  
      """TaskOrdering"""
      orderBy: [TaskOrdering] = null
      filter: [TaskFilterSetType] = null
      order: [TaskOrderSetType] = null
      createdByUser: String = null
      createdByGroup: String = null
      modifiedByUser: String = null
      modifiedByGroup: String = null
  
      """Only return entries created after the given DateTime (Exclusive)"""
      createdBefore: DateTime = null
  
      """
      Only return entries created at or before the given DateTime (Inclusive)
      """
      createdAfter: DateTime = null
      metaHasKey: String = null
      search: String = null
    ): TaskConnection
    allCases(
      offset: Int = null
      before: String = null
      after: String = null
      first: Int = null
      last: Int = null
      metaValue: [JSONValueFilterType] = null
      workflow: ID = null
  
      """CaseOrdering"""
      orderBy: [CaseOrdering] = null
      filter: [CaseFilterSetType] = null
      order: [CaseOrderSetType] = null
      createdByUser: String = null
      createdByGroup: String = null
      modifiedByUser: String = null
      modifiedByGroup: String = null
  
      """Only return entries created after the given DateTime (Exclusive)"""
      createdBefore: DateTime = null
  
      """
      Only return entries created at or before the given DateTime (Inclusive)
      """
      createdAfter: DateTime = null
      metaHasKey: String = null
      id: ID = null
      documentForm: String = null
      documentForms: [String] = null
      hasAnswer: [HasAnswerFilterType] = null
      workItemDocumentHasAnswer: [HasAnswerFilterType] = null
      rootCase: ID = null
      searchAnswers: [SearchAnswersFilterType] = null
      status: [[CaseStatusArgument]] = null
  
      """
      Expects a question slug. If the slug is prefixed with a hyphen, the order will be reversed
      
      For file questions, the filename is used for sorting.
      
      Table questions are not supported at this time.
      """
      orderByQuestionAnswerValue: String = null
    ): CaseConnection
    allWorkItems(
      offset: Int = null
      before: String = null
      after: String = null
      first: Int = null
      last: Int = null
      metaValue: [JSONValueFilterType] = null
      status: WorkItemStatusArgument = null
  
      """WorkItemOrdering"""
      orderBy: [WorkItemOrdering] = null
      filter: [WorkItemFilterSetType] = null
      order: [WorkItemOrderSetType] = null
      documentHasAnswer: [HasAnswerFilterType] = null
      caseDocumentHasAnswer: [HasAnswerFilterType] = null
      caseMetaValue: [JSONValueFilterType] = null
      rootCaseMetaValue: [JSONValueFilterType] = null
      name: String = null
      task: ID = null
      tasks: [String] = null
      case: ID = null
      createdAt: DateTime = null
      closedAt: DateTime = null
      modifiedAt: DateTime = null
      deadline: DateTime = null
      hasDeadline: Boolean = null
      caseFamily: ID = null
      createdByUser: String = null
      createdByGroup: String = null
      modifiedByUser: String = null
      modifiedByGroup: String = null
  
      """Only return entries created after the given DateTime (Exclusive)"""
      createdBefore: DateTime = null
  
      """
      Only return entries created at or before the given DateTime (Inclusive)
      """
      createdAfter: DateTime = null
      metaHasKey: String = null
      id: ID = null
      addressedGroups: [String] = null
      controllingGroups: [String] = null
      assignedUsers: [String] = null
    ): WorkItemConnection
    allForms(
      offset: Int = null
      before: String = null
      after: String = null
      first: Int = null
      last: Int = null
      metaValue: [JSONValueFilterType] = null
  
      """FormOrdering"""
      orderBy: [FormOrdering] = null
      slug: String = null
      name: String = null
      description: String = null
      isPublished: Boolean = null
      isArchived: Boolean = null
      questions: [String] = null
      filter: [FormFilterSetType] = null
      order: [FormOrderSetType] = null
      createdByUser: String = null
      createdByGroup: String = null
      modifiedByUser: String = null
      modifiedByGroup: String = null
  
      """Only return entries created after the given DateTime (Exclusive)"""
      createdBefore: DateTime = null
  
      """
      Only return entries created at or before the given DateTime (Inclusive)
      """
      createdAfter: DateTime = null
      metaHasKey: String = null
      search: String = null
      slugs: [String] = null
    ): FormConnection
    allQuestions(
      offset: Int = null
      before: String = null
      after: String = null
      first: Int = null
      last: Int = null
      metaValue: [JSONValueFilterType] = null
  
      """QuestionOrdering"""
      orderBy: [QuestionOrdering] = null
      slug: String = null
      label: String = null
      isRequired: String = null
      isHidden: String = null
      isArchived: Boolean = null
      subForm: ID = null
      rowForm: ID = null
      filter: [QuestionFilterSetType] = null
      order: [QuestionOrderSetType] = null
      createdByUser: String = null
      createdByGroup: String = null
      modifiedByUser: String = null
      modifiedByGroup: String = null
  
      """Only return entries created after the given DateTime (Exclusive)"""
      createdBefore: DateTime = null
  
      """
      Only return entries created at or before the given DateTime (Inclusive)
      """
      createdAfter: DateTime = null
      metaHasKey: String = null
      excludeForms: [ID] = null
      search: String = null
      slugs: [String] = null
    ): QuestionConnection
    allDocuments(
      offset: Int = null
      before: String = null
      after: String = null
      first: Int = null
      last: Int = null
      metaValue: [JSONValueFilterType] = null
      form: ID = null
      forms: [ID] = null
      search: String = null
      id: ID = null
  
      """DocumentOrdering"""
      orderBy: [DocumentOrdering] = null
      filter: [DocumentFilterSetType] = null
      order: [DocumentOrderSetType] = null
      createdByUser: String = null
      createdByGroup: String = null
      modifiedByUser: String = null
      modifiedByGroup: String = null
  
      """Only return entries created after the given DateTime (Exclusive)"""
      createdBefore: DateTime = null
  
      """
      Only return entries created at or before the given DateTime (Inclusive)
      """
      createdAfter: DateTime = null
      metaHasKey: String = null
      rootDocument: ID = null
      hasAnswer: [HasAnswerFilterType] = null
      searchAnswers: [SearchAnswersFilterType] = null
    ): DocumentConnection
    allFormatValidators(before: String = null, after: String = null, first: Int = null, last: Int = null): FormatValidatorConnection
    allUsedDynamicOptions(
      offset: Int = null
      before: String = null
      after: String = null
      first: Int = null
      last: Int = null
      question: ID = null
      document: ID = null
      filter: [DynamicOptionFilterSetType] = null
      createdByUser: String = null
      createdByGroup: String = null
      modifiedByUser: String = null
      modifiedByGroup: String = null
  
      """Only return entries created after the given DateTime (Exclusive)"""
      createdBefore: DateTime = null
  
      """
      Only return entries created at or before the given DateTime (Inclusive)
      """
      createdAfter: DateTime = null
    ): DynamicOptionConnection
    documentValidity(id: ID!, before: String = null, after: String = null, first: Int = null, last: Int = null): DocumentValidityConnection
    node(
      """The ID of the object"""
      id: ID!
    ): Node
    _debug: DjangoDebug
  }
  
  interface Question {
    id: ID!
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    slug: String!
    label: String!
    infoText: String
  
    """Required expression is only evaluated when question is not hidden."""
    isRequired: QuestionJexl!
    isHidden: QuestionJexl!
    isArchived: Boolean!
    meta: GenericScalar!
    forms(
      offset: Int = null
      before: String = null
      after: String = null
      first: Int = null
      last: Int = null
      slug: String = null
      name: String = null
      description: String = null
      isPublished: Boolean = null
      isArchived: Boolean = null
      questions: [String] = null
      createdByUser: String = null
      createdByGroup: String = null
      modifiedByUser: String = null
      modifiedByGroup: String = null
  
      """Only return entries created after the given DateTime (Exclusive)"""
      createdBefore: DateTime = null
  
      """
      Only return entries created at or before the given DateTime (Inclusive)
      """
      createdAfter: DateTime = null
      metaHasKey: String = null
      metaValue: [JSONValueFilterType] = null
      search: String = null
  
      """FormOrdering"""
      orderBy: [FormOrdering] = null
      slugs: [String] = null
    ): FormConnection
    source: Question
  }
  
  type QuestionConnection {
    """Pagination data for this connection."""
    pageInfo: PageInfo!
  
    """Contains the nodes in this connection."""
    edges: [QuestionEdge]!
    totalCount: Int
  }
  
  """A Relay edge containing a `Question` and its cursor."""
  type QuestionEdge {
    """The item at the end of the edge"""
    node: Question
  
    """A cursor for use in pagination"""
    cursor: String!
  }
  
  input QuestionFilterSetType {
    """"""
    orderBy: [QuestionOrdering]
    slug: String
    label: String
    isRequired: String
    isHidden: String
    isArchived: Boolean
    subForm: ID
    rowForm: ID
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    createdBefore: DateTime
    createdAfter: DateTime
    metaHasKey: String
    metaValue: [JSONValueFilterType]
    excludeForms: [ID]
    search: String
    slugs: [String]
    invert: Boolean
  }
  
  """
  Question jexl expression returning boolean.
  
  Following transform can be used:
  * answer - access answer of document by question slug
  * mapby - map list by key. Helpful to work with table answers
    whereas an answer is a list of dicts.
  
  Following context is available:
  * form - access form of document
  
  Examples:
  * 'answer' == 'question-slug'|answer
  * 'answer' in 'list-question-slug'|answer
  * 'answer' in 'table-question-slug'|answer|mapby('column-question')
  * 'form-slug' == form
  """
  scalar QuestionJexl
  
  input QuestionOrderSetType {
    meta: String
    attribute: SortableQuestionAttributes
    direction: AscDesc
  }
  
  """An enumeration."""
  enum QuestionOrdering {
    """Label"""
    LABEL_ASC
  
    """Label (descending)"""
    LABEL_DESC
  
    """Created at"""
    CREATED_AT_ASC
  
    """Created at (descending)"""
    CREATED_AT_DESC
  
    """Modified at"""
    MODIFIED_AT_ASC
  
    """Modified at (descending)"""
    MODIFIED_AT_DESC
  
    """Created by user"""
    CREATED_BY_USER_ASC
  
    """Created by user (descending)"""
    CREATED_BY_USER_DESC
  
    """Created by group"""
    CREATED_BY_GROUP_ASC
  
    """Created by group (descending)"""
    CREATED_BY_GROUP_DESC
  
    """Modified by user"""
    MODIFIED_BY_USER_ASC
  
    """Modified by user (descending)"""
    MODIFIED_BY_USER_DESC
  
    """Modified by group"""
    MODIFIED_BY_GROUP_ASC
  
    """Modified by group (descending)"""
    MODIFIED_BY_GROUP_DESC
  
    """Meta test-key"""
    META_TEST_KEY_ASC
  
    """Meta test-key (descending)"""
    META_TEST_KEY_DESC
  
    """Meta foobar"""
    META_FOOBAR_ASC
  
    """Meta foobar (descending)"""
    META_FOOBAR_DESC
  }
  
  input RedoWorkItemInput {
    id: ID!
  
    """Provide extra context for dynamic jexl transforms and events"""
    context: JSONString
    clientMutationId: String
  }
  
  type RedoWorkItemPayload {
    workItem: WorkItem
    clientMutationId: String
  }
  
  input RemoveAnalyticsFieldInput {
    id: ID!
    clientMutationId: String
  }
  
  type RemoveAnalyticsFieldPayload {
    analyticsField: AnalyticsField
    clientMutationId: String
  }
  
  input RemoveAnalyticsTableInput {
    slug: ID!
    clientMutationId: String
  }
  
  type RemoveAnalyticsTablePayload {
    analyticsTable: AnalyticsTable
    clientMutationId: String
  }
  
  input RemoveAnswerInput {
    answer: ID!
    clientMutationId: String
  }
  
  type RemoveAnswerPayload {
    answer: Answer
    clientMutationId: String
  }
  
  input RemoveDefaultAnswerInput {
    question: ID!
    clientMutationId: String
  }
  
  type RemoveDefaultAnswerPayload {
    question: Question
    clientMutationId: String
  }
  
  input RemoveDocumentInput {
    document: ID!
    clientMutationId: String
  }
  
  type RemoveDocumentPayload {
    document: Document
    clientMutationId: String
  }
  
  input RemoveFlowInput {
    flow: ID!
    clientMutationId: String
  }
  
  type RemoveFlowPayload {
    flow: Flow
    clientMutationId: String
  }
  
  input RemoveFormQuestionInput {
    form: ID!
    question: ID!
    clientMutationId: String
  }
  
  type RemoveFormQuestionPayload {
    form: Form
    clientMutationId: String
  }
  
  input ReorderFormQuestionsInput {
    form: ID!
    questions: [ID]!
    clientMutationId: String
  }
  
  type ReorderFormQuestionsPayload {
    form: Form
    clientMutationId: String
  }
  
  input ResumeCaseInput {
    id: ID!
  
    """Provide extra context for dynamic jexl transforms and events"""
    context: JSONString
    clientMutationId: String
  }
  
  type ResumeCasePayload {
    case: Case
    clientMutationId: String
  }
  
  input ResumeWorkItemInput {
    id: ID!
  
    """Provide extra context for dynamic jexl transforms and events"""
    context: JSONString
    clientMutationId: String
  }
  
  type ResumeWorkItemPayload {
    workItem: WorkItem
    clientMutationId: String
  }
  
  input SaveActionButtonQuestionInput {
    label: String!
    slug: String!
    infoText: String
    isHidden: QuestionJexl
    meta: JSONString
    isArchived: Boolean
    action: ButtonAction!
    color: ButtonColor!
    validateOnEnter: Boolean!
    clientMutationId: String
  }
  
  type SaveActionButtonQuestionPayload {
    question: Question
    clientMutationId: String
  }
  
  input SaveAnalyticsFieldInput {
    id: ID
    alias: String!
    table: ID!
    dataSource: String!
    filters: [String]
    meta: JSONString
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    clientMutationId: String
  }
  
  type SaveAnalyticsFieldPayload {
    analyticsField: AnalyticsField
    clientMutationId: String
  }
  
  input SaveAnalyticsTableInput {
    slug: String!
    name: String!
    startingObject: StartingObject!
    disableVisibilities: Boolean
    meta: JSONString
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    clientMutationId: String
  }
  
  type SaveAnalyticsTablePayload {
    analyticsTable: AnalyticsTable
    clientMutationId: String
  }
  
  input SaveCalculatedFloatQuestionInput {
    slug: String!
    label: String!
    infoText: String
    isRequired: QuestionJexl
    isHidden: QuestionJexl
    meta: JSONString
    isArchived: Boolean
    calcExpression: QuestionJexl
    hintText: String
    clientMutationId: String
  }
  
  type SaveCalculatedFloatQuestionPayload {
    question: Question
    clientMutationId: String
  }
  
  input SaveCaseInput {
    id: String
    workflow: ID!
    meta: JSONString
    parentWorkItem: ID
    form: ID
  
    """Provide extra context for dynamic jexl transforms and events"""
    context: JSONString
    clientMutationId: String
  }
  
  type SaveCasePayload {
    case: Case
    clientMutationId: String
  }
  
  input SaveChoiceQuestionInput {
    slug: String!
    label: String!
    infoText: String
    isRequired: QuestionJexl
    isHidden: QuestionJexl
    meta: JSONString
    isArchived: Boolean
    options: [ID]!
    hintText: String
    clientMutationId: String
  }
  
  type SaveChoiceQuestionPayload {
    question: Question
    clientMutationId: String
  }
  
  input SaveCompleteTaskFormTaskInput {
    slug: String!
    name: String!
    description: String
    meta: JSONString
  
    """
    Group jexl returning what group(s) derived work items will be addressed to.
    """
    addressGroups: GroupJexl
  
    """
    Group jexl returning what group(s) derived work items will be assigned to for controlling.
    """
    controlGroups: GroupJexl
    isArchived: Boolean
  
    """Time in seconds task may take to be processed."""
    leadTime: Int
  
    """
    Allows creating multiple work items for this task using the `CreateWorkItem` mutation. If true, one work item will be created for each entry in `address_groups`.
    """
    isMultipleInstance: Boolean
  
    """
    Whether to continue the flow if the multiple instance work item has ready siblings
    """
    continueAsync: Boolean
    form: ID!
    clientMutationId: String
  }
  
  type SaveCompleteTaskFormTaskPayload {
    task: Task
    clientMutationId: String
  }
  
  input SaveCompleteWorkflowFormTaskInput {
    slug: String!
    name: String!
    description: String
    meta: JSONString
  
    """
    Group jexl returning what group(s) derived work items will be addressed to.
    """
    addressGroups: GroupJexl
  
    """
    Group jexl returning what group(s) derived work items will be assigned to for controlling.
    """
    controlGroups: GroupJexl
    isArchived: Boolean
  
    """Time in seconds task may take to be processed."""
    leadTime: Int
  
    """
    Allows creating multiple work items for this task using the `CreateWorkItem` mutation. If true, one work item will be created for each entry in `address_groups`.
    """
    isMultipleInstance: Boolean
  
    """
    Whether to continue the flow if the multiple instance work item has ready siblings
    """
    continueAsync: Boolean
    clientMutationId: String
  }
  
  type SaveCompleteWorkflowFormTaskPayload {
    task: Task
    clientMutationId: String
  }
  
  input SaveDateQuestionInput {
    slug: String!
    label: String!
    infoText: String
    isRequired: QuestionJexl
    isHidden: QuestionJexl
    meta: JSONString
    isArchived: Boolean
    hintText: String
    clientMutationId: String
  }
  
  type SaveDateQuestionPayload {
    question: Question
    clientMutationId: String
  }
  
  input SaveDefaultDateAnswerInput {
    question: ID!
    meta: JSONString
    value: Date
    clientMutationId: String
  }
  
  type SaveDefaultDateAnswerPayload {
    answer: Answer
    clientMutationId: String
  }
  
  input SaveDefaultFloatAnswerInput {
    question: ID!
    meta: JSONString
    value: Float
    clientMutationId: String
  }
  
  type SaveDefaultFloatAnswerPayload {
    answer: Answer
    clientMutationId: String
  }
  
  input SaveDefaultIntegerAnswerInput {
    question: ID!
    meta: JSONString
    value: Int
    clientMutationId: String
  }
  
  type SaveDefaultIntegerAnswerPayload {
    answer: Answer
    clientMutationId: String
  }
  
  input SaveDefaultListAnswerInput {
    question: ID!
    meta: JSONString
    value: [String]
    clientMutationId: String
  }
  
  type SaveDefaultListAnswerPayload {
    answer: Answer
    clientMutationId: String
  }
  
  input SaveDefaultStringAnswerInput {
    question: ID!
    meta: JSONString
    value: String
    clientMutationId: String
  }
  
  type SaveDefaultStringAnswerPayload {
    answer: Answer
    clientMutationId: String
  }
  
  input SaveDefaultTableAnswerInput {
    question: ID!
    meta: JSONString
  
    """List of document IDs representing the rows in the table."""
    value: [ID]
    clientMutationId: String
  }
  
  type SaveDefaultTableAnswerPayload {
    answer: Answer
    clientMutationId: String
  }
  
  input SaveDocumentDateAnswerInput {
    question: ID!
    document: ID!
    meta: JSONString
    value: Date
    clientMutationId: String
  }
  
  type SaveDocumentDateAnswerPayload {
    answer: Answer
    clientMutationId: String
  }
  
  input SaveDocumentFileAnswerInput {
    question: ID!
    document: ID!
    meta: JSONString
    value: String
    clientMutationId: String
  }
  
  type SaveDocumentFileAnswerPayload {
    answer: Answer
    clientMutationId: String
  }
  
  input SaveDocumentFloatAnswerInput {
    question: ID!
    document: ID!
    meta: JSONString
    value: Float
    clientMutationId: String
  }
  
  type SaveDocumentFloatAnswerPayload {
    answer: Answer
    clientMutationId: String
  }
  
  input SaveDocumentInput {
    id: String
    form: ID!
    meta: JSONString
    clientMutationId: String
  }
  
  input SaveDocumentIntegerAnswerInput {
    question: ID!
    document: ID!
    meta: JSONString
    value: Int
    clientMutationId: String
  }
  
  type SaveDocumentIntegerAnswerPayload {
    answer: Answer
    clientMutationId: String
  }
  
  input SaveDocumentListAnswerInput {
    question: ID!
    document: ID!
    meta: JSONString
    value: [String]
    clientMutationId: String
  }
  
  type SaveDocumentListAnswerPayload {
    answer: Answer
    clientMutationId: String
  }
  
  type SaveDocumentPayload {
    document: Document
    clientMutationId: String
  }
  
  input SaveDocumentStringAnswerInput {
    question: ID!
    document: ID!
    meta: JSONString
    value: String
    clientMutationId: String
  }
  
  type SaveDocumentStringAnswerPayload {
    answer: Answer
    clientMutationId: String
  }
  
  input SaveDocumentTableAnswerInput {
    question: ID!
    document: ID!
    meta: JSONString
  
    """List of document IDs representing the rows in the table."""
    value: [ID]
    clientMutationId: String
  }
  
  type SaveDocumentTableAnswerPayload {
    answer: Answer
    clientMutationId: String
  }
  
  input SaveDynamicChoiceQuestionInput {
    slug: String!
    label: String!
    infoText: String
    isRequired: QuestionJexl
    isHidden: QuestionJexl
    meta: JSONString
    isArchived: Boolean
    dataSource: String!
    hintText: String
    clientMutationId: String
  }
  
  type SaveDynamicChoiceQuestionPayload {
    question: Question
    clientMutationId: String
  }
  
  input SaveDynamicMultipleChoiceQuestionInput {
    slug: String!
    label: String!
    infoText: String
    isRequired: QuestionJexl
    isHidden: QuestionJexl
    meta: JSONString
    isArchived: Boolean
    dataSource: String!
    hintText: String
    clientMutationId: String
  }
  
  type SaveDynamicMultipleChoiceQuestionPayload {
    question: Question
    clientMutationId: String
  }
  
  input SaveFileQuestionInput {
    slug: String!
    label: String!
    infoText: String
    isRequired: QuestionJexl
    isHidden: QuestionJexl
    meta: JSONString
    isArchived: Boolean
    hintText: String
    clientMutationId: String
  }
  
  type SaveFileQuestionPayload {
    question: Question
    clientMutationId: String
  }
  
  input SaveFloatQuestionInput {
    slug: String!
    label: String!
    infoText: String
    isRequired: QuestionJexl
    isHidden: QuestionJexl
    meta: JSONString
    isArchived: Boolean
    minValue: Float
    maxValue: Float
    placeholder: String
    hintText: String
    clientMutationId: String
  }
  
  type SaveFloatQuestionPayload {
    question: Question
    clientMutationId: String
  }
  
  input SaveFormInput {
    slug: String!
    name: String!
    description: String
    meta: JSONString
    isArchived: Boolean
    isPublished: Boolean
    clientMutationId: String
  }
  
  type SaveFormPayload {
    form: Form
    clientMutationId: String
  }
  
  input SaveFormQuestionInput {
    slug: String!
    label: String!
    infoText: String
    isRequired: QuestionJexl
    isHidden: QuestionJexl
    meta: JSONString
    isArchived: Boolean
    subForm: ID!
    clientMutationId: String
  }
  
  type SaveFormQuestionPayload {
    question: Question
    clientMutationId: String
  }
  
  input SaveIntegerQuestionInput {
    slug: String!
    label: String!
    infoText: String
    isRequired: QuestionJexl
    isHidden: QuestionJexl
    meta: JSONString
    isArchived: Boolean
    minValue: Int
    maxValue: Int
    placeholder: String
    hintText: String
    clientMutationId: String
  }
  
  type SaveIntegerQuestionPayload {
    question: Question
    clientMutationId: String
  }
  
  input SaveMultipleChoiceQuestionInput {
    slug: String!
    label: String!
    infoText: String
    isRequired: QuestionJexl
    isHidden: QuestionJexl
    meta: JSONString
    isArchived: Boolean
    options: [ID]!
    hintText: String
    clientMutationId: String
  }
  
  type SaveMultipleChoiceQuestionPayload {
    question: Question
    clientMutationId: String
  }
  
  input SaveOptionInput {
    slug: String!
    label: String!
    isArchived: Boolean
    meta: JSONString
    clientMutationId: String
  }
  
  type SaveOptionPayload {
    option: Option
    clientMutationId: String
  }
  
  input SaveSimpleTaskInput {
    slug: String!
    name: String!
    description: String
    meta: JSONString
  
    """
    Group jexl returning what group(s) derived work items will be addressed to.
    """
    addressGroups: GroupJexl
  
    """
    Group jexl returning what group(s) derived work items will be assigned to for controlling.
    """
    controlGroups: GroupJexl
    isArchived: Boolean
  
    """Time in seconds task may take to be processed."""
    leadTime: Int
  
    """
    Allows creating multiple work items for this task using the `CreateWorkItem` mutation. If true, one work item will be created for each entry in `address_groups`.
    """
    isMultipleInstance: Boolean
  
    """
    Whether to continue the flow if the multiple instance work item has ready siblings
    """
    continueAsync: Boolean
    clientMutationId: String
  }
  
  type SaveSimpleTaskPayload {
    task: Task
    clientMutationId: String
  }
  
  input SaveStaticQuestionInput {
    label: String!
    slug: String!
    infoText: String
    isHidden: QuestionJexl
    meta: JSONString
    isArchived: Boolean
    staticContent: String
    clientMutationId: String
  }
  
  type SaveStaticQuestionPayload {
    question: Question
    clientMutationId: String
  }
  
  input SaveTableQuestionInput {
    slug: String!
    label: String!
    infoText: String
    isRequired: QuestionJexl
    isHidden: QuestionJexl
    meta: JSONString
    isArchived: Boolean
  
    """Form that represents rows of a TableQuestion"""
    rowForm: ID!
    hintText: String
    clientMutationId: String
  }
  
  type SaveTableQuestionPayload {
    question: Question
    clientMutationId: String
  }
  
  input SaveTextQuestionInput {
    slug: String!
    label: String!
    infoText: String
    isRequired: QuestionJexl
    isHidden: QuestionJexl
    meta: JSONString
    isArchived: Boolean
    minLength: Int
    maxLength: Int
    placeholder: String
    hintText: String
    formatValidators: [String]
    clientMutationId: String
  }
  
  type SaveTextQuestionPayload {
    question: Question
    clientMutationId: String
  }
  
  input SaveTextareaQuestionInput {
    slug: String!
    label: String!
    infoText: String
    isRequired: QuestionJexl
    isHidden: QuestionJexl
    meta: JSONString
    isArchived: Boolean
    minLength: Int
    maxLength: Int
    placeholder: String
    hintText: String
    formatValidators: [String]
    clientMutationId: String
  }
  
  type SaveTextareaQuestionPayload {
    question: Question
    clientMutationId: String
  }
  
  input SaveWorkItemInput {
    workItem: ID!
  
    """Will be set from Task, if not provided."""
    name: String
  
    """Will be set from Task, if not provided."""
    description: String
  
    """Users responsible to undertake given work item."""
    assignedUsers: [String]
    deadline: DateTime
    meta: JSONString
  
    """Provide extra context for dynamic jexl transforms and events"""
    context: JSONString
    clientMutationId: String
  }
  
  type SaveWorkItemPayload {
    workItem: WorkItem
    clientMutationId: String
  }
  
  input SaveWorkflowInput {
    slug: String!
    name: String!
    description: String
    meta: JSONString
  
    """Starting task(s) of the workflow."""
    startTasks: [ID]!
  
    """Allow workflow to be started with any form"""
    allowAllForms: Boolean
  
    """List of forms which are allowed to start workflow with"""
    allowForms: [ID]
    isArchived: Boolean
    isPublished: Boolean
    clientMutationId: String
  }
  
  type SaveWorkflowPayload {
    workflow: Workflow
    clientMutationId: String
  }
  
  """Lookup type to search in answers."""
  input SearchAnswersFilterType {
    questions: [ID]
    value: GenericScalar!
    lookup: SearchLookupMode
  }
  
  enum SearchLookupMode {
    STARTSWITH
    CONTAINS
    TEXT
  }
  
  type SelectedOption {
    label: String!
    slug: String!
  }
  
  type SelectedOptionConnection {
    """Pagination data for this connection."""
    pageInfo: PageInfo!
  
    """Contains the nodes in this connection."""
    edges: [SelectedOptionEdge]!
    totalCount: Int
  }
  
  """A Relay edge containing a `SelectedOption` and its cursor."""
  type SelectedOptionEdge {
    """The item at the end of the edge"""
    node: SelectedOption
  
    """A cursor for use in pagination"""
    cursor: String!
  }
  
  type SimpleTask implements Task & Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    slug: String!
    name: String!
    description: String
    meta: GenericScalar!
    addressGroups: GroupJexl
    controlGroups: GroupJexl
    isArchived: Boolean!
  
    """Time in seconds task may take to be processed."""
    leadTime: Int
    isMultipleInstance: Boolean!
    continueAsync: Boolean
  
    """The ID of the object"""
    id: ID!
  }
  
  input SkipWorkItemInput {
    id: ID!
  
    """Provide extra context for dynamic jexl transforms and events"""
    context: JSONString
    clientMutationId: String
  }
  
  type SkipWorkItemPayload {
    workItem: WorkItem
    clientMutationId: String
  }
  
  enum SortableAnalyticsTableAttributes {
    CREATED_AT
    MODIFIED_AT
    CREATED_BY_USER
    CREATED_BY_GROUP
    MODIFIED_BY_USER
    MODIFIED_BY_GROUP
    SLUG
    NAME
  }
  
  enum SortableAnswerAttributes {
    CREATED_AT
    MODIFIED_AT
    CREATED_BY_USER
    CREATED_BY_GROUP
    MODIFIED_BY_USER
    MODIFIED_BY_GROUP
    QUESTION
    VALUE
    DOCUMENT
    DATE
    FILE
  }
  
  enum SortableCaseAttributes {
    ALLOW_ALL_FORMS
    CREATED_BY_GROUP
    CREATED_BY_USER
    DESCRIPTION
    IS_ARCHIVED
    IS_PUBLISHED
    NAME
    STATUS
    SLUG
  }
  
  enum SortableDocumentAttributes {
    CREATED_AT
    MODIFIED_AT
    CREATED_BY_USER
    CREATED_BY_GROUP
    MODIFIED_BY_USER
    MODIFIED_BY_GROUP
    FORM
    SOURCE
  }
  
  enum SortableFormAttributes {
    CREATED_AT
    MODIFIED_AT
    CREATED_BY_USER
    CREATED_BY_GROUP
    MODIFIED_BY_USER
    MODIFIED_BY_GROUP
    SLUG
    NAME
    DESCRIPTION
    IS_PUBLISHED
    IS_ARCHIVED
  }
  
  enum SortableQuestionAttributes {
    CREATED_AT
    MODIFIED_AT
    CREATED_BY_USER
    CREATED_BY_GROUP
    MODIFIED_BY_USER
    MODIFIED_BY_GROUP
    SLUG
    LABEL
    TYPE
    IS_REQUIRED
    IS_HIDDEN
    IS_ARCHIVED
    PLACEHOLDER
    INFO_TEXT
    HINT_TEXT
    CALC_EXPRESSION
  }
  
  enum SortableTaskAttributes {
    ALLOW_ALL_FORMS
    LEAD_TIME
    TYPE
    CREATED_BY_GROUP
    CREATED_BY_USER
    DESCRIPTION
    IS_ARCHIVED
    IS_PUBLISHED
    NAME
    SLUG
  }
  
  enum SortableWorkItemAttributes {
    ALLOW_ALL_FORMS
    CREATED_BY_GROUP
    CREATED_BY_USER
    DESCRIPTION
    CREATED_AT
    MODIFIED_AT
    CLOSED_AT
    IS_ARCHIVED
    IS_PUBLISHED
    NAME
    DEADLINE
    STATUS
    SLUG
  }
  
  enum SortableWorkflowAttributes {
    ALLOW_ALL_FORMS
    CREATED_BY_GROUP
    CREATED_BY_USER
    DESCRIPTION
    IS_ARCHIVED
    IS_PUBLISHED
    NAME
    SLUG
  }
  
  input StartCaseInput {
    workflow: ID!
    meta: JSONString
    parentWorkItem: ID
    form: ID
  
    """Provide extra context for dynamic jexl transforms and events"""
    context: JSONString
    clientMutationId: String
  }
  
  type StartCasePayload {
    case: Case
    clientMutationId: String
  }
  
  """An enumeration."""
  enum StartingObject {
    CASES
  }
  
  type StaticQuestion implements Question & Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    slug: String!
    label: String!
  
    """
    Required expression is only evaluated when question is not hidden. This should not be used for `StaticQuestion`, because it can never be satisfied.
    """
    isRequired: QuestionJexl!
    isHidden: QuestionJexl!
    isArchived: Boolean!
    infoText: String
    meta: GenericScalar!
    source: Question
    forms(
      offset: Int = null
      before: String = null
      after: String = null
      first: Int = null
      last: Int = null
      slug: String = null
      name: String = null
      description: String = null
      isPublished: Boolean = null
      isArchived: Boolean = null
      questions: [String] = null
      createdByUser: String = null
      createdByGroup: String = null
      modifiedByUser: String = null
      modifiedByGroup: String = null
  
      """Only return entries created after the given DateTime (Exclusive)"""
      createdBefore: DateTime = null
  
      """
      Only return entries created at or before the given DateTime (Inclusive)
      """
      createdAfter: DateTime = null
      metaHasKey: String = null
      metaValue: [JSONValueFilterType] = null
      search: String = null
  
      """FormOrdering"""
      orderBy: [FormOrdering] = null
      slugs: [String] = null
    ): FormConnection
    staticContent: String
    dataSource: String
  
    """The ID of the object"""
    id: ID!
  }
  
  """An enumeration."""
  enum Status {
    """Work item is ready to be processed."""
    READY
  
    """Work item is done."""
    COMPLETED
  
    """Work item is canceled."""
    CANCELED
  
    """Work item is skipped."""
    SKIPPED
  
    """Work item is suspended."""
    SUSPENDED
  
    """Work item has been marked for redo."""
    REDO
  }
  
  type StringAnswer implements Answer & Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
  
    """The ID of the object"""
    id: ID!
    question: Question!
    value: String
    meta: GenericScalar!
    selectedOption: SelectedOption
  }
  
  input SuspendCaseInput {
    id: ID!
  
    """Provide extra context for dynamic jexl transforms and events"""
    context: JSONString
    clientMutationId: String
  }
  
  type SuspendCasePayload {
    case: Case
    clientMutationId: String
  }
  
  input SuspendWorkItemInput {
    id: ID!
  
    """Provide extra context for dynamic jexl transforms and events"""
    context: JSONString
    clientMutationId: String
  }
  
  type SuspendWorkItemPayload {
    workItem: WorkItem
    clientMutationId: String
  }
  
  type TableAnswer implements Answer & Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
  
    """The ID of the object"""
    id: ID!
    question: Question!
    value: [Document]
    meta: GenericScalar!
    document: Document
  }
  
  type TableQuestion implements Question & Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    slug: String!
    label: String!
  
    """Required expression is only evaluated when question is not hidden."""
    isRequired: QuestionJexl!
    isHidden: QuestionJexl!
    isArchived: Boolean!
    infoText: String
    hintText: String
    meta: GenericScalar!
    source: Question
    defaultAnswer: TableAnswer
    forms(
      offset: Int = null
      before: String = null
      after: String = null
      first: Int = null
      last: Int = null
      slug: String = null
      name: String = null
      description: String = null
      isPublished: Boolean = null
      isArchived: Boolean = null
      questions: [String] = null
      createdByUser: String = null
      createdByGroup: String = null
      modifiedByUser: String = null
      modifiedByGroup: String = null
  
      """Only return entries created after the given DateTime (Exclusive)"""
      createdBefore: DateTime = null
  
      """
      Only return entries created at or before the given DateTime (Inclusive)
      """
      createdAfter: DateTime = null
      metaHasKey: String = null
      metaValue: [JSONValueFilterType] = null
      search: String = null
  
      """FormOrdering"""
      orderBy: [FormOrdering] = null
      slugs: [String] = null
    ): FormConnection
  
    """Form that represents rows of a TableQuestion"""
    rowForm: Form
  
    """The ID of the object"""
    id: ID!
  }
  
  interface Task {
    id: ID!
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    slug: String!
    name: String!
    description: String
    isArchived: Boolean!
    addressGroups: GroupJexl
    controlGroups: GroupJexl
    meta: GenericScalar!
    isMultipleInstance: Boolean!
    continueAsync: Boolean
  }
  
  type TaskConnection {
    """Pagination data for this connection."""
    pageInfo: PageInfo!
  
    """Contains the nodes in this connection."""
    edges: [TaskEdge]!
    totalCount: Int
  }
  
  """A Relay edge containing a `Task` and its cursor."""
  type TaskEdge {
    """The item at the end of the edge"""
    node: Task
  
    """A cursor for use in pagination"""
    cursor: String!
  }
  
  input TaskFilterSetType {
    slug: String
    name: String
    description: String
  
    """"""
    type: Type
    isArchived: Boolean
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    createdBefore: DateTime
    createdAfter: DateTime
    metaHasKey: String
    metaValue: [JSONValueFilterType]
    search: String
  
    """"""
    orderBy: [TaskOrdering]
    invert: Boolean
  }
  
  input TaskOrderSetType {
    meta: String
    attribute: SortableTaskAttributes
    direction: AscDesc
  }
  
  """An enumeration."""
  enum TaskOrdering {
    """Name"""
    NAME_ASC
  
    """Name (descending)"""
    NAME_DESC
  
    """Description"""
    DESCRIPTION_ASC
  
    """Description (descending)"""
    DESCRIPTION_DESC
  
    """Type"""
    TYPE_ASC
  
    """Type (descending)"""
    TYPE_DESC
  
    """Created at"""
    CREATED_AT_ASC
  
    """Created at (descending)"""
    CREATED_AT_DESC
  
    """Modified at"""
    MODIFIED_AT_ASC
  
    """Modified at (descending)"""
    MODIFIED_AT_DESC
  
    """Created by user"""
    CREATED_BY_USER_ASC
  
    """Created by user (descending)"""
    CREATED_BY_USER_DESC
  
    """Created by group"""
    CREATED_BY_GROUP_ASC
  
    """Created by group (descending)"""
    CREATED_BY_GROUP_DESC
  
    """Modified by user"""
    MODIFIED_BY_USER_ASC
  
    """Modified by user (descending)"""
    MODIFIED_BY_USER_DESC
  
    """Modified by group"""
    MODIFIED_BY_GROUP_ASC
  
    """Modified by group (descending)"""
    MODIFIED_BY_GROUP_DESC
  
    """Meta test-key"""
    META_TEST_KEY_ASC
  
    """Meta test-key (descending)"""
    META_TEST_KEY_DESC
  
    """Meta foobar"""
    META_FOOBAR_ASC
  
    """Meta foobar (descending)"""
    META_FOOBAR_DESC
  }
  
  """An enumeration."""
  enum TaskTypeArgument {
    """Task which can simply be marked as completed."""
    SIMPLE
  
    """Task to complete a defined workflow form."""
    COMPLETE_WORKFLOW_FORM
  
    """Task to complete a defined task form."""
    COMPLETE_TASK_FORM
  }
  
  type TextQuestion implements Question & Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    slug: String!
    label: String!
  
    """Required expression is only evaluated when question is not hidden."""
    isRequired: QuestionJexl!
    isHidden: QuestionJexl!
    isArchived: Boolean!
    placeholder: String
    infoText: String
    hintText: String
    meta: GenericScalar!
    source: Question
    formatValidators(before: String = null, after: String = null, first: Int = null, last: Int = null): FormatValidatorConnection
    defaultAnswer: StringAnswer
    forms(
      offset: Int = null
      before: String = null
      after: String = null
      first: Int = null
      last: Int = null
      slug: String = null
      name: String = null
      description: String = null
      isPublished: Boolean = null
      isArchived: Boolean = null
      questions: [String] = null
      createdByUser: String = null
      createdByGroup: String = null
      modifiedByUser: String = null
      modifiedByGroup: String = null
  
      """Only return entries created after the given DateTime (Exclusive)"""
      createdBefore: DateTime = null
  
      """
      Only return entries created at or before the given DateTime (Inclusive)
      """
      createdAfter: DateTime = null
      metaHasKey: String = null
      metaValue: [JSONValueFilterType] = null
      search: String = null
  
      """FormOrdering"""
      orderBy: [FormOrdering] = null
      slugs: [String] = null
    ): FormConnection
  
    """The ID of the object"""
    id: ID!
    minLength: Int
    maxLength: Int
  }
  
  type TextareaQuestion implements Question & Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    slug: String!
    label: String!
  
    """Required expression is only evaluated when question is not hidden."""
    isRequired: QuestionJexl!
    isHidden: QuestionJexl!
    isArchived: Boolean!
    placeholder: String
    infoText: String
    hintText: String
    meta: GenericScalar!
    source: Question
    formatValidators(before: String = null, after: String = null, first: Int = null, last: Int = null): FormatValidatorConnection
    defaultAnswer: StringAnswer
    forms(
      offset: Int = null
      before: String = null
      after: String = null
      first: Int = null
      last: Int = null
      slug: String = null
      name: String = null
      description: String = null
      isPublished: Boolean = null
      isArchived: Boolean = null
      questions: [String] = null
      createdByUser: String = null
      createdByGroup: String = null
      modifiedByUser: String = null
      modifiedByGroup: String = null
  
      """Only return entries created after the given DateTime (Exclusive)"""
      createdBefore: DateTime = null
  
      """
      Only return entries created at or before the given DateTime (Inclusive)
      """
      createdAfter: DateTime = null
      metaHasKey: String = null
      metaValue: [JSONValueFilterType] = null
      search: String = null
  
      """FormOrdering"""
      orderBy: [FormOrdering] = null
      slugs: [String] = null
    ): FormConnection
  
    """The ID of the object"""
    id: ID!
    minLength: Int
    maxLength: Int
  }
  
  """An enumeration."""
  enum Type {
    """Task which can simply be marked as completed."""
    SIMPLE
  
    """Task to complete a defined workflow form."""
    COMPLETE_WORKFLOW_FORM
  
    """Task to complete a defined task form."""
    COMPLETE_TASK_FORM
  }
  
  """
  Leverages the internal Python implementation of UUID (uuid.UUID) to provide native UUID objects
  in fields, resolvers and input.
  """
  scalar UUID
  
  type ValidationEntry {
    slug: String!
    errorMsg: String!
  }
  
  type ValidationResult {
    id: ID
    isValid: Boolean
    errors: [ValidationEntry]
  }
  
  type WorkItem implements Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
  
    """The ID of the object"""
    id: ID!
  
    """Will be set from Task, if not provided."""
    name: String!
  
    """Will be set from Task, if not provided."""
    description: String
  
    """Time when work item has either been canceled or completed"""
    closedAt: DateTime
    closedByUser: String
    closedByGroup: String
    deadline: DateTime
    task: Task!
    status: WorkItemStatus!
    meta: GenericScalar
    addressedGroups: [String]!
    controllingGroups: [String]!
    assignedUsers: [String]!
    case: Case!
  
    """Defines case of a sub-workflow"""
    childCase: Case
    document: Document
    previousWorkItem: WorkItem
    succeedingWorkItems(offset: Int = null, before: String = null, after: String = null, first: Int = null, last: Int = null): WorkItemConnection!
  }
  
  type WorkItemConnection {
    """Pagination data for this connection."""
    pageInfo: PageInfo!
  
    """Contains the nodes in this connection."""
    edges: [WorkItemEdge]!
    totalCount: Int
  }
  
  """A Relay edge containing a `WorkItem` and its cursor."""
  type WorkItemEdge {
    """The item at the end of the edge"""
    node: WorkItem
  
    """A cursor for use in pagination"""
    cursor: String!
  }
  
  input WorkItemFilterSetType {
    """"""
    status: Status
    name: String
    task: ID
    tasks: [String]
    case: ID
    createdAt: DateTime
    closedAt: DateTime
    modifiedAt: DateTime
    deadline: DateTime
    hasDeadline: Boolean
    caseFamily: ID
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    createdBefore: DateTime
    createdAfter: DateTime
    metaHasKey: String
    metaValue: [JSONValueFilterType]
    id: ID
  
    """"""
    orderBy: [WorkItemOrdering]
    addressedGroups: [String]
    controllingGroups: [String]
    assignedUsers: [String]
    documentHasAnswer: [HasAnswerFilterType]
    caseDocumentHasAnswer: [HasAnswerFilterType]
    caseMetaValue: [JSONValueFilterType]
    rootCaseMetaValue: [JSONValueFilterType]
    invert: Boolean
  }
  
  input WorkItemOrderSetType {
    meta: String
    caseMeta: String
    attribute: SortableWorkItemAttributes
    documentAnswer: String
    caseDocumentAnswer: String
    direction: AscDesc
  }
  
  """An enumeration."""
  enum WorkItemOrdering {
    """Status"""
    STATUS_ASC
  
    """Status (descending)"""
    STATUS_DESC
  
    """Deadline"""
    DEADLINE_ASC
  
    """Deadline (descending)"""
    DEADLINE_DESC
  
    """Created at"""
    CREATED_AT_ASC
  
    """Created at (descending)"""
    CREATED_AT_DESC
  
    """Modified at"""
    MODIFIED_AT_ASC
  
    """Modified at (descending)"""
    MODIFIED_AT_DESC
  
    """Created by user"""
    CREATED_BY_USER_ASC
  
    """Created by user (descending)"""
    CREATED_BY_USER_DESC
  
    """Created by group"""
    CREATED_BY_GROUP_ASC
  
    """Created by group (descending)"""
    CREATED_BY_GROUP_DESC
  
    """Modified by user"""
    MODIFIED_BY_USER_ASC
  
    """Modified by user (descending)"""
    MODIFIED_BY_USER_DESC
  
    """Modified by group"""
    MODIFIED_BY_GROUP_ASC
  
    """Modified by group (descending)"""
    MODIFIED_BY_GROUP_DESC
  
    """Meta test-key"""
    META_TEST_KEY_ASC
  
    """Meta test-key (descending)"""
    META_TEST_KEY_DESC
  
    """Meta foobar"""
    META_FOOBAR_ASC
  
    """Meta foobar (descending)"""
    META_FOOBAR_DESC
  }
  
  """An enumeration."""
  enum WorkItemStatus {
    READY
    COMPLETED
    CANCELED
    SKIPPED
    SUSPENDED
    REDO
  }
  
  """An enumeration."""
  enum WorkItemStatusArgument {
    """Work item is ready to be processed."""
    READY
  
    """Work item is done."""
    COMPLETED
  
    """Work item is canceled."""
    CANCELED
  
    """Work item is skipped."""
    SKIPPED
  
    """Work item is suspended."""
    SUSPENDED
  
    """Work item has been marked for redo."""
    REDO
  }
  
  type Workflow implements Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    slug: String!
    name: String!
    description: String
    meta: GenericScalar
    isPublished: Boolean!
    isArchived: Boolean!
    startTasks: [Task]!
  
    """Allow workflow to be started with any form"""
    allowAllForms: Boolean!
  
    """List of forms which are allowed to start workflow with"""
    allowForms(offset: Int = null, before: String = null, after: String = null, first: Int = null, last: Int = null): FormConnection!
  
    """The ID of the object"""
    id: ID!
  
    """List of tasks referenced in workflow"""
    tasks: [Task]!
    flows(
      offset: Int = null
      before: String = null
      after: String = null
      first: Int = null
      last: Int = null
      task: ID = null
      filter: [FlowFilterSetType] = null
      createdByUser: String = null
      createdByGroup: String = null
      modifiedByUser: String = null
      modifiedByGroup: String = null
  
      """Only return entries created after the given DateTime (Exclusive)"""
      createdBefore: DateTime = null
  
      """
      Only return entries created at or before the given DateTime (Inclusive)
      """
      createdAfter: DateTime = null
    ): FlowConnection
  }
  
  type WorkflowConnection {
    """Pagination data for this connection."""
    pageInfo: PageInfo!
  
    """Contains the nodes in this connection."""
    edges: [WorkflowEdge]!
    totalCount: Int
  }
  
  """A Relay edge containing a `Workflow` and its cursor."""
  type WorkflowEdge {
    """The item at the end of the edge"""
    node: Workflow
  
    """A cursor for use in pagination"""
    cursor: String!
  }
  
  input WorkflowFilterSetType {
    slug: String
    name: String
    description: String
    isPublished: Boolean
    isArchived: Boolean
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    createdBefore: DateTime
    createdAfter: DateTime
    metaHasKey: String
    metaValue: [JSONValueFilterType]
    search: String
  
    """"""
    orderBy: [WorkflowOrdering]
    invert: Boolean
  }
  
  input WorkflowOrderSetType {
    meta: String
    attribute: SortableWorkflowAttributes
    direction: AscDesc
  }
  
  """An enumeration."""
  enum WorkflowOrdering {
    """Name"""
    NAME_ASC
  
    """Name (descending)"""
    NAME_DESC
  
    """Description"""
    DESCRIPTION_ASC
  
    """Description (descending)"""
    DESCRIPTION_DESC
  
    """Created at"""
    CREATED_AT_ASC
  
    """Created at (descending)"""
    CREATED_AT_DESC
  
    """Modified at"""
    MODIFIED_AT_ASC
  
    """Modified at (descending)"""
    MODIFIED_AT_DESC
  
    """Created by user"""
    CREATED_BY_USER_ASC
  
    """Created by user (descending)"""
    CREATED_BY_USER_DESC
  
    """Created by group"""
    CREATED_BY_GROUP_ASC
  
    """Created by group (descending)"""
    CREATED_BY_GROUP_DESC
  
    """Modified by user"""
    MODIFIED_BY_USER_ASC
  
    """Modified by user (descending)"""
    MODIFIED_BY_USER_DESC
  
    """Modified by group"""
    MODIFIED_BY_GROUP_ASC
  
    """Modified by group (descending)"""
    MODIFIED_BY_GROUP_DESC
  
    """Meta test-key"""
    META_TEST_KEY_ASC
  
    """Meta test-key (descending)"""
    META_TEST_KEY_DESC
  
    """Meta foobar"""
    META_FOOBAR_ASC
  
    """Meta foobar (descending)"""
    META_FOOBAR_DESC
  }
  
  '
---
