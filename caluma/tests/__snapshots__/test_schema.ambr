# name: test_schema_introspect_direct
  '
  type ActionButtonQuestion implements Question & Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    slug: String!
    label: String!
  
    """Required expression is only evaluated when question is not hidden."""
    isRequired: QuestionJexl!
    isHidden: QuestionJexl!
    isArchived: Boolean!
    infoText: String
    meta: GenericScalar!
    source: Question
    forms(
      offset: Int = null
      before: String = null
      after: String = null
      first: Int = null
      last: Int = null
      slug: String = null
      name: String = null
      description: String = null
      isPublished: Boolean = null
      isArchived: Boolean = null
      questions: [String] = null
      createdByUser: String = null
      createdByGroup: String = null
      modifiedByUser: String = null
      modifiedByGroup: String = null
  
      """Only return entries created after the given DateTime (Exclusive)"""
      createdBefore: DateTime = null
  
      """
      Only return entries created at or before the given DateTime (Inclusive)
      """
      createdAfter: DateTime = null
      metaHasKey: String = null
      metaValue: [JSONValueFilterType] = null
      search: String = null
  
      """FormOrdering"""
      orderBy: [FormOrdering] = null
      slugs: [String] = null
    ): FormConnection
  
    """The ID of the object"""
    id: ID!
    action: ButtonAction!
    color: ButtonColor!
    validateOnEnter: Boolean!
  }
  
  input AddFormQuestionInput {
    form: ID!
    question: ID!
    clientMutationId: String
  }
  
  """Add question at the end of form."""
  type AddFormQuestionPayload {
    form: Form
    clientMutationId: String
  }
  
  input AddWorkflowFlowInput {
    workflow: ID!
    tasks: [ID]!
    next: FlowJexl!
    clientMutationId: String
  }
  
  type AddWorkflowFlowPayload {
    workflow: Workflow
    clientMutationId: String
  }
  
  interface Answer {
    id: ID
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    question: Question!
    meta: GenericScalar!
  }
  
  type AnswerConnection {
    """Pagination data for this connection."""
    pageInfo: PageInfo!
  
    """Contains the nodes in this connection."""
    edges: [AnswerEdge]!
    totalCount: Int
  }
  
  """A Relay edge containing a `Answer` and its cursor."""
  type AnswerEdge {
    """The item at the end of the edge"""
    node: Answer
  
    """A cursor for use in pagination"""
    cursor: String!
  }
  
  input AnswerFilterSetType {
    question: ID
    search: String
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    createdBefore: DateTime
    createdAfter: DateTime
    metaHasKey: String
    metaValue: [JSONValueFilterType]
  
    """"""
    orderBy: [AnswerOrdering]
    questions: [ID]
    visibleInContext: Boolean
    invert: Boolean
  }
  
  enum AnswerHierarchyMode {
    DIRECT
    FAMILY
  }
  
  enum AnswerLookupMode {
    EXACT
    STARTSWITH
    CONTAINS
    ICONTAINS
    INTERSECTS
    ISNULL
    GTE
    GT
    LTE
    LT
  }
  
  input AnswerOrderSetType {
    meta: String
    attribute: SortableAnswerAttributes
    direction: AscDesc
  }
  
  """An enumeration."""
  enum AnswerOrdering {
    """Created at"""
    CREATED_AT_ASC
  
    """Created at (descending)"""
    CREATED_AT_DESC
  
    """Modified at"""
    MODIFIED_AT_ASC
  
    """Modified at (descending)"""
    MODIFIED_AT_DESC
  
    """Created by user"""
    CREATED_BY_USER_ASC
  
    """Created by user (descending)"""
    CREATED_BY_USER_DESC
  
    """Created by group"""
    CREATED_BY_GROUP_ASC
  
    """Created by group (descending)"""
    CREATED_BY_GROUP_DESC
  
    """Modified by user"""
    MODIFIED_BY_USER_ASC
  
    """Modified by user (descending)"""
    MODIFIED_BY_USER_DESC
  
    """Modified by group"""
    MODIFIED_BY_GROUP_ASC
  
    """Modified by group (descending)"""
    MODIFIED_BY_GROUP_DESC
  
    """Meta test-key"""
    META_TEST_KEY_ASC
  
    """Meta test-key (descending)"""
    META_TEST_KEY_DESC
  
    """Meta foobar"""
    META_FOOBAR_ASC
  
    """Meta foobar (descending)"""
    META_FOOBAR_DESC
  }
  
  enum AscDesc {
    ASC
    DESC
  }
  
  """An enumeration."""
  enum ButtonAction {
    COMPLETE
    SKIP
  }
  
  """An enumeration."""
  enum ButtonColor {
    PRIMARY
    SECONDARY
    DEFAULT
  }
  
  type CalculatedFloatQuestion implements Question & Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    slug: String!
    label: String!
  
    """Required expression is only evaluated when question is not hidden."""
    isRequired: QuestionJexl!
    isHidden: QuestionJexl!
    isArchived: Boolean!
    infoText: String
    meta: GenericScalar!
    source: Question
    forms(
      offset: Int = null
      before: String = null
      after: String = null
      first: Int = null
      last: Int = null
      slug: String = null
      name: String = null
      description: String = null
      isPublished: Boolean = null
      isArchived: Boolean = null
      questions: [String] = null
      createdByUser: String = null
      createdByGroup: String = null
      modifiedByUser: String = null
      modifiedByGroup: String = null
  
      """Only return entries created after the given DateTime (Exclusive)"""
      createdBefore: DateTime = null
  
      """
      Only return entries created at or before the given DateTime (Inclusive)
      """
      createdAfter: DateTime = null
      metaHasKey: String = null
      metaValue: [JSONValueFilterType] = null
      search: String = null
  
      """FormOrdering"""
      orderBy: [FormOrdering] = null
      slugs: [String] = null
    ): FormConnection
    calcExpression: String
  
    """The ID of the object"""
    id: ID!
  }
  
  """An enumeration."""
  enum CalumaWorkflowCaseStatusChoices {
    """Case is running and work items need to be completed."""
    RUNNING
  
    """Case is done."""
    COMPLETED
  
    """Case is canceled."""
    CANCELED
  
    """Case is suspended."""
    SUSPENDED
  }
  
  """An enumeration."""
  enum CalumaWorkflowTaskTypeChoices {
    """Task which can simply be marked as completed."""
    SIMPLE
  
    """Task to complete a defined workflow form."""
    COMPLETE_WORKFLOW_FORM
  
    """Task to complete a defined task form."""
    COMPLETE_TASK_FORM
  }
  
  """An enumeration."""
  enum CalumaWorkflowWorkItemStatusChoices {
    """Work item is ready to be processed."""
    READY
  
    """Work item is done."""
    COMPLETED
  
    """Work item is canceled."""
    CANCELED
  
    """Work item is skipped."""
    SKIPPED
  
    """Work item is suspended."""
    SUSPENDED
  }
  
  input CancelCaseInput {
    id: ID!
  
    """Provide extra context for dynamic jexl transforms and events"""
    context: JSONString
    clientMutationId: String
  }
  
  type CancelCasePayload {
    case: Case
    clientMutationId: String
  }
  
  input CancelWorkItemInput {
    id: ID!
  
    """Provide extra context for dynamic jexl transforms and events"""
    context: JSONString
    clientMutationId: String
  }
  
  type CancelWorkItemPayload {
    workItem: WorkItem
    clientMutationId: String
  }
  
  type Case implements Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
  
    """The ID of the object"""
    id: ID!
  
    """Time when case has either been canceled or completed"""
    closedAt: DateTime
    closedByUser: String
    closedByGroup: String
    workflow: Workflow!
    status: CalumaWorkflowCaseStatusChoices!
    meta: GenericScalar
    document: Document
    workItems(
      offset: Int = null
      before: String = null
      after: String = null
      first: Int = null
      last: Int = null
      metaValue: [JSONValueFilterType] = null
      status: WorkItemStatusArgument = null
      name: String = null
      task: ID = null
      tasks: [String] = null
      case: ID = null
      createdAt: DateTime = null
      closedAt: DateTime = null
      modifiedAt: DateTime = null
      deadline: DateTime = null
      hasDeadline: Boolean = null
      caseFamily: ID = null
  
      """WorkItemOrdering"""
      orderBy: [WorkItemOrdering] = null
      filter: [WorkItemFilterSetType] = null
      order: [WorkItemOrderSetType] = null
      createdByUser: String = null
      createdByGroup: String = null
      modifiedByUser: String = null
      modifiedByGroup: String = null
  
      """Only return entries created after the given DateTime (Exclusive)"""
      createdBefore: DateTime = null
  
      """
      Only return entries created at or before the given DateTime (Inclusive)
      """
      createdAfter: DateTime = null
      metaHasKey: String = null
      id: ID = null
      addressedGroups: [String] = null
      controllingGroups: [String] = null
      assignedUsers: [String] = null
      documentHasAnswer: [HasAnswerFilterType] = null
      caseDocumentHasAnswer: [HasAnswerFilterType] = null
      caseMetaValue: [JSONValueFilterType] = null
      rootCaseMetaValue: [JSONValueFilterType] = null
    ): WorkItemConnection
    parentWorkItem: WorkItem
    familyWorkItems(
      offset: Int = null
      before: String = null
      after: String = null
      first: Int = null
      last: Int = null
      metaValue: [JSONValueFilterType] = null
      status: WorkItemStatusArgument = null
  
      """WorkItemOrdering"""
      orderBy: [WorkItemOrdering] = null
      filter: [WorkItemFilterSetType] = null
      order: [WorkItemOrderSetType] = null
      documentHasAnswer: [HasAnswerFilterType] = null
      caseDocumentHasAnswer: [HasAnswerFilterType] = null
      caseMetaValue: [JSONValueFilterType] = null
      rootCaseMetaValue: [JSONValueFilterType] = null
      name: String = null
      task: ID = null
      tasks: [String] = null
      case: ID = null
      createdAt: DateTime = null
      closedAt: DateTime = null
      modifiedAt: DateTime = null
      deadline: DateTime = null
      hasDeadline: Boolean = null
      caseFamily: ID = null
      createdByUser: String = null
      createdByGroup: String = null
      modifiedByUser: String = null
      modifiedByGroup: String = null
  
      """Only return entries created after the given DateTime (Exclusive)"""
      createdBefore: DateTime = null
  
      """
      Only return entries created at or before the given DateTime (Inclusive)
      """
      createdAfter: DateTime = null
      metaHasKey: String = null
      id: ID = null
      addressedGroups: [String] = null
      controllingGroups: [String] = null
      assignedUsers: [String] = null
    ): WorkItemConnection
  }
  
  type CaseConnection {
    """Pagination data for this connection."""
    pageInfo: PageInfo!
  
    """Contains the nodes in this connection."""
    edges: [CaseEdge]!
    totalCount: Int
  }
  
  """A Relay edge containing a `Case` and its cursor."""
  type CaseEdge {
    """The item at the end of the edge"""
    node: Case
  
    """A cursor for use in pagination"""
    cursor: String!
  }
  
  input CaseFilterSetType {
    workflow: ID
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    createdBefore: DateTime
    createdAfter: DateTime
    metaHasKey: String
    metaValue: [JSONValueFilterType]
    id: ID
  
    """"""
    orderBy: [CaseOrdering]
    documentForm: String
    documentForms: [String]
    hasAnswer: [HasAnswerFilterType]
    workItemDocumentHasAnswer: [HasAnswerFilterType]
    rootCase: ID
    searchAnswers: [SearchAnswersFilterType]
    status: [CaseStatusArgument]
    orderByQuestionAnswerValue: String
    invert: Boolean
  }
  
  input CaseOrderSetType {
    meta: String
    attribute: SortableCaseAttributes
    documentAnswer: String
    direction: AscDesc
  }
  
  """An enumeration."""
  enum CaseOrdering {
    """Status"""
    STATUS_ASC
  
    """Status (descending)"""
    STATUS_DESC
  
    """Created at"""
    CREATED_AT_ASC
  
    """Created at (descending)"""
    CREATED_AT_DESC
  
    """Modified at"""
    MODIFIED_AT_ASC
  
    """Modified at (descending)"""
    MODIFIED_AT_DESC
  
    """Created by user"""
    CREATED_BY_USER_ASC
  
    """Created by user (descending)"""
    CREATED_BY_USER_DESC
  
    """Created by group"""
    CREATED_BY_GROUP_ASC
  
    """Created by group (descending)"""
    CREATED_BY_GROUP_DESC
  
    """Modified by user"""
    MODIFIED_BY_USER_ASC
  
    """Modified by user (descending)"""
    MODIFIED_BY_USER_DESC
  
    """Modified by group"""
    MODIFIED_BY_GROUP_ASC
  
    """Modified by group (descending)"""
    MODIFIED_BY_GROUP_DESC
  
    """Meta test-key"""
    META_TEST_KEY_ASC
  
    """Meta test-key (descending)"""
    META_TEST_KEY_DESC
  
    """Meta foobar"""
    META_FOOBAR_ASC
  
    """Meta foobar (descending)"""
    META_FOOBAR_DESC
  }
  
  """An enumeration."""
  enum CaseStatusArgument {
    """Case is running and work items need to be completed."""
    RUNNING
  
    """Case is done."""
    COMPLETED
  
    """Case is canceled."""
    CANCELED
  
    """Case is suspended."""
    SUSPENDED
  }
  
  type ChoiceQuestion implements Question & Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    slug: String!
    label: String!
  
    """Required expression is only evaluated when question is not hidden."""
    isRequired: QuestionJexl!
    isHidden: QuestionJexl!
    isArchived: Boolean!
    infoText: String
    meta: GenericScalar!
    source: Question
    defaultAnswer: StringAnswer
    forms(
      offset: Int = null
      before: String = null
      after: String = null
      first: Int = null
      last: Int = null
      slug: String = null
      name: String = null
      description: String = null
      isPublished: Boolean = null
      isArchived: Boolean = null
      questions: [String] = null
      createdByUser: String = null
      createdByGroup: String = null
      modifiedByUser: String = null
      modifiedByGroup: String = null
  
      """Only return entries created after the given DateTime (Exclusive)"""
      createdBefore: DateTime = null
  
      """
      Only return entries created at or before the given DateTime (Inclusive)
      """
      createdAfter: DateTime = null
      metaHasKey: String = null
      metaValue: [JSONValueFilterType] = null
      search: String = null
  
      """FormOrdering"""
      orderBy: [FormOrdering] = null
      slugs: [String] = null
    ): FormConnection
    options(
      offset: Int = null
      before: String = null
      after: String = null
      first: Int = null
      last: Int = null
      metaValue: [JSONValueFilterType] = null
      slug: String = null
      label: String = null
      isArchived: Boolean = null
      createdByUser: String = null
      createdByGroup: String = null
      modifiedByUser: String = null
      modifiedByGroup: String = null
  
      """Only return entries created after the given DateTime (Exclusive)"""
      createdBefore: DateTime = null
  
      """
      Only return entries created at or before the given DateTime (Inclusive)
      """
      createdAfter: DateTime = null
      metaHasKey: String = null
      search: String = null
  
      """OptionOrdering"""
      orderBy: [OptionOrdering] = null
    ): OptionConnection
  
    """The ID of the object"""
    id: ID!
  }
  
  type CompleteTaskFormTask implements Task & Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    slug: String!
    name: String!
    description: String
    type: CalumaWorkflowTaskTypeChoices!
    meta: GenericScalar!
    addressGroups: GroupJexl
    controlGroups: GroupJexl
    isArchived: Boolean!
  
    """Time in seconds task may take to be processed."""
    leadTime: Int
    isMultipleInstance: Boolean!
    form: Form!
  
    """The ID of the object"""
    id: ID!
  }
  
  input CompleteWorkItemInput {
    id: ID!
  
    """Provide extra context for dynamic jexl transforms and events"""
    context: JSONString
    clientMutationId: String
  }
  
  type CompleteWorkItemPayload {
    workItem: WorkItem
    clientMutationId: String
  }
  
  type CompleteWorkflowFormTask implements Task & Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    slug: String!
    name: String!
    description: String
    type: CalumaWorkflowTaskTypeChoices!
    meta: GenericScalar!
    addressGroups: GroupJexl
    controlGroups: GroupJexl
    isArchived: Boolean!
  
    """Time in seconds task may take to be processed."""
    leadTime: Int
    isMultipleInstance: Boolean!
  
    """The ID of the object"""
    id: ID!
  }
  
  input CopyDocumentInput {
    source: ID!
    clientMutationId: String
  }
  
  type CopyDocumentPayload {
    document: Document
    clientMutationId: String
  }
  
  input CopyFormInput {
    slug: String!
    name: String!
    description: String
    source: ID!
    isPublished: Boolean
    clientMutationId: String
  }
  
  type CopyFormPayload {
    form: Form
    clientMutationId: String
  }
  
  input CopyOptionInput {
    slug: String!
    label: String!
    source: ID!
    clientMutationId: String
  }
  
  type CopyOptionPayload {
    option: Option
    clientMutationId: String
  }
  
  input CopyQuestionInput {
    slug: String!
    label: String!
    source: ID!
    clientMutationId: String
  }
  
  type CopyQuestionPayload {
    question: Question
    clientMutationId: String
  }
  
  input CreateWorkItemInput {
    case: ID!
    multipleInstanceTask: ID!
  
    """Will be set from Task, if not provided."""
    name: String
  
    """Will be set from Task, if not provided."""
    description: String
  
    """Users responsible to undertake given work item."""
    assignedUsers: [String]
    addressedGroups: [String]
    controllingGroups: [String]
    deadline: DateTime
    meta: JSONString
  
    """Provide extra context for dynamic jexl transforms and events"""
    context: JSONString
    clientMutationId: String
  }
  
  type CreateWorkItemPayload {
    workItem: WorkItem
    clientMutationId: String
  }
  
  type DataSource {
    info: String
    name: String!
  }
  
  type DataSourceConnection {
    """Pagination data for this connection."""
    pageInfo: PageInfo!
  
    """Contains the nodes in this connection."""
    edges: [DataSourceEdge]!
    totalCount: Int
  }
  
  type DataSourceData {
    label: String!
    slug: String!
  }
  
  type DataSourceDataConnection {
    """Pagination data for this connection."""
    pageInfo: PageInfo!
  
    """Contains the nodes in this connection."""
    edges: [DataSourceDataEdge]!
    totalCount: Int
  }
  
  """A Relay edge containing a `DataSourceData` and its cursor."""
  type DataSourceDataEdge {
    """The item at the end of the edge"""
    node: DataSourceData
  
    """A cursor for use in pagination"""
    cursor: String!
  }
  
  """A Relay edge containing a `DataSource` and its cursor."""
  type DataSourceEdge {
    """The item at the end of the edge"""
    node: DataSource
  
    """A cursor for use in pagination"""
    cursor: String!
  }
  
  """
  The `Date` scalar type represents a Date
  value as specified by
  [iso8601](https://en.wikipedia.org/wiki/ISO_8601).
  """
  scalar Date
  
  type DateAnswer implements Answer & Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
  
    """The ID of the object"""
    id: ID!
    question: Question!
    value: Date
    meta: GenericScalar!
    date: Date
  }
  
  type DateQuestion implements Question & Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    slug: String!
    label: String!
  
    """Required expression is only evaluated when question is not hidden."""
    isRequired: QuestionJexl!
    isHidden: QuestionJexl!
    isArchived: Boolean!
    infoText: String
    meta: GenericScalar!
    source: Question
    defaultAnswer: DateAnswer
    forms(
      offset: Int = null
      before: String = null
      after: String = null
      first: Int = null
      last: Int = null
      slug: String = null
      name: String = null
      description: String = null
      isPublished: Boolean = null
      isArchived: Boolean = null
      questions: [String] = null
      createdByUser: String = null
      createdByGroup: String = null
      modifiedByUser: String = null
      modifiedByGroup: String = null
  
      """Only return entries created after the given DateTime (Exclusive)"""
      createdBefore: DateTime = null
  
      """
      Only return entries created at or before the given DateTime (Inclusive)
      """
      createdAfter: DateTime = null
      metaHasKey: String = null
      metaValue: [JSONValueFilterType] = null
      search: String = null
  
      """FormOrdering"""
      orderBy: [FormOrdering] = null
      slugs: [String] = null
    ): FormConnection
  
    """The ID of the object"""
    id: ID!
  }
  
  """
  The `DateTime` scalar type represents a DateTime
  value as specified by
  [iso8601](https://en.wikipedia.org/wiki/ISO_8601).
  """
  scalar DateTime
  
  """Debugging information for the current query."""
  type DjangoDebug {
    """Executed SQL queries for this API query."""
    sql: [DjangoDebugSQL]
  }
  
  """Represents a single database query made to a Django managed DB."""
  type DjangoDebugSQL {
    """The type of database being used (e.g. postrgesql, mysql, sqlite)."""
    vendor: String!
  
    """The Django database alias (e.g. 'default')."""
    alias: String!
  
    """The actual SQL sent to this database."""
    sql: String
  
    """Duration of this database query in seconds."""
    duration: Float!
  
    """The raw SQL of this query, without params."""
    rawSql: String!
  
    """JSON encoded database query parameters."""
    params: String!
  
    """Start time of this database query."""
    startTime: Float!
  
    """Stop time of this database query."""
    stopTime: Float!
  
    """Whether this database query took more than 10 seconds."""
    isSlow: Boolean!
  
    """Whether this database query was a SELECT."""
    isSelect: Boolean!
  
    """Postgres transaction ID if available."""
    transId: String
  
    """Postgres transaction status if available."""
    transStatus: String
  
    """Postgres isolation level if available."""
    isoLevel: String
  
    """Postgres connection encoding if available."""
    encoding: String
  }
  
  type Document implements Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
  
    """The ID of the object"""
    id: ID!
    form: Form!
  
    """Reference this document has been copied from"""
    source: Document
    meta: GenericScalar
  
    """Reference this document has been copied from"""
    copies(offset: Int = null, before: String = null, after: String = null, first: Int = null, last: Int = null): DocumentConnection!
    answers(
      offset: Int = null
      before: String = null
      after: String = null
      first: Int = null
      last: Int = null
      metaValue: [JSONValueFilterType] = null
      question: ID = null
      search: String = null
  
      """AnswerOrdering"""
      orderBy: [AnswerOrdering] = null
      filter: [AnswerFilterSetType] = null
      order: [AnswerOrderSetType] = null
      createdByUser: String = null
      createdByGroup: String = null
      modifiedByUser: String = null
      modifiedByGroup: String = null
  
      """Only return entries created after the given DateTime (Exclusive)"""
      createdBefore: DateTime = null
  
      """
      Only return entries created at or before the given DateTime (Inclusive)
      """
      createdAfter: DateTime = null
      metaHasKey: String = null
      questions: [ID] = null
      visibleInContext: Boolean = null
    ): AnswerConnection
    case: Case
    workItem: WorkItem
    modifiedContentAt: DateTime
    modifiedContentByUser: String
    modifiedContentByGroup: String
  }
  
  type DocumentConnection {
    """Pagination data for this connection."""
    pageInfo: PageInfo!
  
    """Contains the nodes in this connection."""
    edges: [DocumentEdge]!
    totalCount: Int
  }
  
  """A Relay edge containing a `Document` and its cursor."""
  type DocumentEdge {
    """The item at the end of the edge"""
    node: Document
  
    """A cursor for use in pagination"""
    cursor: String!
  }
  
  input DocumentFilterSetType {
    form: ID
    forms: [ID]
    search: String
    id: ID
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    createdBefore: DateTime
    createdAfter: DateTime
    metaHasKey: String
    metaValue: [JSONValueFilterType]
  
    """"""
    orderBy: [DocumentOrdering]
    rootDocument: ID
    hasAnswer: [HasAnswerFilterType]
    searchAnswers: [SearchAnswersFilterType]
    invert: Boolean
  }
  
  input DocumentOrderSetType {
    meta: String
    answerValue: String
    attribute: SortableDocumentAttributes
    direction: AscDesc
  }
  
  """An enumeration."""
  enum DocumentOrdering {
    """Created at"""
    CREATED_AT_ASC
  
    """Created at (descending)"""
    CREATED_AT_DESC
  
    """Modified at"""
    MODIFIED_AT_ASC
  
    """Modified at (descending)"""
    MODIFIED_AT_DESC
  
    """Created by user"""
    CREATED_BY_USER_ASC
  
    """Created by user (descending)"""
    CREATED_BY_USER_DESC
  
    """Created by group"""
    CREATED_BY_GROUP_ASC
  
    """Created by group (descending)"""
    CREATED_BY_GROUP_DESC
  
    """Modified by user"""
    MODIFIED_BY_USER_ASC
  
    """Modified by user (descending)"""
    MODIFIED_BY_USER_DESC
  
    """Modified by group"""
    MODIFIED_BY_GROUP_ASC
  
    """Modified by group (descending)"""
    MODIFIED_BY_GROUP_DESC
  
    """Meta test-key"""
    META_TEST_KEY_ASC
  
    """Meta test-key (descending)"""
    META_TEST_KEY_DESC
  
    """Meta foobar"""
    META_FOOBAR_ASC
  
    """Meta foobar (descending)"""
    META_FOOBAR_DESC
  }
  
  type DocumentValidityConnection {
    """Pagination data for this connection."""
    pageInfo: PageInfo!
  
    """Contains the nodes in this connection."""
    edges: [DocumentValidityEdge]!
    totalCount: Int
  }
  
  """A Relay edge containing a `DocumentValidity` and its cursor."""
  type DocumentValidityEdge {
    """The item at the end of the edge"""
    node: ValidationResult
  
    """A cursor for use in pagination"""
    cursor: String!
  }
  
  type DynamicChoiceQuestion implements Question & DynamicQuestion & Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    slug: String!
    label: String!
  
    """Required expression is only evaluated when question is not hidden."""
    isRequired: QuestionJexl!
    isHidden: QuestionJexl!
    isArchived: Boolean!
    infoText: String
    meta: GenericScalar!
    source: Question
    forms(
      offset: Int = null
      before: String = null
      after: String = null
      first: Int = null
      last: Int = null
      slug: String = null
      name: String = null
      description: String = null
      isPublished: Boolean = null
      isArchived: Boolean = null
      questions: [String] = null
      createdByUser: String = null
      createdByGroup: String = null
      modifiedByUser: String = null
      modifiedByGroup: String = null
  
      """Only return entries created after the given DateTime (Exclusive)"""
      createdBefore: DateTime = null
  
      """
      Only return entries created at or before the given DateTime (Inclusive)
      """
      createdAfter: DateTime = null
      metaHasKey: String = null
      metaValue: [JSONValueFilterType] = null
      search: String = null
  
      """FormOrdering"""
      orderBy: [FormOrdering] = null
      slugs: [String] = null
    ): FormConnection
    options(before: String = null, after: String = null, first: Int = null, last: Int = null): DataSourceDataConnection
    dataSource: String!
  
    """The ID of the object"""
    id: ID!
  }
  
  type DynamicMultipleChoiceQuestion implements Question & DynamicQuestion & Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    slug: String!
    label: String!
  
    """Required expression is only evaluated when question is not hidden."""
    isRequired: QuestionJexl!
    isHidden: QuestionJexl!
    isArchived: Boolean!
    infoText: String
    meta: GenericScalar!
    source: Question
    forms(
      offset: Int = null
      before: String = null
      after: String = null
      first: Int = null
      last: Int = null
      slug: String = null
      name: String = null
      description: String = null
      isPublished: Boolean = null
      isArchived: Boolean = null
      questions: [String] = null
      createdByUser: String = null
      createdByGroup: String = null
      modifiedByUser: String = null
      modifiedByGroup: String = null
  
      """Only return entries created after the given DateTime (Exclusive)"""
      createdBefore: DateTime = null
  
      """
      Only return entries created at or before the given DateTime (Inclusive)
      """
      createdAfter: DateTime = null
      metaHasKey: String = null
      metaValue: [JSONValueFilterType] = null
      search: String = null
  
      """FormOrdering"""
      orderBy: [FormOrdering] = null
      slugs: [String] = null
    ): FormConnection
    options(before: String = null, after: String = null, first: Int = null, last: Int = null): DataSourceDataConnection
    dataSource: String!
  
    """The ID of the object"""
    id: ID!
  }
  
  type DynamicOption implements Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
  
    """The ID of the object"""
    id: ID!
    slug: String!
    label: String!
    document: Document!
    question: DynamicQuestion!
  }
  
  type DynamicOptionConnection {
    """Pagination data for this connection."""
    pageInfo: PageInfo!
  
    """Contains the nodes in this connection."""
    edges: [DynamicOptionEdge]!
    totalCount: Int
  }
  
  """A Relay edge containing a `DynamicOption` and its cursor."""
  type DynamicOptionEdge {
    """The item at the end of the edge"""
    node: DynamicOption
  
    """A cursor for use in pagination"""
    cursor: String!
  }
  
  input DynamicOptionFilterSetType {
    question: ID
    document: ID
    invert: Boolean
  }
  
  interface DynamicQuestion {
    options(before: String = null, after: String = null, first: Int = null, last: Int = null): DataSourceDataConnection
    dataSource: String!
  }
  
  type File implements Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
  
    """The ID of the object"""
    id: ID!
    name: String!
    answer: FileAnswer
    uploadUrl: String
    downloadUrl: String
    metadata: GenericScalar
  }
  
  type FileAnswer implements Answer & Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
  
    """The ID of the object"""
    id: ID!
    question: Question!
    value: File!
    meta: GenericScalar!
    file: File
  }
  
  type FileQuestion implements Question & Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    slug: String!
    label: String!
  
    """Required expression is only evaluated when question is not hidden."""
    isRequired: QuestionJexl!
    isHidden: QuestionJexl!
    isArchived: Boolean!
    infoText: String
    meta: GenericScalar!
    source: Question
    forms(
      offset: Int = null
      before: String = null
      after: String = null
      first: Int = null
      last: Int = null
      slug: String = null
      name: String = null
      description: String = null
      isPublished: Boolean = null
      isArchived: Boolean = null
      questions: [String] = null
      createdByUser: String = null
      createdByGroup: String = null
      modifiedByUser: String = null
      modifiedByGroup: String = null
  
      """Only return entries created after the given DateTime (Exclusive)"""
      createdBefore: DateTime = null
  
      """
      Only return entries created at or before the given DateTime (Inclusive)
      """
      createdAfter: DateTime = null
      metaHasKey: String = null
      metaValue: [JSONValueFilterType] = null
      search: String = null
  
      """FormOrdering"""
      orderBy: [FormOrdering] = null
      slugs: [String] = null
    ): FormConnection
  
    """The ID of the object"""
    id: ID!
  }
  
  type FloatAnswer implements Answer & Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
  
    """The ID of the object"""
    id: ID!
    question: Question!
    value: Float
    meta: GenericScalar!
  }
  
  type FloatQuestion implements Question & Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    slug: String!
    label: String!
  
    """Required expression is only evaluated when question is not hidden."""
    isRequired: QuestionJexl!
    isHidden: QuestionJexl!
    isArchived: Boolean!
    placeholder: String
    infoText: String
    meta: GenericScalar!
    source: Question
    defaultAnswer: FloatAnswer
    forms(
      offset: Int = null
      before: String = null
      after: String = null
      first: Int = null
      last: Int = null
      slug: String = null
      name: String = null
      description: String = null
      isPublished: Boolean = null
      isArchived: Boolean = null
      questions: [String] = null
      createdByUser: String = null
      createdByGroup: String = null
      modifiedByUser: String = null
      modifiedByGroup: String = null
  
      """Only return entries created after the given DateTime (Exclusive)"""
      createdBefore: DateTime = null
  
      """
      Only return entries created at or before the given DateTime (Inclusive)
      """
      createdAfter: DateTime = null
      metaHasKey: String = null
      metaValue: [JSONValueFilterType] = null
      search: String = null
  
      """FormOrdering"""
      orderBy: [FormOrdering] = null
      slugs: [String] = null
    ): FormConnection
  
    """The ID of the object"""
    id: ID!
    minValue: Float
    maxValue: Float
  }
  
  type Flow implements Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
  
    """The ID of the object"""
    id: ID!
    next: FlowJexl!
    tasks: [Task]!
  }
  
  type FlowConnection {
    """Pagination data for this connection."""
    pageInfo: PageInfo!
  
    """Contains the nodes in this connection."""
    edges: [FlowEdge]!
    totalCount: Int
  }
  
  """A Relay edge containing a `Flow` and its cursor."""
  type FlowEdge {
    """The item at the end of the edge"""
    node: Flow
  
    """A cursor for use in pagination"""
    cursor: String!
  }
  
  input FlowFilterSetType {
    task: ID
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    createdBefore: DateTime
    createdAfter: DateTime
    invert: Boolean
  }
  
  """
  Flow jexl represents a jexl expression returning task slugs.
  
  Following transforms can be used:
  * task - return single task
  * tasks - return multiple tasks
  
  Examples:
  * 'task-slug'|task
  * ['task-slug1', 'task-slug2']|tasks
  """
  scalar FlowJexl
  
  type Form implements Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    slug: String!
    name: String!
    description: String
    meta: GenericScalar
    isPublished: Boolean!
    isArchived: Boolean!
    questions(
      offset: Int = null
      before: String = null
      after: String = null
      first: Int = null
      last: Int = null
      metaValue: [JSONValueFilterType] = null
      slug: String = null
      label: String = null
      isRequired: String = null
      isHidden: String = null
      isArchived: Boolean = null
      subForm: ID = null
      rowForm: ID = null
      createdByUser: String = null
      createdByGroup: String = null
      modifiedByUser: String = null
      modifiedByGroup: String = null
  
      """Only return entries created after the given DateTime (Exclusive)"""
      createdBefore: DateTime = null
  
      """
      Only return entries created at or before the given DateTime (Inclusive)
      """
      createdAfter: DateTime = null
      metaHasKey: String = null
      excludeForms: [ID] = null
      search: String = null
  
      """QuestionOrdering"""
      orderBy: [QuestionOrdering] = null
      slugs: [String] = null
    ): QuestionConnection
  
    """Reference this form has been copied from"""
    source: Form
    documents(offset: Int = null, before: String = null, after: String = null, first: Int = null, last: Int = null): DocumentConnection!
  
    """The ID of the object"""
    id: ID!
  }
  
  type FormConnection {
    """Pagination data for this connection."""
    pageInfo: PageInfo!
  
    """Contains the nodes in this connection."""
    edges: [FormEdge]!
    totalCount: Int
  }
  
  """A Relay edge containing a `Form` and its cursor."""
  type FormEdge {
    """The item at the end of the edge"""
    node: Form
  
    """A cursor for use in pagination"""
    cursor: String!
  }
  
  input FormFilterSetType {
    """"""
    orderBy: [FormOrdering]
    slug: String
    name: String
    description: String
    isPublished: Boolean
    isArchived: Boolean
    questions: [String]
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    createdBefore: DateTime
    createdAfter: DateTime
    metaHasKey: String
    metaValue: [JSONValueFilterType]
    search: String
    slugs: [String]
    invert: Boolean
  }
  
  input FormOrderSetType {
    meta: String
    attribute: SortableFormAttributes
    direction: AscDesc
  }
  
  """An enumeration."""
  enum FormOrdering {
    """Name"""
    NAME_ASC
  
    """Name (descending)"""
    NAME_DESC
  
    """Created at"""
    CREATED_AT_ASC
  
    """Created at (descending)"""
    CREATED_AT_DESC
  
    """Modified at"""
    MODIFIED_AT_ASC
  
    """Modified at (descending)"""
    MODIFIED_AT_DESC
  
    """Created by user"""
    CREATED_BY_USER_ASC
  
    """Created by user (descending)"""
    CREATED_BY_USER_DESC
  
    """Created by group"""
    CREATED_BY_GROUP_ASC
  
    """Created by group (descending)"""
    CREATED_BY_GROUP_DESC
  
    """Modified by user"""
    MODIFIED_BY_USER_ASC
  
    """Modified by user (descending)"""
    MODIFIED_BY_USER_DESC
  
    """Modified by group"""
    MODIFIED_BY_GROUP_ASC
  
    """Modified by group (descending)"""
    MODIFIED_BY_GROUP_DESC
  
    """Meta test-key"""
    META_TEST_KEY_ASC
  
    """Meta test-key (descending)"""
    META_TEST_KEY_DESC
  
    """Meta foobar"""
    META_FOOBAR_ASC
  
    """Meta foobar (descending)"""
    META_FOOBAR_DESC
  }
  
  type FormQuestion implements Question & Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    slug: String!
    label: String!
  
    """Required expression is only evaluated when question is not hidden."""
    isRequired: QuestionJexl!
    isHidden: QuestionJexl!
    isArchived: Boolean!
    infoText: String
    meta: GenericScalar!
    source: Question
    forms(
      offset: Int = null
      before: String = null
      after: String = null
      first: Int = null
      last: Int = null
      slug: String = null
      name: String = null
      description: String = null
      isPublished: Boolean = null
      isArchived: Boolean = null
      questions: [String] = null
      createdByUser: String = null
      createdByGroup: String = null
      modifiedByUser: String = null
      modifiedByGroup: String = null
  
      """Only return entries created after the given DateTime (Exclusive)"""
      createdBefore: DateTime = null
  
      """
      Only return entries created at or before the given DateTime (Inclusive)
      """
      createdAfter: DateTime = null
      metaHasKey: String = null
      metaValue: [JSONValueFilterType] = null
      search: String = null
  
      """FormOrdering"""
      orderBy: [FormOrdering] = null
      slugs: [String] = null
    ): FormConnection
  
    """Form referenced in a FormQuestion"""
    subForm: Form
  
    """The ID of the object"""
    id: ID!
  }
  
  type FormatValidator {
    slug: String!
    name: String!
    regex: String!
    errorMsg: String!
  }
  
  type FormatValidatorConnection {
    """Pagination data for this connection."""
    pageInfo: PageInfo!
  
    """Contains the nodes in this connection."""
    edges: [FormatValidatorEdge]!
    totalCount: Int
  }
  
  """A Relay edge containing a `FormatValidator` and its cursor."""
  type FormatValidatorEdge {
    """The item at the end of the edge"""
    node: FormatValidator
  
    """A cursor for use in pagination"""
    cursor: String!
  }
  
  """
  The `GenericScalar` scalar type represents a generic
  GraphQL scalar value that could be:
  String, Boolean, Int, Float, List or Object.
  """
  scalar GenericScalar
  
  """
  Group jexl represents a jexl expression returning group names.
  
  Following transforms can be used:
  * groups - return list of group names
  
  Examples:
  * ['group-name1', 'group-name2']|groups
  """
  scalar GroupJexl
  
  """
  Lookup type to search document structures.
  
  When using lookup `ISNULL`, the provided `value` will be ignored.
  """
  input HasAnswerFilterType {
    question: ID!
    value: GenericScalar
    lookup: AnswerLookupMode
    hierarchy: AnswerHierarchyMode
  }
  
  interface HistoricalAnswer {
    id: ID
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    question: Question!
    meta: GenericScalar!
    historyDate: DateTime!
    historyUserId: String
    historyType: String
  }
  
  type HistoricalAnswerConnection {
    """Pagination data for this connection."""
    pageInfo: PageInfo!
  
    """Contains the nodes in this connection."""
    edges: [HistoricalAnswerEdge]!
    totalCount: Int
  }
  
  """A Relay edge containing a `HistoricalAnswer` and its cursor."""
  type HistoricalAnswerEdge {
    """The item at the end of the edge"""
    node: HistoricalAnswer
  
    """A cursor for use in pagination"""
    cursor: String!
  }
  
  type HistoricalDateAnswer implements HistoricalAnswer & Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
  
    """The ID of the object"""
    id: ID!
    value: Date
    meta: GenericScalar!
    date: Date
    historyQuestionType: String!
    historyUserId: String
    question: Question!
    historyId: UUID!
    historyDate: DateTime!
    historyChangeReason: String
    historyType: String
  }
  
  type HistoricalDocument implements Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
  
    """The ID of the object"""
    id: ID!
    meta: GenericScalar
    historyUserId: String
    form: Form
  
    """Reference this document has been copied from"""
    source: Document
    historyDate: DateTime!
    historyType: String
    historicalAnswers(asOf: DateTime!, before: String = null, after: String = null, first: Int = null, last: Int = null): HistoricalAnswerConnection
    documentId: UUID
  }
  
  type HistoricalFile implements Node {
    """The ID of the object"""
    id: ID!
    name: String!
    downloadUrl: String
    metadata: GenericScalar
    historicalAnswer: HistoricalFileAnswer
    historyDate: DateTime!
    historyUserId: String
    historyType: String
  }
  
  type HistoricalFileAnswer implements HistoricalAnswer & Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
  
    """The ID of the object"""
    id: ID!
    value(asOf: DateTime!): HistoricalFile
    meta: GenericScalar!
    historyQuestionType: String!
    historyUserId: String
    question: Question!
    historyId: UUID!
    historyDate: DateTime!
    historyChangeReason: String
    historyType: String
    file: File
  }
  
  type HistoricalFloatAnswer implements HistoricalAnswer & Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
  
    """The ID of the object"""
    id: ID!
    value: Float
    meta: GenericScalar!
    historyQuestionType: String!
    historyUserId: String
    question: Question!
    historyId: UUID!
    historyDate: DateTime!
    historyChangeReason: String
    historyType: String
  }
  
  type HistoricalIntegerAnswer implements HistoricalAnswer & Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
  
    """The ID of the object"""
    id: ID!
    value: Int
    meta: GenericScalar!
    historyQuestionType: String!
    historyUserId: String
    question: Question!
    historyId: UUID!
    historyDate: DateTime!
    historyChangeReason: String
    historyType: String
  }
  
  type HistoricalListAnswer implements HistoricalAnswer & Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
  
    """The ID of the object"""
    id: ID!
    value: [String]
    meta: GenericScalar!
    historyQuestionType: String!
    historyUserId: String
    question: Question!
    historyId: UUID!
    historyDate: DateTime!
    historyChangeReason: String
    historyType: String
    selectedOptions(before: String = null, after: String = null, first: Int = null, last: Int = null): SelectedOptionConnection
  }
  
  type HistoricalStringAnswer implements HistoricalAnswer & Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
  
    """The ID of the object"""
    id: ID!
    value: String
    meta: GenericScalar!
    historyQuestionType: String!
    historyUserId: String
    question: Question!
    historyId: UUID!
    historyDate: DateTime!
    historyChangeReason: String
    historyType: String
    selectedOption: SelectedOption
  }
  
  type HistoricalTableAnswer implements HistoricalAnswer & Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
  
    """The ID of the object"""
    id: ID!
    value(asOf: DateTime!): [HistoricalDocument]
    meta: GenericScalar!
    historyQuestionType: String!
    historyUserId: String
    question: Question!
    historyId: UUID!
    historyDate: DateTime!
    historyChangeReason: String
    historyType: String
    document: Document
  }
  
  type IntegerAnswer implements Answer & Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
  
    """The ID of the object"""
    id: ID!
    question: Question!
    value: Int
    meta: GenericScalar!
  }
  
  type IntegerQuestion implements Question & Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    slug: String!
    label: String!
  
    """Required expression is only evaluated when question is not hidden."""
    isRequired: QuestionJexl!
    isHidden: QuestionJexl!
    isArchived: Boolean!
    placeholder: String
    infoText: String
    meta: GenericScalar!
    source: Question
    defaultAnswer: IntegerAnswer
    forms(
      offset: Int = null
      before: String = null
      after: String = null
      first: Int = null
      last: Int = null
      slug: String = null
      name: String = null
      description: String = null
      isPublished: Boolean = null
      isArchived: Boolean = null
      questions: [String] = null
      createdByUser: String = null
      createdByGroup: String = null
      modifiedByUser: String = null
      modifiedByGroup: String = null
  
      """Only return entries created after the given DateTime (Exclusive)"""
      createdBefore: DateTime = null
  
      """
      Only return entries created at or before the given DateTime (Inclusive)
      """
      createdAfter: DateTime = null
      metaHasKey: String = null
      metaValue: [JSONValueFilterType] = null
      search: String = null
  
      """FormOrdering"""
      orderBy: [FormOrdering] = null
      slugs: [String] = null
    ): FormConnection
  
    """The ID of the object"""
    id: ID!
    maxValue: Int
    minValue: Int
  }
  
  enum JSONLookupMode {
    EXACT
    STARTSWITH
    CONTAINS
    ICONTAINS
    IN
    GTE
    GT
    LTE
    LT
  }
  
  """
  Allows use of a JSON String for input / output from the GraphQL schema.
  
  Use of this type is *not recommended* as you lose the benefits of having a defined, static
  schema (one of the key benefits of GraphQL).
  """
  scalar JSONString
  
  input JSONValueFilterType {
    key: String!
    value: GenericScalar!
    lookup: JSONLookupMode
  }
  
  type ListAnswer implements Answer & Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
  
    """The ID of the object"""
    id: ID!
    question: Question!
    value: [String]
    meta: GenericScalar!
    selectedOptions(before: String = null, after: String = null, first: Int = null, last: Int = null): SelectedOptionConnection
  }
  
  type MultipleChoiceQuestion implements Question & Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    slug: String!
    label: String!
  
    """Required expression is only evaluated when question is not hidden."""
    isRequired: QuestionJexl!
    isHidden: QuestionJexl!
    isArchived: Boolean!
    infoText: String
    meta: GenericScalar!
    source: Question
    defaultAnswer: ListAnswer
    forms(
      offset: Int = null
      before: String = null
      after: String = null
      first: Int = null
      last: Int = null
      slug: String = null
      name: String = null
      description: String = null
      isPublished: Boolean = null
      isArchived: Boolean = null
      questions: [String] = null
      createdByUser: String = null
      createdByGroup: String = null
      modifiedByUser: String = null
      modifiedByGroup: String = null
  
      """Only return entries created after the given DateTime (Exclusive)"""
      createdBefore: DateTime = null
  
      """
      Only return entries created at or before the given DateTime (Inclusive)
      """
      createdAfter: DateTime = null
      metaHasKey: String = null
      metaValue: [JSONValueFilterType] = null
      search: String = null
  
      """FormOrdering"""
      orderBy: [FormOrdering] = null
      slugs: [String] = null
    ): FormConnection
    options(
      offset: Int = null
      before: String = null
      after: String = null
      first: Int = null
      last: Int = null
      metaValue: [JSONValueFilterType] = null
  
      """OptionOrdering"""
      orderBy: [OptionOrdering] = null
      slug: String = null
      label: String = null
      isArchived: Boolean = null
      createdByUser: String = null
      createdByGroup: String = null
      modifiedByUser: String = null
      modifiedByGroup: String = null
  
      """Only return entries created after the given DateTime (Exclusive)"""
      createdBefore: DateTime = null
  
      """
      Only return entries created at or before the given DateTime (Inclusive)
      """
      createdAfter: DateTime = null
      metaHasKey: String = null
      search: String = null
    ): OptionConnection
    staticContent: String
  
    """The ID of the object"""
    id: ID!
  }
  
  type Mutation {
    saveWorkflow(input: SaveWorkflowInput!): SaveWorkflowPayload
    addWorkflowFlow(input: AddWorkflowFlowInput!): AddWorkflowFlowPayload
    removeFlow(input: RemoveFlowInput!): RemoveFlowPayload
    saveSimpleTask(input: SaveSimpleTaskInput!): SaveSimpleTaskPayload
    saveCompleteWorkflowFormTask(input: SaveCompleteWorkflowFormTaskInput!): SaveCompleteWorkflowFormTaskPayload
    saveCompleteTaskFormTask(input: SaveCompleteTaskFormTaskInput!): SaveCompleteTaskFormTaskPayload
    startCase(input: StartCaseInput!): StartCasePayload @deprecated(reason: "Use SaveCase mutation instead")
    saveCase(input: SaveCaseInput!): SaveCasePayload
    cancelCase(input: CancelCaseInput!): CancelCasePayload
    suspendCase(input: SuspendCaseInput!): SuspendCasePayload
    resumeCase(input: ResumeCaseInput!): ResumeCasePayload
    completeWorkItem(input: CompleteWorkItemInput!): CompleteWorkItemPayload
    skipWorkItem(input: SkipWorkItemInput!): SkipWorkItemPayload
    cancelWorkItem(input: CancelWorkItemInput!): CancelWorkItemPayload
    suspendWorkItem(input: SuspendWorkItemInput!): SuspendWorkItemPayload
    resumeWorkItem(input: ResumeWorkItemInput!): ResumeWorkItemPayload
    saveWorkItem(input: SaveWorkItemInput!): SaveWorkItemPayload
    createWorkItem(input: CreateWorkItemInput!): CreateWorkItemPayload
    saveForm(input: SaveFormInput!): SaveFormPayload
    copyForm(input: CopyFormInput!): CopyFormPayload
  
    """Add question at the end of form."""
    addFormQuestion(input: AddFormQuestionInput!): AddFormQuestionPayload
    removeFormQuestion(input: RemoveFormQuestionInput!): RemoveFormQuestionPayload
    reorderFormQuestions(input: ReorderFormQuestionsInput!): ReorderFormQuestionsPayload
    saveOption(input: SaveOptionInput!): SaveOptionPayload
    copyOption(input: CopyOptionInput!): CopyOptionPayload
    copyQuestion(input: CopyQuestionInput!): CopyQuestionPayload
    saveTextQuestion(input: SaveTextQuestionInput!): SaveTextQuestionPayload
    saveTextareaQuestion(input: SaveTextareaQuestionInput!): SaveTextareaQuestionPayload
    saveDateQuestion(input: SaveDateQuestionInput!): SaveDateQuestionPayload
    saveChoiceQuestion(input: SaveChoiceQuestionInput!): SaveChoiceQuestionPayload
    saveMultipleChoiceQuestion(input: SaveMultipleChoiceQuestionInput!): SaveMultipleChoiceQuestionPayload
    saveDynamicChoiceQuestion(input: SaveDynamicChoiceQuestionInput!): SaveDynamicChoiceQuestionPayload
    saveDynamicMultipleChoiceQuestion(input: SaveDynamicMultipleChoiceQuestionInput!): SaveDynamicMultipleChoiceQuestionPayload
    saveFloatQuestion(input: SaveFloatQuestionInput!): SaveFloatQuestionPayload
    saveIntegerQuestion(input: SaveIntegerQuestionInput!): SaveIntegerQuestionPayload
    saveTableQuestion(input: SaveTableQuestionInput!): SaveTableQuestionPayload
    saveFormQuestion(input: SaveFormQuestionInput!): SaveFormQuestionPayload
    saveFileQuestion(input: SaveFileQuestionInput!): SaveFileQuestionPayload
    saveStaticQuestion(input: SaveStaticQuestionInput!): SaveStaticQuestionPayload
    saveCalculatedFloatQuestion(input: SaveCalculatedFloatQuestionInput!): SaveCalculatedFloatQuestionPayload
    saveActionButtonQuestion(input: SaveActionButtonQuestionInput!): SaveActionButtonQuestionPayload
    copyDocument(input: CopyDocumentInput!): CopyDocumentPayload
    saveDocument(input: SaveDocumentInput!): SaveDocumentPayload
    saveDocumentStringAnswer(input: SaveDocumentStringAnswerInput!): SaveDocumentStringAnswerPayload
    saveDocumentIntegerAnswer(input: SaveDocumentIntegerAnswerInput!): SaveDocumentIntegerAnswerPayload
    saveDocumentFloatAnswer(input: SaveDocumentFloatAnswerInput!): SaveDocumentFloatAnswerPayload
    saveDocumentDateAnswer(input: SaveDocumentDateAnswerInput!): SaveDocumentDateAnswerPayload
    saveDocumentListAnswer(input: SaveDocumentListAnswerInput!): SaveDocumentListAnswerPayload
    saveDocumentTableAnswer(input: SaveDocumentTableAnswerInput!): SaveDocumentTableAnswerPayload
    saveDocumentFileAnswer(input: SaveDocumentFileAnswerInput!): SaveDocumentFileAnswerPayload
    saveDefaultStringAnswer(input: SaveDefaultStringAnswerInput!): SaveDefaultStringAnswerPayload
    saveDefaultIntegerAnswer(input: SaveDefaultIntegerAnswerInput!): SaveDefaultIntegerAnswerPayload
    saveDefaultFloatAnswer(input: SaveDefaultFloatAnswerInput!): SaveDefaultFloatAnswerPayload
    saveDefaultDateAnswer(input: SaveDefaultDateAnswerInput!): SaveDefaultDateAnswerPayload
    saveDefaultListAnswer(input: SaveDefaultListAnswerInput!): SaveDefaultListAnswerPayload
    saveDefaultTableAnswer(input: SaveDefaultTableAnswerInput!): SaveDefaultTableAnswerPayload
    removeAnswer(input: RemoveAnswerInput!): RemoveAnswerPayload
    removeDefaultAnswer(input: RemoveDefaultAnswerInput!): RemoveDefaultAnswerPayload
    removeDocument(input: RemoveDocumentInput!): RemoveDocumentPayload
  }
  
  """An object with an ID"""
  interface Node {
    """The ID of the object"""
    id: ID!
  }
  
  type Option implements Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    slug: String!
    label: String!
    isArchived: Boolean!
    meta: GenericScalar
  
    """Reference this option has been copied from"""
    source: Option
  
    """The ID of the object"""
    id: ID!
  }
  
  type OptionConnection {
    """Pagination data for this connection."""
    pageInfo: PageInfo!
  
    """Contains the nodes in this connection."""
    edges: [OptionEdge]!
    totalCount: Int
  }
  
  """A Relay edge containing a `Option` and its cursor."""
  type OptionEdge {
    """The item at the end of the edge"""
    node: Option
  
    """A cursor for use in pagination"""
    cursor: String!
  }
  
  """An enumeration."""
  enum OptionOrdering {
    """Label"""
    LABEL_ASC
  
    """Label (descending)"""
    LABEL_DESC
  
    """Created at"""
    CREATED_AT_ASC
  
    """Created at (descending)"""
    CREATED_AT_DESC
  
    """Modified at"""
    MODIFIED_AT_ASC
  
    """Modified at (descending)"""
    MODIFIED_AT_DESC
  
    """Created by user"""
    CREATED_BY_USER_ASC
  
    """Created by user (descending)"""
    CREATED_BY_USER_DESC
  
    """Created by group"""
    CREATED_BY_GROUP_ASC
  
    """Created by group (descending)"""
    CREATED_BY_GROUP_DESC
  
    """Modified by user"""
    MODIFIED_BY_USER_ASC
  
    """Modified by user (descending)"""
    MODIFIED_BY_USER_DESC
  
    """Modified by group"""
    MODIFIED_BY_GROUP_ASC
  
    """Modified by group (descending)"""
    MODIFIED_BY_GROUP_DESC
  
    """Meta test-key"""
    META_TEST_KEY_ASC
  
    """Meta test-key (descending)"""
    META_TEST_KEY_DESC
  
    """Meta foobar"""
    META_FOOBAR_ASC
  
    """Meta foobar (descending)"""
    META_FOOBAR_DESC
  }
  
  """
  The Relay compliant `PageInfo` type, containing data necessary to paginate this connection.
  """
  type PageInfo {
    """When paginating forwards, are there more items?"""
    hasNextPage: Boolean!
  
    """When paginating backwards, are there more items?"""
    hasPreviousPage: Boolean!
  
    """When paginating backwards, the cursor to continue."""
    startCursor: String
  
    """When paginating forwards, the cursor to continue."""
    endCursor: String
  }
  
  type Query {
    documentAsOf(id: ID!, asOf: DateTime!): HistoricalDocument
    allDataSources(before: String = null, after: String = null, first: Int = null, last: Int = null): DataSourceConnection
    dataSource(name: String!, before: String = null, after: String = null, first: Int = null, last: Int = null): DataSourceDataConnection
    allWorkflows(
      offset: Int = null
      before: String = null
      after: String = null
      first: Int = null
      last: Int = null
      metaValue: [JSONValueFilterType] = null
      slug: String = null
      name: String = null
      description: String = null
      isPublished: Boolean = null
      isArchived: Boolean = null
  
      """WorkflowOrdering"""
      orderBy: [WorkflowOrdering] = null
      filter: [WorkflowFilterSetType] = null
      order: [WorkflowOrderSetType] = null
      createdByUser: String = null
      createdByGroup: String = null
      modifiedByUser: String = null
      modifiedByGroup: String = null
  
      """Only return entries created after the given DateTime (Exclusive)"""
      createdBefore: DateTime = null
  
      """
      Only return entries created at or before the given DateTime (Inclusive)
      """
      createdAfter: DateTime = null
      metaHasKey: String = null
      search: String = null
    ): WorkflowConnection
    allTasks(
      offset: Int = null
      before: String = null
      after: String = null
      first: Int = null
      last: Int = null
      metaValue: [JSONValueFilterType] = null
      slug: String = null
      name: String = null
      description: String = null
      type: TaskTypeArgument = null
      isArchived: Boolean = null
  
      """TaskOrdering"""
      orderBy: [TaskOrdering] = null
      filter: [TaskFilterSetType] = null
      order: [TaskOrderSetType] = null
      createdByUser: String = null
      createdByGroup: String = null
      modifiedByUser: String = null
      modifiedByGroup: String = null
  
      """Only return entries created after the given DateTime (Exclusive)"""
      createdBefore: DateTime = null
  
      """
      Only return entries created at or before the given DateTime (Inclusive)
      """
      createdAfter: DateTime = null
      metaHasKey: String = null
      search: String = null
    ): TaskConnection
    allCases(
      offset: Int = null
      before: String = null
      after: String = null
      first: Int = null
      last: Int = null
      metaValue: [JSONValueFilterType] = null
      workflow: ID = null
  
      """CaseOrdering"""
      orderBy: [CaseOrdering] = null
      filter: [CaseFilterSetType] = null
      order: [CaseOrderSetType] = null
      createdByUser: String = null
      createdByGroup: String = null
      modifiedByUser: String = null
      modifiedByGroup: String = null
  
      """Only return entries created after the given DateTime (Exclusive)"""
      createdBefore: DateTime = null
  
      """
      Only return entries created at or before the given DateTime (Inclusive)
      """
      createdAfter: DateTime = null
      metaHasKey: String = null
      id: ID = null
      documentForm: String = null
      documentForms: [String] = null
      hasAnswer: [HasAnswerFilterType] = null
      workItemDocumentHasAnswer: [HasAnswerFilterType] = null
      rootCase: ID = null
      searchAnswers: [SearchAnswersFilterType] = null
      status: [[CaseStatusArgument]] = null
  
      """
      Expects a question slug. If the slug is prefixed with a hyphen, the order will be reversed
      
      For file questions, the filename is used for sorting.
      
      Table questions are not supported at this time.
      """
      orderByQuestionAnswerValue: String = null
    ): CaseConnection
    allWorkItems(
      offset: Int = null
      before: String = null
      after: String = null
      first: Int = null
      last: Int = null
      metaValue: [JSONValueFilterType] = null
      status: WorkItemStatusArgument = null
  
      """WorkItemOrdering"""
      orderBy: [WorkItemOrdering] = null
      filter: [WorkItemFilterSetType] = null
      order: [WorkItemOrderSetType] = null
      documentHasAnswer: [HasAnswerFilterType] = null
      caseDocumentHasAnswer: [HasAnswerFilterType] = null
      caseMetaValue: [JSONValueFilterType] = null
      rootCaseMetaValue: [JSONValueFilterType] = null
      name: String = null
      task: ID = null
      tasks: [String] = null
      case: ID = null
      createdAt: DateTime = null
      closedAt: DateTime = null
      modifiedAt: DateTime = null
      deadline: DateTime = null
      hasDeadline: Boolean = null
      caseFamily: ID = null
      createdByUser: String = null
      createdByGroup: String = null
      modifiedByUser: String = null
      modifiedByGroup: String = null
  
      """Only return entries created after the given DateTime (Exclusive)"""
      createdBefore: DateTime = null
  
      """
      Only return entries created at or before the given DateTime (Inclusive)
      """
      createdAfter: DateTime = null
      metaHasKey: String = null
      id: ID = null
      addressedGroups: [String] = null
      controllingGroups: [String] = null
      assignedUsers: [String] = null
    ): WorkItemConnection
    allForms(
      offset: Int = null
      before: String = null
      after: String = null
      first: Int = null
      last: Int = null
      metaValue: [JSONValueFilterType] = null
  
      """FormOrdering"""
      orderBy: [FormOrdering] = null
      slug: String = null
      name: String = null
      description: String = null
      isPublished: Boolean = null
      isArchived: Boolean = null
      questions: [String] = null
      filter: [FormFilterSetType] = null
      order: [FormOrderSetType] = null
      createdByUser: String = null
      createdByGroup: String = null
      modifiedByUser: String = null
      modifiedByGroup: String = null
  
      """Only return entries created after the given DateTime (Exclusive)"""
      createdBefore: DateTime = null
  
      """
      Only return entries created at or before the given DateTime (Inclusive)
      """
      createdAfter: DateTime = null
      metaHasKey: String = null
      search: String = null
      slugs: [String] = null
    ): FormConnection
    allQuestions(
      offset: Int = null
      before: String = null
      after: String = null
      first: Int = null
      last: Int = null
      metaValue: [JSONValueFilterType] = null
  
      """QuestionOrdering"""
      orderBy: [QuestionOrdering] = null
      slug: String = null
      label: String = null
      isRequired: String = null
      isHidden: String = null
      isArchived: Boolean = null
      subForm: ID = null
      rowForm: ID = null
      filter: [QuestionFilterSetType] = null
      order: [QuestionOrderSetType] = null
      createdByUser: String = null
      createdByGroup: String = null
      modifiedByUser: String = null
      modifiedByGroup: String = null
  
      """Only return entries created after the given DateTime (Exclusive)"""
      createdBefore: DateTime = null
  
      """
      Only return entries created at or before the given DateTime (Inclusive)
      """
      createdAfter: DateTime = null
      metaHasKey: String = null
      excludeForms: [ID] = null
      search: String = null
      slugs: [String] = null
    ): QuestionConnection
    allDocuments(
      offset: Int = null
      before: String = null
      after: String = null
      first: Int = null
      last: Int = null
      metaValue: [JSONValueFilterType] = null
      form: ID = null
      forms: [ID] = null
      search: String = null
      id: ID = null
  
      """DocumentOrdering"""
      orderBy: [DocumentOrdering] = null
      filter: [DocumentFilterSetType] = null
      order: [DocumentOrderSetType] = null
      createdByUser: String = null
      createdByGroup: String = null
      modifiedByUser: String = null
      modifiedByGroup: String = null
  
      """Only return entries created after the given DateTime (Exclusive)"""
      createdBefore: DateTime = null
  
      """
      Only return entries created at or before the given DateTime (Inclusive)
      """
      createdAfter: DateTime = null
      metaHasKey: String = null
      rootDocument: ID = null
      hasAnswer: [HasAnswerFilterType] = null
      searchAnswers: [SearchAnswersFilterType] = null
    ): DocumentConnection
    allFormatValidators(before: String = null, after: String = null, first: Int = null, last: Int = null): FormatValidatorConnection
    allUsedDynamicOptions(
      offset: Int = null
      before: String = null
      after: String = null
      first: Int = null
      last: Int = null
      question: ID = null
      document: ID = null
      filter: [DynamicOptionFilterSetType] = null
      createdByUser: String = null
      createdByGroup: String = null
      modifiedByUser: String = null
      modifiedByGroup: String = null
  
      """Only return entries created after the given DateTime (Exclusive)"""
      createdBefore: DateTime = null
  
      """
      Only return entries created at or before the given DateTime (Inclusive)
      """
      createdAfter: DateTime = null
    ): DynamicOptionConnection
    documentValidity(id: ID!, before: String = null, after: String = null, first: Int = null, last: Int = null): DocumentValidityConnection
    node(
      """The ID of the object"""
      id: ID!
    ): Node
    _debug: DjangoDebug
  }
  
  interface Question {
    id: ID!
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    slug: String!
    label: String!
    infoText: String
  
    """Required expression is only evaluated when question is not hidden."""
    isRequired: QuestionJexl!
    isHidden: QuestionJexl!
    isArchived: Boolean!
    meta: GenericScalar!
    forms(
      offset: Int = null
      before: String = null
      after: String = null
      first: Int = null
      last: Int = null
      slug: String = null
      name: String = null
      description: String = null
      isPublished: Boolean = null
      isArchived: Boolean = null
      questions: [String] = null
      createdByUser: String = null
      createdByGroup: String = null
      modifiedByUser: String = null
      modifiedByGroup: String = null
  
      """Only return entries created after the given DateTime (Exclusive)"""
      createdBefore: DateTime = null
  
      """
      Only return entries created at or before the given DateTime (Inclusive)
      """
      createdAfter: DateTime = null
      metaHasKey: String = null
      metaValue: [JSONValueFilterType] = null
      search: String = null
  
      """FormOrdering"""
      orderBy: [FormOrdering] = null
      slugs: [String] = null
    ): FormConnection
    source: Question
  }
  
  type QuestionConnection {
    """Pagination data for this connection."""
    pageInfo: PageInfo!
  
    """Contains the nodes in this connection."""
    edges: [QuestionEdge]!
    totalCount: Int
  }
  
  """A Relay edge containing a `Question` and its cursor."""
  type QuestionEdge {
    """The item at the end of the edge"""
    node: Question
  
    """A cursor for use in pagination"""
    cursor: String!
  }
  
  input QuestionFilterSetType {
    """"""
    orderBy: [QuestionOrdering]
    slug: String
    label: String
    isRequired: String
    isHidden: String
    isArchived: Boolean
    subForm: ID
    rowForm: ID
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    createdBefore: DateTime
    createdAfter: DateTime
    metaHasKey: String
    metaValue: [JSONValueFilterType]
    excludeForms: [ID]
    search: String
    slugs: [String]
    invert: Boolean
  }
  
  """
  Question jexl expression returning boolean.
  
  Following transform can be used:
  * answer - access answer of document by question slug
  * mapby - map list by key. Helpful to work with table answers
    whereas an answer is a list of dicts.
  
  Following context is available:
  * form - access form of document
  
  Examples:
  * 'answer' == 'question-slug'|answer
  * 'answer' in 'list-question-slug'|answer
  * 'answer' in 'table-question-slug'|answer|mapby('column-question')
  * 'form-slug' == form
  """
  scalar QuestionJexl
  
  input QuestionOrderSetType {
    meta: String
    attribute: SortableQuestionAttributes
    direction: AscDesc
  }
  
  """An enumeration."""
  enum QuestionOrdering {
    """Label"""
    LABEL_ASC
  
    """Label (descending)"""
    LABEL_DESC
  
    """Created at"""
    CREATED_AT_ASC
  
    """Created at (descending)"""
    CREATED_AT_DESC
  
    """Modified at"""
    MODIFIED_AT_ASC
  
    """Modified at (descending)"""
    MODIFIED_AT_DESC
  
    """Created by user"""
    CREATED_BY_USER_ASC
  
    """Created by user (descending)"""
    CREATED_BY_USER_DESC
  
    """Created by group"""
    CREATED_BY_GROUP_ASC
  
    """Created by group (descending)"""
    CREATED_BY_GROUP_DESC
  
    """Modified by user"""
    MODIFIED_BY_USER_ASC
  
    """Modified by user (descending)"""
    MODIFIED_BY_USER_DESC
  
    """Modified by group"""
    MODIFIED_BY_GROUP_ASC
  
    """Modified by group (descending)"""
    MODIFIED_BY_GROUP_DESC
  
    """Meta test-key"""
    META_TEST_KEY_ASC
  
    """Meta test-key (descending)"""
    META_TEST_KEY_DESC
  
    """Meta foobar"""
    META_FOOBAR_ASC
  
    """Meta foobar (descending)"""
    META_FOOBAR_DESC
  }
  
  input RemoveAnswerInput {
    answer: ID!
    clientMutationId: String
  }
  
  type RemoveAnswerPayload {
    answer: Answer
    clientMutationId: String
  }
  
  input RemoveDefaultAnswerInput {
    question: ID!
    clientMutationId: String
  }
  
  type RemoveDefaultAnswerPayload {
    question: Question
    clientMutationId: String
  }
  
  input RemoveDocumentInput {
    document: ID!
    clientMutationId: String
  }
  
  type RemoveDocumentPayload {
    document: Document
    clientMutationId: String
  }
  
  input RemoveFlowInput {
    flow: ID!
    clientMutationId: String
  }
  
  type RemoveFlowPayload {
    flow: Flow
    clientMutationId: String
  }
  
  input RemoveFormQuestionInput {
    form: ID!
    question: ID!
    clientMutationId: String
  }
  
  type RemoveFormQuestionPayload {
    form: Form
    clientMutationId: String
  }
  
  input ReorderFormQuestionsInput {
    form: ID!
    questions: [ID]!
    clientMutationId: String
  }
  
  type ReorderFormQuestionsPayload {
    form: Form
    clientMutationId: String
  }
  
  input ResumeCaseInput {
    id: ID!
  
    """Provide extra context for dynamic jexl transforms and events"""
    context: JSONString
    clientMutationId: String
  }
  
  type ResumeCasePayload {
    case: Case
    clientMutationId: String
  }
  
  input ResumeWorkItemInput {
    id: ID!
  
    """Provide extra context for dynamic jexl transforms and events"""
    context: JSONString
    clientMutationId: String
  }
  
  type ResumeWorkItemPayload {
    workItem: WorkItem
    clientMutationId: String
  }
  
  input SaveActionButtonQuestionInput {
    label: String!
    slug: String!
    infoText: String
    isHidden: QuestionJexl
    meta: JSONString
    isArchived: Boolean
    action: ButtonAction!
    color: ButtonColor!
    validateOnEnter: Boolean!
    clientMutationId: String
  }
  
  type SaveActionButtonQuestionPayload {
    question: Question
    clientMutationId: String
  }
  
  input SaveCalculatedFloatQuestionInput {
    slug: String!
    label: String!
    infoText: String
    isRequired: QuestionJexl
    isHidden: QuestionJexl
    meta: JSONString
    isArchived: Boolean
    calcExpression: QuestionJexl
    clientMutationId: String
  }
  
  type SaveCalculatedFloatQuestionPayload {
    question: Question
    clientMutationId: String
  }
  
  input SaveCaseInput {
    id: String
    workflow: ID!
    meta: JSONString
    parentWorkItem: ID
    form: ID
  
    """Provide extra context for dynamic jexl transforms and events"""
    context: JSONString
    clientMutationId: String
  }
  
  type SaveCasePayload {
    case: Case
    clientMutationId: String
  }
  
  input SaveChoiceQuestionInput {
    slug: String!
    label: String!
    infoText: String
    isRequired: QuestionJexl
    isHidden: QuestionJexl
    meta: JSONString
    isArchived: Boolean
    options: [ID]!
    clientMutationId: String
  }
  
  type SaveChoiceQuestionPayload {
    question: Question
    clientMutationId: String
  }
  
  input SaveCompleteTaskFormTaskInput {
    slug: String!
    name: String!
    description: String
    meta: JSONString
  
    """
    Group jexl returning what group(s) derived work items will be addressed to.
    """
    addressGroups: GroupJexl
  
    """
    Group jexl returning what group(s) derived work items will be assigned to for controlling.
    """
    controlGroups: GroupJexl
    isArchived: Boolean
  
    """Time in seconds task may take to be processed."""
    leadTime: Int
  
    """
    Allows creating multiple work items for this task using the `CreateWorkItem` mutation. If true, one work item will be created for each entry in `address_groups`.
    """
    isMultipleInstance: Boolean
    form: ID!
    clientMutationId: String
  }
  
  type SaveCompleteTaskFormTaskPayload {
    task: Task
    clientMutationId: String
  }
  
  input SaveCompleteWorkflowFormTaskInput {
    slug: String!
    name: String!
    description: String
    meta: JSONString
  
    """
    Group jexl returning what group(s) derived work items will be addressed to.
    """
    addressGroups: GroupJexl
  
    """
    Group jexl returning what group(s) derived work items will be assigned to for controlling.
    """
    controlGroups: GroupJexl
    isArchived: Boolean
  
    """Time in seconds task may take to be processed."""
    leadTime: Int
  
    """
    Allows creating multiple work items for this task using the `CreateWorkItem` mutation. If true, one work item will be created for each entry in `address_groups`.
    """
    isMultipleInstance: Boolean
    clientMutationId: String
  }
  
  type SaveCompleteWorkflowFormTaskPayload {
    task: Task
    clientMutationId: String
  }
  
  input SaveDateQuestionInput {
    slug: String!
    label: String!
    infoText: String
    isRequired: QuestionJexl
    isHidden: QuestionJexl
    meta: JSONString
    isArchived: Boolean
    clientMutationId: String
  }
  
  type SaveDateQuestionPayload {
    question: Question
    clientMutationId: String
  }
  
  input SaveDefaultDateAnswerInput {
    question: ID!
    meta: JSONString
    value: Date
    clientMutationId: String
  }
  
  type SaveDefaultDateAnswerPayload {
    answer: Answer
    clientMutationId: String
  }
  
  input SaveDefaultFloatAnswerInput {
    question: ID!
    meta: JSONString
    value: Float
    clientMutationId: String
  }
  
  type SaveDefaultFloatAnswerPayload {
    answer: Answer
    clientMutationId: String
  }
  
  input SaveDefaultIntegerAnswerInput {
    question: ID!
    meta: JSONString
    value: Int
    clientMutationId: String
  }
  
  type SaveDefaultIntegerAnswerPayload {
    answer: Answer
    clientMutationId: String
  }
  
  input SaveDefaultListAnswerInput {
    question: ID!
    meta: JSONString
    value: [String]
    clientMutationId: String
  }
  
  type SaveDefaultListAnswerPayload {
    answer: Answer
    clientMutationId: String
  }
  
  input SaveDefaultStringAnswerInput {
    question: ID!
    meta: JSONString
    value: String
    clientMutationId: String
  }
  
  type SaveDefaultStringAnswerPayload {
    answer: Answer
    clientMutationId: String
  }
  
  input SaveDefaultTableAnswerInput {
    question: ID!
    meta: JSONString
  
    """List of document IDs representing the rows in the table."""
    value: [ID]
    clientMutationId: String
  }
  
  type SaveDefaultTableAnswerPayload {
    answer: Answer
    clientMutationId: String
  }
  
  input SaveDocumentDateAnswerInput {
    question: ID!
    document: ID!
    meta: JSONString
    value: Date
    clientMutationId: String
  }
  
  type SaveDocumentDateAnswerPayload {
    answer: Answer
    clientMutationId: String
  }
  
  input SaveDocumentFileAnswerInput {
    question: ID!
    document: ID!
    meta: JSONString
    value: String
    clientMutationId: String
  }
  
  type SaveDocumentFileAnswerPayload {
    answer: Answer
    clientMutationId: String
  }
  
  input SaveDocumentFloatAnswerInput {
    question: ID!
    document: ID!
    meta: JSONString
    value: Float
    clientMutationId: String
  }
  
  type SaveDocumentFloatAnswerPayload {
    answer: Answer
    clientMutationId: String
  }
  
  input SaveDocumentInput {
    id: String
    form: ID!
    meta: JSONString
    clientMutationId: String
  }
  
  input SaveDocumentIntegerAnswerInput {
    question: ID!
    document: ID!
    meta: JSONString
    value: Int
    clientMutationId: String
  }
  
  type SaveDocumentIntegerAnswerPayload {
    answer: Answer
    clientMutationId: String
  }
  
  input SaveDocumentListAnswerInput {
    question: ID!
    document: ID!
    meta: JSONString
    value: [String]
    clientMutationId: String
  }
  
  type SaveDocumentListAnswerPayload {
    answer: Answer
    clientMutationId: String
  }
  
  type SaveDocumentPayload {
    document: Document
    clientMutationId: String
  }
  
  input SaveDocumentStringAnswerInput {
    question: ID!
    document: ID!
    meta: JSONString
    value: String
    clientMutationId: String
  }
  
  type SaveDocumentStringAnswerPayload {
    answer: Answer
    clientMutationId: String
  }
  
  input SaveDocumentTableAnswerInput {
    question: ID!
    document: ID!
    meta: JSONString
  
    """List of document IDs representing the rows in the table."""
    value: [ID]
    clientMutationId: String
  }
  
  type SaveDocumentTableAnswerPayload {
    answer: Answer
    clientMutationId: String
  }
  
  input SaveDynamicChoiceQuestionInput {
    slug: String!
    label: String!
    infoText: String
    isRequired: QuestionJexl
    isHidden: QuestionJexl
    meta: JSONString
    isArchived: Boolean
    dataSource: String!
    clientMutationId: String
  }
  
  type SaveDynamicChoiceQuestionPayload {
    question: Question
    clientMutationId: String
  }
  
  input SaveDynamicMultipleChoiceQuestionInput {
    slug: String!
    label: String!
    infoText: String
    isRequired: QuestionJexl
    isHidden: QuestionJexl
    meta: JSONString
    isArchived: Boolean
    dataSource: String!
    clientMutationId: String
  }
  
  type SaveDynamicMultipleChoiceQuestionPayload {
    question: Question
    clientMutationId: String
  }
  
  input SaveFileQuestionInput {
    slug: String!
    label: String!
    infoText: String
    isRequired: QuestionJexl
    isHidden: QuestionJexl
    meta: JSONString
    isArchived: Boolean
    clientMutationId: String
  }
  
  type SaveFileQuestionPayload {
    question: Question
    clientMutationId: String
  }
  
  input SaveFloatQuestionInput {
    slug: String!
    label: String!
    infoText: String
    isRequired: QuestionJexl
    isHidden: QuestionJexl
    meta: JSONString
    isArchived: Boolean
    minValue: Float
    maxValue: Float
    placeholder: String
    clientMutationId: String
  }
  
  type SaveFloatQuestionPayload {
    question: Question
    clientMutationId: String
  }
  
  input SaveFormInput {
    slug: String!
    name: String!
    description: String
    meta: JSONString
    isArchived: Boolean
    isPublished: Boolean
    clientMutationId: String
  }
  
  type SaveFormPayload {
    form: Form
    clientMutationId: String
  }
  
  input SaveFormQuestionInput {
    slug: String!
    label: String!
    infoText: String
    isRequired: QuestionJexl
    isHidden: QuestionJexl
    meta: JSONString
    isArchived: Boolean
    subForm: ID!
    clientMutationId: String
  }
  
  type SaveFormQuestionPayload {
    question: Question
    clientMutationId: String
  }
  
  input SaveIntegerQuestionInput {
    slug: String!
    label: String!
    infoText: String
    isRequired: QuestionJexl
    isHidden: QuestionJexl
    meta: JSONString
    isArchived: Boolean
    minValue: Int
    maxValue: Int
    placeholder: String
    clientMutationId: String
  }
  
  type SaveIntegerQuestionPayload {
    question: Question
    clientMutationId: String
  }
  
  input SaveMultipleChoiceQuestionInput {
    slug: String!
    label: String!
    infoText: String
    isRequired: QuestionJexl
    isHidden: QuestionJexl
    meta: JSONString
    isArchived: Boolean
    options: [ID]!
    clientMutationId: String
  }
  
  type SaveMultipleChoiceQuestionPayload {
    question: Question
    clientMutationId: String
  }
  
  input SaveOptionInput {
    slug: String!
    label: String!
    isArchived: Boolean
    meta: JSONString
    clientMutationId: String
  }
  
  type SaveOptionPayload {
    option: Option
    clientMutationId: String
  }
  
  input SaveSimpleTaskInput {
    slug: String!
    name: String!
    description: String
    meta: JSONString
  
    """
    Group jexl returning what group(s) derived work items will be addressed to.
    """
    addressGroups: GroupJexl
  
    """
    Group jexl returning what group(s) derived work items will be assigned to for controlling.
    """
    controlGroups: GroupJexl
    isArchived: Boolean
  
    """Time in seconds task may take to be processed."""
    leadTime: Int
  
    """
    Allows creating multiple work items for this task using the `CreateWorkItem` mutation. If true, one work item will be created for each entry in `address_groups`.
    """
    isMultipleInstance: Boolean
    clientMutationId: String
  }
  
  type SaveSimpleTaskPayload {
    task: Task
    clientMutationId: String
  }
  
  input SaveStaticQuestionInput {
    label: String!
    slug: String!
    infoText: String
    isHidden: QuestionJexl
    meta: JSONString
    isArchived: Boolean
    staticContent: String
    clientMutationId: String
  }
  
  type SaveStaticQuestionPayload {
    question: Question
    clientMutationId: String
  }
  
  input SaveTableQuestionInput {
    slug: String!
    label: String!
    infoText: String
    isRequired: QuestionJexl
    isHidden: QuestionJexl
    meta: JSONString
    isArchived: Boolean
  
    """Form that represents rows of a TableQuestion"""
    rowForm: ID!
    clientMutationId: String
  }
  
  type SaveTableQuestionPayload {
    question: Question
    clientMutationId: String
  }
  
  input SaveTextQuestionInput {
    slug: String!
    label: String!
    infoText: String
    isRequired: QuestionJexl
    isHidden: QuestionJexl
    meta: JSONString
    isArchived: Boolean
    minLength: Int
    maxLength: Int
    placeholder: String
    formatValidators: [String]
    clientMutationId: String
  }
  
  type SaveTextQuestionPayload {
    question: Question
    clientMutationId: String
  }
  
  input SaveTextareaQuestionInput {
    slug: String!
    label: String!
    infoText: String
    isRequired: QuestionJexl
    isHidden: QuestionJexl
    meta: JSONString
    isArchived: Boolean
    minLength: Int
    maxLength: Int
    placeholder: String
    formatValidators: [String]
    clientMutationId: String
  }
  
  type SaveTextareaQuestionPayload {
    question: Question
    clientMutationId: String
  }
  
  input SaveWorkItemInput {
    workItem: ID!
  
    """Will be set from Task, if not provided."""
    name: String
  
    """Will be set from Task, if not provided."""
    description: String
  
    """Users responsible to undertake given work item."""
    assignedUsers: [String]
    deadline: DateTime
    meta: JSONString
  
    """Provide extra context for dynamic jexl transforms and events"""
    context: JSONString
    clientMutationId: String
  }
  
  type SaveWorkItemPayload {
    workItem: WorkItem
    clientMutationId: String
  }
  
  input SaveWorkflowInput {
    slug: String!
    name: String!
    description: String
    meta: JSONString
  
    """Starting task(s) of the workflow."""
    startTasks: [ID]!
  
    """Allow workflow to be started with any form"""
    allowAllForms: Boolean
  
    """List of forms which are allowed to start workflow with"""
    allowForms: [ID]
    isArchived: Boolean
    isPublished: Boolean
    clientMutationId: String
  }
  
  type SaveWorkflowPayload {
    workflow: Workflow
    clientMutationId: String
  }
  
  """Lookup type to search in answers."""
  input SearchAnswersFilterType {
    questions: [ID]
    value: GenericScalar!
    lookup: SearchLookupMode
  }
  
  enum SearchLookupMode {
    STARTSWITH
    CONTAINS
    TEXT
  }
  
  type SelectedOption {
    label: String!
    slug: String!
  }
  
  type SelectedOptionConnection {
    """Pagination data for this connection."""
    pageInfo: PageInfo!
  
    """Contains the nodes in this connection."""
    edges: [SelectedOptionEdge]!
    totalCount: Int
  }
  
  """A Relay edge containing a `SelectedOption` and its cursor."""
  type SelectedOptionEdge {
    """The item at the end of the edge"""
    node: SelectedOption
  
    """A cursor for use in pagination"""
    cursor: String!
  }
  
  type SimpleTask implements Task & Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    slug: String!
    name: String!
    description: String
    type: CalumaWorkflowTaskTypeChoices!
    meta: GenericScalar!
    addressGroups: GroupJexl
    controlGroups: GroupJexl
    isArchived: Boolean!
  
    """Time in seconds task may take to be processed."""
    leadTime: Int
    isMultipleInstance: Boolean!
  
    """The ID of the object"""
    id: ID!
  }
  
  input SkipWorkItemInput {
    id: ID!
  
    """Provide extra context for dynamic jexl transforms and events"""
    context: JSONString
    clientMutationId: String
  }
  
  type SkipWorkItemPayload {
    workItem: WorkItem
    clientMutationId: String
  }
  
  enum SortableAnswerAttributes {
    CREATED_AT
    MODIFIED_AT
    CREATED_BY_USER
    CREATED_BY_GROUP
    MODIFIED_BY_USER
    MODIFIED_BY_GROUP
    QUESTION
    VALUE
    DOCUMENT
    DATE
    FILE
  }
  
  enum SortableCaseAttributes {
    ALLOW_ALL_FORMS
    CREATED_BY_GROUP
    CREATED_BY_USER
    DESCRIPTION
    IS_ARCHIVED
    IS_PUBLISHED
    NAME
    STATUS
    SLUG
  }
  
  enum SortableDocumentAttributes {
    CREATED_AT
    MODIFIED_AT
    CREATED_BY_USER
    CREATED_BY_GROUP
    MODIFIED_BY_USER
    MODIFIED_BY_GROUP
    FORM
    SOURCE
  }
  
  enum SortableFormAttributes {
    CREATED_AT
    MODIFIED_AT
    CREATED_BY_USER
    CREATED_BY_GROUP
    MODIFIED_BY_USER
    MODIFIED_BY_GROUP
    SLUG
    NAME
    DESCRIPTION
    IS_PUBLISHED
    IS_ARCHIVED
  }
  
  enum SortableQuestionAttributes {
    CREATED_AT
    MODIFIED_AT
    CREATED_BY_USER
    CREATED_BY_GROUP
    MODIFIED_BY_USER
    MODIFIED_BY_GROUP
    SLUG
    LABEL
    TYPE
    IS_REQUIRED
    IS_HIDDEN
    IS_ARCHIVED
    PLACEHOLDER
    INFO_TEXT
    CALC_EXPRESSION
  }
  
  enum SortableTaskAttributes {
    ALLOW_ALL_FORMS
    LEAD_TIME
    TYPE
    CREATED_BY_GROUP
    CREATED_BY_USER
    DESCRIPTION
    IS_ARCHIVED
    IS_PUBLISHED
    NAME
    SLUG
  }
  
  enum SortableWorkItemAttributes {
    ALLOW_ALL_FORMS
    CREATED_BY_GROUP
    CREATED_BY_USER
    DESCRIPTION
    CREATED_AT
    MODIFIED_AT
    CLOSED_AT
    IS_ARCHIVED
    IS_PUBLISHED
    NAME
    DEADLINE
    STATUS
    SLUG
  }
  
  enum SortableWorkflowAttributes {
    ALLOW_ALL_FORMS
    CREATED_BY_GROUP
    CREATED_BY_USER
    DESCRIPTION
    IS_ARCHIVED
    IS_PUBLISHED
    NAME
    SLUG
  }
  
  input StartCaseInput {
    workflow: ID!
    meta: JSONString
    parentWorkItem: ID
    form: ID
  
    """Provide extra context for dynamic jexl transforms and events"""
    context: JSONString
    clientMutationId: String
  }
  
  type StartCasePayload {
    case: Case
    clientMutationId: String
  }
  
  type StaticQuestion implements Question & Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    slug: String!
    label: String!
  
    """
    Required expression is only evaluated when question is not hidden. This should not be used for `StaticQuestion`, because it can never be satisfied.
    """
    isRequired: QuestionJexl!
    isHidden: QuestionJexl!
    isArchived: Boolean!
    infoText: String
    meta: GenericScalar!
    source: Question
    forms(
      offset: Int = null
      before: String = null
      after: String = null
      first: Int = null
      last: Int = null
      slug: String = null
      name: String = null
      description: String = null
      isPublished: Boolean = null
      isArchived: Boolean = null
      questions: [String] = null
      createdByUser: String = null
      createdByGroup: String = null
      modifiedByUser: String = null
      modifiedByGroup: String = null
  
      """Only return entries created after the given DateTime (Exclusive)"""
      createdBefore: DateTime = null
  
      """
      Only return entries created at or before the given DateTime (Inclusive)
      """
      createdAfter: DateTime = null
      metaHasKey: String = null
      metaValue: [JSONValueFilterType] = null
      search: String = null
  
      """FormOrdering"""
      orderBy: [FormOrdering] = null
      slugs: [String] = null
    ): FormConnection
    staticContent: String
    dataSource: String
  
    """The ID of the object"""
    id: ID!
  }
  
  """An enumeration."""
  enum Status {
    """Work item is ready to be processed."""
    READY
  
    """Work item is done."""
    COMPLETED
  
    """Work item is canceled."""
    CANCELED
  
    """Work item is skipped."""
    SKIPPED
  
    """Work item is suspended."""
    SUSPENDED
  }
  
  type StringAnswer implements Answer & Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
  
    """The ID of the object"""
    id: ID!
    question: Question!
    value: String
    meta: GenericScalar!
    selectedOption: SelectedOption
  }
  
  input SuspendCaseInput {
    id: ID!
  
    """Provide extra context for dynamic jexl transforms and events"""
    context: JSONString
    clientMutationId: String
  }
  
  type SuspendCasePayload {
    case: Case
    clientMutationId: String
  }
  
  input SuspendWorkItemInput {
    id: ID!
  
    """Provide extra context for dynamic jexl transforms and events"""
    context: JSONString
    clientMutationId: String
  }
  
  type SuspendWorkItemPayload {
    workItem: WorkItem
    clientMutationId: String
  }
  
  type TableAnswer implements Answer & Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
  
    """The ID of the object"""
    id: ID!
    question: Question!
    value: [Document]
    meta: GenericScalar!
    document: Document
  }
  
  type TableQuestion implements Question & Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    slug: String!
    label: String!
  
    """Required expression is only evaluated when question is not hidden."""
    isRequired: QuestionJexl!
    isHidden: QuestionJexl!
    isArchived: Boolean!
    infoText: String
    meta: GenericScalar!
    source: Question
    defaultAnswer: TableAnswer
    forms(
      offset: Int = null
      before: String = null
      after: String = null
      first: Int = null
      last: Int = null
      slug: String = null
      name: String = null
      description: String = null
      isPublished: Boolean = null
      isArchived: Boolean = null
      questions: [String] = null
      createdByUser: String = null
      createdByGroup: String = null
      modifiedByUser: String = null
      modifiedByGroup: String = null
  
      """Only return entries created after the given DateTime (Exclusive)"""
      createdBefore: DateTime = null
  
      """
      Only return entries created at or before the given DateTime (Inclusive)
      """
      createdAfter: DateTime = null
      metaHasKey: String = null
      metaValue: [JSONValueFilterType] = null
      search: String = null
  
      """FormOrdering"""
      orderBy: [FormOrdering] = null
      slugs: [String] = null
    ): FormConnection
  
    """Form that represents rows of a TableQuestion"""
    rowForm: Form
  
    """The ID of the object"""
    id: ID!
  }
  
  interface Task {
    id: ID!
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    slug: String!
    name: String!
    description: String
    isArchived: Boolean!
    addressGroups: GroupJexl
    controlGroups: GroupJexl
    meta: GenericScalar!
    isMultipleInstance: Boolean!
  }
  
  type TaskConnection {
    """Pagination data for this connection."""
    pageInfo: PageInfo!
  
    """Contains the nodes in this connection."""
    edges: [TaskEdge]!
    totalCount: Int
  }
  
  """A Relay edge containing a `Task` and its cursor."""
  type TaskEdge {
    """The item at the end of the edge"""
    node: Task
  
    """A cursor for use in pagination"""
    cursor: String!
  }
  
  input TaskFilterSetType {
    slug: String
    name: String
    description: String
  
    """"""
    type: Type
    isArchived: Boolean
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    createdBefore: DateTime
    createdAfter: DateTime
    metaHasKey: String
    metaValue: [JSONValueFilterType]
    search: String
  
    """"""
    orderBy: [TaskOrdering]
    invert: Boolean
  }
  
  input TaskOrderSetType {
    meta: String
    attribute: SortableTaskAttributes
    direction: AscDesc
  }
  
  """An enumeration."""
  enum TaskOrdering {
    """Name"""
    NAME_ASC
  
    """Name (descending)"""
    NAME_DESC
  
    """Description"""
    DESCRIPTION_ASC
  
    """Description (descending)"""
    DESCRIPTION_DESC
  
    """Type"""
    TYPE_ASC
  
    """Type (descending)"""
    TYPE_DESC
  
    """Created at"""
    CREATED_AT_ASC
  
    """Created at (descending)"""
    CREATED_AT_DESC
  
    """Modified at"""
    MODIFIED_AT_ASC
  
    """Modified at (descending)"""
    MODIFIED_AT_DESC
  
    """Created by user"""
    CREATED_BY_USER_ASC
  
    """Created by user (descending)"""
    CREATED_BY_USER_DESC
  
    """Created by group"""
    CREATED_BY_GROUP_ASC
  
    """Created by group (descending)"""
    CREATED_BY_GROUP_DESC
  
    """Modified by user"""
    MODIFIED_BY_USER_ASC
  
    """Modified by user (descending)"""
    MODIFIED_BY_USER_DESC
  
    """Modified by group"""
    MODIFIED_BY_GROUP_ASC
  
    """Modified by group (descending)"""
    MODIFIED_BY_GROUP_DESC
  
    """Meta test-key"""
    META_TEST_KEY_ASC
  
    """Meta test-key (descending)"""
    META_TEST_KEY_DESC
  
    """Meta foobar"""
    META_FOOBAR_ASC
  
    """Meta foobar (descending)"""
    META_FOOBAR_DESC
  }
  
  """An enumeration."""
  enum TaskTypeArgument {
    """Task which can simply be marked as completed."""
    SIMPLE
  
    """Task to complete a defined workflow form."""
    COMPLETE_WORKFLOW_FORM
  
    """Task to complete a defined task form."""
    COMPLETE_TASK_FORM
  }
  
  type TextQuestion implements Question & Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    slug: String!
    label: String!
  
    """Required expression is only evaluated when question is not hidden."""
    isRequired: QuestionJexl!
    isHidden: QuestionJexl!
    isArchived: Boolean!
    placeholder: String
    infoText: String
    meta: GenericScalar!
    source: Question
    formatValidators(before: String = null, after: String = null, first: Int = null, last: Int = null): FormatValidatorConnection
    defaultAnswer: StringAnswer
    forms(
      offset: Int = null
      before: String = null
      after: String = null
      first: Int = null
      last: Int = null
      slug: String = null
      name: String = null
      description: String = null
      isPublished: Boolean = null
      isArchived: Boolean = null
      questions: [String] = null
      createdByUser: String = null
      createdByGroup: String = null
      modifiedByUser: String = null
      modifiedByGroup: String = null
  
      """Only return entries created after the given DateTime (Exclusive)"""
      createdBefore: DateTime = null
  
      """
      Only return entries created at or before the given DateTime (Inclusive)
      """
      createdAfter: DateTime = null
      metaHasKey: String = null
      metaValue: [JSONValueFilterType] = null
      search: String = null
  
      """FormOrdering"""
      orderBy: [FormOrdering] = null
      slugs: [String] = null
    ): FormConnection
  
    """The ID of the object"""
    id: ID!
    minLength: Int
    maxLength: Int
  }
  
  type TextareaQuestion implements Question & Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    slug: String!
    label: String!
  
    """Required expression is only evaluated when question is not hidden."""
    isRequired: QuestionJexl!
    isHidden: QuestionJexl!
    isArchived: Boolean!
    placeholder: String
    infoText: String
    meta: GenericScalar!
    source: Question
    formatValidators(before: String = null, after: String = null, first: Int = null, last: Int = null): FormatValidatorConnection
    defaultAnswer: StringAnswer
    forms(
      offset: Int = null
      before: String = null
      after: String = null
      first: Int = null
      last: Int = null
      slug: String = null
      name: String = null
      description: String = null
      isPublished: Boolean = null
      isArchived: Boolean = null
      questions: [String] = null
      createdByUser: String = null
      createdByGroup: String = null
      modifiedByUser: String = null
      modifiedByGroup: String = null
  
      """Only return entries created after the given DateTime (Exclusive)"""
      createdBefore: DateTime = null
  
      """
      Only return entries created at or before the given DateTime (Inclusive)
      """
      createdAfter: DateTime = null
      metaHasKey: String = null
      metaValue: [JSONValueFilterType] = null
      search: String = null
  
      """FormOrdering"""
      orderBy: [FormOrdering] = null
      slugs: [String] = null
    ): FormConnection
  
    """The ID of the object"""
    id: ID!
    minLength: Int
    maxLength: Int
  }
  
  """An enumeration."""
  enum Type {
    """Task which can simply be marked as completed."""
    SIMPLE
  
    """Task to complete a defined workflow form."""
    COMPLETE_WORKFLOW_FORM
  
    """Task to complete a defined task form."""
    COMPLETE_TASK_FORM
  }
  
  """
  Leverages the internal Python implementation of UUID (uuid.UUID) to provide native UUID objects
  in fields, resolvers and input.
  """
  scalar UUID
  
  type ValidationEntry {
    slug: String!
    errorMsg: String!
  }
  
  type ValidationResult {
    id: ID
    isValid: Boolean
    errors: [ValidationEntry]
  }
  
  type WorkItem implements Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
  
    """The ID of the object"""
    id: ID!
  
    """Will be set from Task, if not provided."""
    name: String!
  
    """Will be set from Task, if not provided."""
    description: String
  
    """Time when work item has either been canceled or completed"""
    closedAt: DateTime
    closedByUser: String
    closedByGroup: String
    deadline: DateTime
    task: Task!
    status: CalumaWorkflowWorkItemStatusChoices!
    meta: GenericScalar
  
    """
    Offer work item to be processed by a group of users, such are not committed to process it though.
    """
    addressedGroups: [String!]!
  
    """List of groups this work item is assigned to for controlling."""
    controllingGroups: [String!]!
  
    """Users responsible to undertake given work item."""
    assignedUsers: [String!]!
    case: Case!
  
    """Defines case of a sub-workflow"""
    childCase: Case
    document: Document
    previousWorkItem: WorkItem
    succeedingWorkItems(offset: Int = null, before: String = null, after: String = null, first: Int = null, last: Int = null): WorkItemConnection!
  }
  
  type WorkItemConnection {
    """Pagination data for this connection."""
    pageInfo: PageInfo!
  
    """Contains the nodes in this connection."""
    edges: [WorkItemEdge]!
    totalCount: Int
  }
  
  """A Relay edge containing a `WorkItem` and its cursor."""
  type WorkItemEdge {
    """The item at the end of the edge"""
    node: WorkItem
  
    """A cursor for use in pagination"""
    cursor: String!
  }
  
  input WorkItemFilterSetType {
    """"""
    status: Status
    name: String
    task: ID
    tasks: [String]
    case: ID
    createdAt: DateTime
    closedAt: DateTime
    modifiedAt: DateTime
    deadline: DateTime
    hasDeadline: Boolean
    caseFamily: ID
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    createdBefore: DateTime
    createdAfter: DateTime
    metaHasKey: String
    metaValue: [JSONValueFilterType]
    id: ID
  
    """"""
    orderBy: [WorkItemOrdering]
    addressedGroups: [String]
    controllingGroups: [String]
    assignedUsers: [String]
    documentHasAnswer: [HasAnswerFilterType]
    caseDocumentHasAnswer: [HasAnswerFilterType]
    caseMetaValue: [JSONValueFilterType]
    rootCaseMetaValue: [JSONValueFilterType]
    invert: Boolean
  }
  
  input WorkItemOrderSetType {
    meta: String
    caseMeta: String
    attribute: SortableWorkItemAttributes
    documentAnswer: String
    caseDocumentAnswer: String
    direction: AscDesc
  }
  
  """An enumeration."""
  enum WorkItemOrdering {
    """Status"""
    STATUS_ASC
  
    """Status (descending)"""
    STATUS_DESC
  
    """Deadline"""
    DEADLINE_ASC
  
    """Deadline (descending)"""
    DEADLINE_DESC
  
    """Created at"""
    CREATED_AT_ASC
  
    """Created at (descending)"""
    CREATED_AT_DESC
  
    """Modified at"""
    MODIFIED_AT_ASC
  
    """Modified at (descending)"""
    MODIFIED_AT_DESC
  
    """Created by user"""
    CREATED_BY_USER_ASC
  
    """Created by user (descending)"""
    CREATED_BY_USER_DESC
  
    """Created by group"""
    CREATED_BY_GROUP_ASC
  
    """Created by group (descending)"""
    CREATED_BY_GROUP_DESC
  
    """Modified by user"""
    MODIFIED_BY_USER_ASC
  
    """Modified by user (descending)"""
    MODIFIED_BY_USER_DESC
  
    """Modified by group"""
    MODIFIED_BY_GROUP_ASC
  
    """Modified by group (descending)"""
    MODIFIED_BY_GROUP_DESC
  
    """Meta test-key"""
    META_TEST_KEY_ASC
  
    """Meta test-key (descending)"""
    META_TEST_KEY_DESC
  
    """Meta foobar"""
    META_FOOBAR_ASC
  
    """Meta foobar (descending)"""
    META_FOOBAR_DESC
  }
  
  """An enumeration."""
  enum WorkItemStatusArgument {
    """Work item is ready to be processed."""
    READY
  
    """Work item is done."""
    COMPLETED
  
    """Work item is canceled."""
    CANCELED
  
    """Work item is skipped."""
    SKIPPED
  
    """Work item is suspended."""
    SUSPENDED
  }
  
  type Workflow implements Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    slug: String!
    name: String!
    description: String
    meta: GenericScalar
    isPublished: Boolean!
    isArchived: Boolean!
    startTasks: [Task]!
  
    """Allow workflow to be started with any form"""
    allowAllForms: Boolean!
  
    """List of forms which are allowed to start workflow with"""
    allowForms(offset: Int = null, before: String = null, after: String = null, first: Int = null, last: Int = null): FormConnection!
  
    """The ID of the object"""
    id: ID!
  
    """List of tasks referenced in workflow"""
    tasks: [Task]!
    flows(
      offset: Int = null
      before: String = null
      after: String = null
      first: Int = null
      last: Int = null
      task: ID = null
      filter: [FlowFilterSetType] = null
      createdByUser: String = null
      createdByGroup: String = null
      modifiedByUser: String = null
      modifiedByGroup: String = null
  
      """Only return entries created after the given DateTime (Exclusive)"""
      createdBefore: DateTime = null
  
      """
      Only return entries created at or before the given DateTime (Inclusive)
      """
      createdAfter: DateTime = null
    ): FlowConnection
  }
  
  type WorkflowConnection {
    """Pagination data for this connection."""
    pageInfo: PageInfo!
  
    """Contains the nodes in this connection."""
    edges: [WorkflowEdge]!
    totalCount: Int
  }
  
  """A Relay edge containing a `Workflow` and its cursor."""
  type WorkflowEdge {
    """The item at the end of the edge"""
    node: Workflow
  
    """A cursor for use in pagination"""
    cursor: String!
  }
  
  input WorkflowFilterSetType {
    slug: String
    name: String
    description: String
    isPublished: Boolean
    isArchived: Boolean
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    createdBefore: DateTime
    createdAfter: DateTime
    metaHasKey: String
    metaValue: [JSONValueFilterType]
    search: String
  
    """"""
    orderBy: [WorkflowOrdering]
    invert: Boolean
  }
  
  input WorkflowOrderSetType {
    meta: String
    attribute: SortableWorkflowAttributes
    direction: AscDesc
  }
  
  """An enumeration."""
  enum WorkflowOrdering {
    """Name"""
    NAME_ASC
  
    """Name (descending)"""
    NAME_DESC
  
    """Description"""
    DESCRIPTION_ASC
  
    """Description (descending)"""
    DESCRIPTION_DESC
  
    """Created at"""
    CREATED_AT_ASC
  
    """Created at (descending)"""
    CREATED_AT_DESC
  
    """Modified at"""
    MODIFIED_AT_ASC
  
    """Modified at (descending)"""
    MODIFIED_AT_DESC
  
    """Created by user"""
    CREATED_BY_USER_ASC
  
    """Created by user (descending)"""
    CREATED_BY_USER_DESC
  
    """Created by group"""
    CREATED_BY_GROUP_ASC
  
    """Created by group (descending)"""
    CREATED_BY_GROUP_DESC
  
    """Modified by user"""
    MODIFIED_BY_USER_ASC
  
    """Modified by user (descending)"""
    MODIFIED_BY_USER_DESC
  
    """Modified by group"""
    MODIFIED_BY_GROUP_ASC
  
    """Modified by group (descending)"""
    MODIFIED_BY_GROUP_DESC
  
    """Meta test-key"""
    META_TEST_KEY_ASC
  
    """Meta test-key (descending)"""
    META_TEST_KEY_DESC
  
    """Meta foobar"""
    META_FOOBAR_ASC
  
    """Meta foobar (descending)"""
    META_FOOBAR_DESC
  }
  
  '
---
