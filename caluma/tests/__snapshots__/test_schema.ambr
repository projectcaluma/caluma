# serializer version: 1
# name: test_schema_introspect_direct
  '''
  type ActionButtonQuestion implements Question & Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    slug: String!
    label: String!
  
    """Required expression is only evaluated when question is not hidden."""
    isRequired: QuestionJexl!
    isHidden: QuestionJexl!
    isArchived: Boolean!
    infoText: String
    meta: GenericScalar!
    source: Question
    forms(offset: Int, before: String, after: String, first: Int, last: Int, filter: [FormFilterSetType], order: [FormOrderSetType]): FormConnection
  
    """The ID of the object"""
    id: ID!
    action: ButtonAction!
    color: ButtonColor!
    validateOnEnter: Boolean!
    showValidation: Boolean!
  }
  
  input AddFormQuestionInput {
    form: ID!
    question: ID!
    clientMutationId: String
  }
  
  """Add question at the end of form."""
  type AddFormQuestionPayload {
    form: Form
    clientMutationId: String
  }
  
  input AddWorkflowFlowInput {
    workflow: ID!
    tasks: [ID]!
    next: FlowJexl!
    redoable: FlowJexl
    clientMutationId: String
  }
  
  type AddWorkflowFlowPayload {
    workflow: Workflow
    clientMutationId: String
  }
  
  """Aggregate function for pivot table"""
  enum AggregateFunction {
    VALUE
    SUM
    COUNT
    AVG
    MAX
    MIN
  }
  
  """A cell represents one value in the analytics output."""
  type AnalyticsCell {
    alias: String
    value: String
  }
  
  type AnalyticsField implements Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
  
    """The ID of the object"""
    id: ID!
    alias: String!
    meta: GenericScalar
    dataSource: String!
    table: AnalyticsTable!
    filters: [String]
    function: AggregateFunction
    showOutput: Boolean!
    sort: Int!
  }
  
  type AnalyticsFieldConnection {
    """Pagination data for this connection."""
    pageInfo: PageInfo!
  
    """Contains the nodes in this connection."""
    edges: [AnalyticsFieldEdge]!
    totalCount: Int
  }
  
  """A Relay edge containing a `AnalyticsField` and its cursor."""
  type AnalyticsFieldEdge {
    """The item at the end of the edge"""
    node: AnalyticsField
  
    """A cursor for use in pagination"""
    cursor: String!
  }
  
  input AnalyticsFieldFilterSetType {
    alias: String
    table: ID
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    createdBefore: DateTime
    createdAfter: DateTime
    modifiedBefore: DateTime
    modifiedAfter: DateTime
    metaHasKey: String
    metaValue: [JSONValueFilterType]
    search: String
    slugs: [String]
    invert: Boolean
  }
  
  input AnalyticsFieldOrderSetType {
    meta: String
    attribute: SortableAnalyticsFieldAttributes
    direction: AscDesc
  }
  
  type AnalyticsOutput {
    records(before: String, after: String, first: Int, last: Int): AnalyticsTableContentConnection
    summary: AnalyticsRowConnection
  }
  
  type AnalyticsRowConnection {
    """Pagination data for this connection."""
    pageInfo: PageInfo!
  
    """Contains the nodes in this connection."""
    edges: [AnalyticsRowEdge]!
  }
  
  """A Relay edge containing a `AnalyticsRow` and its cursor."""
  type AnalyticsRowEdge {
    """The item at the end of the edge"""
    node: AnalyticsCell
  
    """A cursor for use in pagination"""
    cursor: String!
  }
  
  type AnalyticsTable implements Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    slug: String!
    meta: JSONString!
    disableVisibilities: Boolean!
    name: String!
    startingObject: StartingObject
    fields(offset: Int, before: String, after: String, first: Int, last: Int): AnalyticsFieldConnection!
  
    """The ID of the object"""
    id: ID!
    availableFields(prefix: String, depth: Int, before: String, after: String, first: Int, last: Int): AvailableFieldConnection
    resultData: AnalyticsOutput
  }
  
  type AnalyticsTableConnection {
    """Pagination data for this connection."""
    pageInfo: PageInfo!
  
    """Contains the nodes in this connection."""
    edges: [AnalyticsTableEdge]!
    totalCount: Int
  }
  
  type AnalyticsTableContentConnection {
    """Pagination data for this connection."""
    pageInfo: PageInfo!
  
    """Contains the nodes in this connection."""
    edges: [AnalyticsTableContentEdge]!
  }
  
  """A Relay edge containing a `AnalyticsTableContent` and its cursor."""
  type AnalyticsTableContentEdge {
    """The item at the end of the edge"""
    node: AnalyticsRowConnection
  
    """A cursor for use in pagination"""
    cursor: String!
  }
  
  """A Relay edge containing a `AnalyticsTable` and its cursor."""
  type AnalyticsTableEdge {
    """The item at the end of the edge"""
    node: AnalyticsTable
  
    """A cursor for use in pagination"""
    cursor: String!
  }
  
  input AnalyticsTableFilterSetType {
    slug: String
    name: String
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    createdBefore: DateTime
    createdAfter: DateTime
    modifiedBefore: DateTime
    modifiedAfter: DateTime
    metaHasKey: String
    metaValue: [JSONValueFilterType]
    search: String
    slugs: [String]
    invert: Boolean
  }
  
  input AnalyticsTableOrderSetType {
    meta: String
    attribute: SortableAnalyticsTableAttributes
    direction: AscDesc
  }
  
  interface Answer {
    id: ID
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    question: Question!
    meta: GenericScalar!
  }
  
  type AnswerConnection {
    """Pagination data for this connection."""
    pageInfo: PageInfo!
  
    """Contains the nodes in this connection."""
    edges: [AnswerEdge]!
    totalCount: Int
  }
  
  """A Relay edge containing a `Answer` and its cursor."""
  type AnswerEdge {
    """The item at the end of the edge"""
    node: Answer
  
    """A cursor for use in pagination"""
    cursor: String!
  }
  
  input AnswerFilterSetType {
    question: ID
    search: String
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    createdBefore: DateTime
    createdAfter: DateTime
    modifiedBefore: DateTime
    modifiedAfter: DateTime
    metaHasKey: String
    metaValue: [JSONValueFilterType]
    questions: [ID]
    visibleInContext: Boolean
    invert: Boolean
  }
  
  enum AnswerHierarchyMode {
    DIRECT
    FAMILY
  }
  
  enum AnswerLookupMode {
    EXACT
    STARTSWITH
    CONTAINS
    ICONTAINS
    INTERSECTS
    ISNULL
    IN
    GTE
    GT
    LTE
    LT
  }
  
  input AnswerOrderSetType {
    meta: String
    attribute: SortableAnswerAttributes
    direction: AscDesc
  }
  
  enum AscDesc {
    ASC
    DESC
  }
  
  """
  Available fields show users what can be selected in an analysis.
  
  The main identifier is the source path, but for display purposes,
  a label (field at current position) and a full_label (including
  parent fields' labels) is available.
  
  Frontends should query sub-fields (via prefix/depth) if is_leaf is
  False. Some fields can be non-leafs as well as values, such as
  dates: Dates can be extracted "as is", or we can extract a
  date part (such as year, quarter, ...) from it.
  """
  type AvailableField implements Node {
    """The ID of the object"""
    id: ID!
    label: String
    fullLabel: String
    sourcePath: String
    isLeaf: Boolean
    isValue: Boolean
    supportedFunctions: [AggregateFunction]
  }
  
  type AvailableFieldConnection {
    """Pagination data for this connection."""
    pageInfo: PageInfo!
  
    """Contains the nodes in this connection."""
    edges: [AvailableFieldEdge]!
    totalCount: Int
  }
  
  """A Relay edge containing a `AvailableField` and its cursor."""
  type AvailableFieldEdge {
    """The item at the end of the edge"""
    node: AvailableField
  
    """A cursor for use in pagination"""
    cursor: String!
  }
  
  """An enumeration."""
  enum ButtonAction {
    COMPLETE
    SKIP
  }
  
  """An enumeration."""
  enum ButtonColor {
    PRIMARY
    SECONDARY
    DEFAULT
  }
  
  type CalculatedFloatQuestion implements Question & Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    slug: String!
    label: String!
  
    """Required expression is only evaluated when question is not hidden."""
    isRequired: QuestionJexl!
    isHidden: QuestionJexl!
    isArchived: Boolean!
    infoText: String
    hintText: String
    meta: GenericScalar!
    source: Question
    forms(offset: Int, before: String, after: String, first: Int, last: Int, filter: [FormFilterSetType], order: [FormOrderSetType]): FormConnection
    calcExpression: String
  
    """The ID of the object"""
    id: ID!
  }
  
  """An enumeration."""
  enum CalumaFormHistoricalAnswerHistoryQuestionTypeChoices {
    """multiple_choice"""
    MULTIPLE_CHOICE
  
    """integer"""
    INTEGER
  
    """float"""
    FLOAT
  
    """date"""
    DATE
  
    """choice"""
    CHOICE
  
    """textarea"""
    TEXTAREA
  
    """text"""
    TEXT
  
    """table"""
    TABLE
  
    """form"""
    FORM
  
    """files"""
    FILES
  
    """dynamic_choice"""
    DYNAMIC_CHOICE
  
    """dynamic_multiple_choice"""
    DYNAMIC_MULTIPLE_CHOICE
  
    """static"""
    STATIC
  
    """calculated_float"""
    CALCULATED_FLOAT
  
    """action_button"""
    ACTION_BUTTON
  }
  
  input CancelCaseInput {
    id: ID!
  
    """Provide extra context for dynamic jexl transforms and events"""
    context: JSONString
    clientMutationId: String
  }
  
  type CancelCasePayload {
    case: Case
    clientMutationId: String
  }
  
  input CancelWorkItemInput {
    id: ID!
  
    """Provide extra context for dynamic jexl transforms and events"""
    context: JSONString
    clientMutationId: String
  }
  
  type CancelWorkItemPayload {
    workItem: WorkItem
    clientMutationId: String
  }
  
  type Case implements Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
  
    """The ID of the object"""
    id: ID!
  
    """Family id which case belongs to."""
    family: Case
  
    """Time when case has either been canceled or completed"""
    closedAt: DateTime
    closedByUser: String
    closedByGroup: String
    workflow: Workflow!
    status: CaseStatus!
    meta: GenericScalar
    document: Document
    workItems(offset: Int, before: String, after: String, first: Int, last: Int, filter: [WorkItemFilterSetType], order: [WorkItemOrderSetType]): WorkItemConnection
    parentWorkItem: WorkItem
    familyWorkItems(offset: Int, before: String, after: String, first: Int, last: Int, filter: [WorkItemFilterSetType], order: [WorkItemOrderSetType]): WorkItemConnection
  }
  
  type CaseConnection {
    """Pagination data for this connection."""
    pageInfo: PageInfo!
  
    """Contains the nodes in this connection."""
    edges: [CaseEdge]!
    totalCount: Int
  }
  
  """A Relay edge containing a `Case` and its cursor."""
  type CaseEdge {
    """The item at the end of the edge"""
    node: Case
  
    """A cursor for use in pagination"""
    cursor: String!
  }
  
  input CaseFilterSetType {
    workflow: ID
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    createdBefore: DateTime
    createdAfter: DateTime
    modifiedBefore: DateTime
    modifiedAfter: DateTime
    metaHasKey: String
    metaValue: [JSONValueFilterType]
    id: ID
    ids: [ID]
    documentForm: String
    documentForms: [String]
    hasAnswer: [HasAnswerFilterType]
    workItemDocumentHasAnswer: [HasAnswerFilterType]
    rootCase: ID
    searchAnswers: [SearchAnswersFilterType]
    status: [CaseStatusArgument]
    excludeChildCases: Boolean
    invert: Boolean
  }
  
  input CaseOrderSetType {
    meta: String
    attribute: SortableCaseAttributes
    documentAnswer: String
    direction: AscDesc
  }
  
  """An enumeration."""
  enum CaseStatus {
    RUNNING
    COMPLETED
    CANCELED
    SUSPENDED
  }
  
  """An enumeration."""
  enum CaseStatusArgument {
    """Case is running and work items need to be completed."""
    RUNNING
  
    """Case is done."""
    COMPLETED
  
    """Case is canceled."""
    CANCELED
  
    """Case is suspended."""
    SUSPENDED
  }
  
  type ChoiceQuestion implements Question & Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    slug: String!
    label: String!
  
    """Required expression is only evaluated when question is not hidden."""
    isRequired: QuestionJexl!
    isHidden: QuestionJexl!
    isArchived: Boolean!
    infoText: String
    hintText: String
    meta: GenericScalar!
    source: Question
    defaultAnswer: StringAnswer
    forms(offset: Int, before: String, after: String, first: Int, last: Int, filter: [FormFilterSetType], order: [FormOrderSetType]): FormConnection
    options(offset: Int, before: String, after: String, first: Int, last: Int, filter: [OptionFilterSetType], order: [OptionOrderSetType]): OptionConnection
  
    """The ID of the object"""
    id: ID!
  }
  
  type CompleteTaskFormTask implements Task & Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    slug: String!
    name: String!
    description: String
    meta: GenericScalar!
    addressGroups: GroupJexl
    controlGroups: GroupJexl
    isArchived: Boolean!
  
    """Time in seconds task may take to be processed."""
    leadTime: Int
    isMultipleInstance: Boolean!
    continueAsync: Boolean
    form: Form!
  
    """The ID of the object"""
    id: ID!
  }
  
  input CompleteWorkItemInput {
    id: ID!
  
    """Provide extra context for dynamic jexl transforms and events"""
    context: JSONString
    clientMutationId: String
  }
  
  type CompleteWorkItemPayload {
    workItem: WorkItem
    clientMutationId: String
  }
  
  type CompleteWorkflowFormTask implements Task & Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    slug: String!
    name: String!
    description: String
    meta: GenericScalar!
    addressGroups: GroupJexl
    controlGroups: GroupJexl
    isArchived: Boolean!
  
    """Time in seconds task may take to be processed."""
    leadTime: Int
    isMultipleInstance: Boolean!
    continueAsync: Boolean
  
    """The ID of the object"""
    id: ID!
  }
  
  input CopyDocumentInput {
    source: ID!
    clientMutationId: String
  }
  
  type CopyDocumentPayload {
    document: Document
    clientMutationId: String
  }
  
  input CopyFormInput {
    slug: String!
    name: String!
    description: String
    source: ID!
    isPublished: Boolean
    clientMutationId: String
  }
  
  type CopyFormPayload {
    form: Form
    clientMutationId: String
  }
  
  input CopyOptionInput {
    slug: String!
    label: String!
    source: ID!
    clientMutationId: String
  }
  
  type CopyOptionPayload {
    option: Option
    clientMutationId: String
  }
  
  input CopyQuestionInput {
    slug: String!
    label: String!
    source: ID!
    clientMutationId: String
  }
  
  type CopyQuestionPayload {
    question: Question
    clientMutationId: String
  }
  
  input CreateWorkItemInput {
    case: ID!
    multipleInstanceTask: ID!
  
    """Will be set from Task, if not provided."""
    name: String
  
    """Will be set from Task, if not provided."""
    description: String
  
    """Users responsible to undertake given work item."""
    assignedUsers: [String]
    addressedGroups: [String]
    controllingGroups: [String]
    deadline: DateTime
    meta: JSONString
  
    """Provide extra context for dynamic jexl transforms and events"""
    context: JSONString
    clientMutationId: String
  }
  
  type CreateWorkItemPayload {
    workItem: WorkItem
    clientMutationId: String
  }
  
  type DataSource {
    info: String
    name: String!
  }
  
  type DataSourceConnection {
    """Pagination data for this connection."""
    pageInfo: PageInfo!
  
    """Contains the nodes in this connection."""
    edges: [DataSourceEdge]!
    totalCount: Int
  }
  
  type DataSourceData {
    label: String!
    slug: String!
  }
  
  type DataSourceDataConnection {
    """Pagination data for this connection."""
    pageInfo: PageInfo!
  
    """Contains the nodes in this connection."""
    edges: [DataSourceDataEdge]!
    totalCount: Int
  }
  
  """A Relay edge containing a `DataSourceData` and its cursor."""
  type DataSourceDataEdge {
    """The item at the end of the edge"""
    node: DataSourceData
  
    """A cursor for use in pagination"""
    cursor: String!
  }
  
  """A Relay edge containing a `DataSource` and its cursor."""
  type DataSourceEdge {
    """The item at the end of the edge"""
    node: DataSource
  
    """A cursor for use in pagination"""
    cursor: String!
  }
  
  """
  The `Date` scalar type represents a Date
  value as specified by
  [iso8601](https://en.wikipedia.org/wiki/ISO_8601).
  """
  scalar Date
  
  type DateAnswer implements Answer & Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
  
    """The ID of the object"""
    id: ID!
    question: Question!
    value: Date
    meta: GenericScalar!
    date: Date
  }
  
  type DateQuestion implements Question & Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    slug: String!
    label: String!
  
    """Required expression is only evaluated when question is not hidden."""
    isRequired: QuestionJexl!
    isHidden: QuestionJexl!
    isArchived: Boolean!
    infoText: String
    hintText: String
    meta: GenericScalar!
    source: Question
    defaultAnswer: DateAnswer
    forms(offset: Int, before: String, after: String, first: Int, last: Int, filter: [FormFilterSetType], order: [FormOrderSetType]): FormConnection
  
    """The ID of the object"""
    id: ID!
  }
  
  """
  The `DateTime` scalar type represents a DateTime
  value as specified by
  [iso8601](https://en.wikipedia.org/wiki/ISO_8601).
  """
  scalar DateTime
  
  """Debugging information for the current query."""
  type DjangoDebug {
    """Executed SQL queries for this API query."""
    sql: [DjangoDebugSQL]
  }
  
  """Represents a single database query made to a Django managed DB."""
  type DjangoDebugSQL {
    """The type of database being used (e.g. postrgesql, mysql, sqlite)."""
    vendor: String!
  
    """The Django database alias (e.g. 'default')."""
    alias: String!
  
    """The actual SQL sent to this database."""
    sql: String
  
    """Duration of this database query in seconds."""
    duration: Float!
  
    """The raw SQL of this query, without params."""
    rawSql: String!
  
    """JSON encoded database query parameters."""
    params: String!
  
    """Start time of this database query."""
    startTime: Float!
  
    """Stop time of this database query."""
    stopTime: Float!
  
    """Whether this database query took more than 10 seconds."""
    isSlow: Boolean!
  
    """Whether this database query was a SELECT."""
    isSelect: Boolean!
  
    """Postgres transaction ID if available."""
    transId: String
  
    """Postgres transaction status if available."""
    transStatus: String
  
    """Postgres isolation level if available."""
    isoLevel: String
  
    """Postgres connection encoding if available."""
    encoding: String
  }
  
  type Document implements Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
  
    """The ID of the object"""
    id: ID!
    form: Form!
  
    """Reference this document has been copied from"""
    source: Document
    meta: GenericScalar
  
    """Reference this document has been copied from"""
    copies(offset: Int, before: String, after: String, first: Int, last: Int): DocumentConnection!
    answers(offset: Int, before: String, after: String, first: Int, last: Int, filter: [AnswerFilterSetType], order: [AnswerOrderSetType]): AnswerConnection
    case: Case
    workItem: WorkItem
    modifiedContentAt: DateTime
    modifiedContentByUser: String
    modifiedContentByGroup: String
  }
  
  type DocumentConnection {
    """Pagination data for this connection."""
    pageInfo: PageInfo!
  
    """Contains the nodes in this connection."""
    edges: [DocumentEdge]!
    totalCount: Int
  }
  
  """A Relay edge containing a `Document` and its cursor."""
  type DocumentEdge {
    """The item at the end of the edge"""
    node: Document
  
    """A cursor for use in pagination"""
    cursor: String!
  }
  
  input DocumentFilterSetType {
    form: ID
    forms: [ID]
    search: String
    id: ID
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    createdBefore: DateTime
    createdAfter: DateTime
    modifiedBefore: DateTime
    modifiedAfter: DateTime
    metaHasKey: String
    metaValue: [JSONValueFilterType]
    rootDocument: ID
    hasAnswer: [HasAnswerFilterType]
    searchAnswers: [SearchAnswersFilterType]
    invert: Boolean
  }
  
  input DocumentOrderSetType {
    meta: String
    answerValue: String
    attribute: SortableDocumentAttributes
    direction: AscDesc
  }
  
  type DocumentValidityConnection {
    """Pagination data for this connection."""
    pageInfo: PageInfo!
  
    """Contains the nodes in this connection."""
    edges: [DocumentValidityEdge]!
    totalCount: Int
  }
  
  """A Relay edge containing a `DocumentValidity` and its cursor."""
  type DocumentValidityEdge {
    """The item at the end of the edge"""
    node: ValidationResult
  
    """A cursor for use in pagination"""
    cursor: String!
  }
  
  type DynamicChoiceQuestion implements Question & DynamicQuestion & Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    slug: String!
    label: String!
  
    """Required expression is only evaluated when question is not hidden."""
    isRequired: QuestionJexl!
    isHidden: QuestionJexl!
    isArchived: Boolean!
    infoText: String
    hintText: String
    meta: GenericScalar!
    source: Question
    forms(offset: Int, before: String, after: String, first: Int, last: Int, filter: [FormFilterSetType], order: [FormOrderSetType]): FormConnection
    options(
      """JSON object passed as context to the data source"""
      context: JSONString
      before: String
      after: String
      first: Int
      last: Int
    ): DataSourceDataConnection
    dataSource: String!
  
    """The ID of the object"""
    id: ID!
  }
  
  type DynamicMultipleChoiceQuestion implements Question & DynamicQuestion & Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    slug: String!
    label: String!
  
    """Required expression is only evaluated when question is not hidden."""
    isRequired: QuestionJexl!
    isHidden: QuestionJexl!
    isArchived: Boolean!
    infoText: String
    hintText: String
    meta: GenericScalar!
    source: Question
    forms(offset: Int, before: String, after: String, first: Int, last: Int, filter: [FormFilterSetType], order: [FormOrderSetType]): FormConnection
    options(
      """JSON object passed as context to the data source"""
      context: JSONString
      before: String
      after: String
      first: Int
      last: Int
    ): DataSourceDataConnection
    dataSource: String!
  
    """The ID of the object"""
    id: ID!
  }
  
  type DynamicOption implements Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
  
    """The ID of the object"""
    id: ID!
    slug: String!
    label: String!
    document: Document!
    question: DynamicQuestion!
  }
  
  type DynamicOptionConnection {
    """Pagination data for this connection."""
    pageInfo: PageInfo!
  
    """Contains the nodes in this connection."""
    edges: [DynamicOptionEdge]!
    totalCount: Int
  }
  
  """A Relay edge containing a `DynamicOption` and its cursor."""
  type DynamicOptionEdge {
    """The item at the end of the edge"""
    node: DynamicOption
  
    """A cursor for use in pagination"""
    cursor: String!
  }
  
  input DynamicOptionFilterSetType {
    question: ID
    document: ID
    invert: Boolean
  }
  
  input DynamicOptionOrderSetType {
    meta: String
    attribute: SortableDynamicOptionAttributes
    direction: AscDesc
  }
  
  interface DynamicQuestion {
    options(
      """JSON object passed as context to the data source"""
      context: JSONString
      before: String
      after: String
      first: Int
      last: Int
    ): DataSourceDataConnection
    dataSource: String!
    hintText: String
  }
  
  type File implements Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
  
    """The ID of the object"""
    id: ID!
    name: String!
    answer: FilesAnswer
    uploadUrl: String
    downloadUrl: String
    metadata: GenericScalar
  }
  
  type FilesAnswer implements Answer & Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
  
    """The ID of the object"""
    id: ID!
    question: Question!
    value: [File]!
    meta: GenericScalar!
  }
  
  type FilesQuestion implements Question & Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    slug: String!
    label: String!
  
    """Required expression is only evaluated when question is not hidden."""
    isRequired: QuestionJexl!
    isHidden: QuestionJexl!
    isArchived: Boolean!
    infoText: String
    hintText: String
    meta: GenericScalar!
    source: Question
    forms(offset: Int, before: String, after: String, first: Int, last: Int, filter: [FormFilterSetType], order: [FormOrderSetType]): FormConnection
  
    """The ID of the object"""
    id: ID!
  }
  
  type FloatAnswer implements Answer & Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
  
    """The ID of the object"""
    id: ID!
    question: Question!
    value: Float
    meta: GenericScalar!
  }
  
  type FloatQuestion implements Question & Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    slug: String!
    label: String!
  
    """Required expression is only evaluated when question is not hidden."""
    isRequired: QuestionJexl!
    isHidden: QuestionJexl!
    isArchived: Boolean!
    placeholder: String
    infoText: String
    hintText: String
    meta: GenericScalar!
    source: Question
    defaultAnswer: FloatAnswer
    forms(offset: Int, before: String, after: String, first: Int, last: Int, filter: [FormFilterSetType], order: [FormOrderSetType]): FormConnection
  
    """The ID of the object"""
    id: ID!
    minValue: Float
    maxValue: Float
  }
  
  type Flow implements Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
  
    """The ID of the object"""
    id: ID!
    next: FlowJexl!
    tasks: [Task]!
  }
  
  type FlowConnection {
    """Pagination data for this connection."""
    pageInfo: PageInfo!
  
    """Contains the nodes in this connection."""
    edges: [FlowEdge]!
    totalCount: Int
  }
  
  """A Relay edge containing a `Flow` and its cursor."""
  type FlowEdge {
    """The item at the end of the edge"""
    node: Flow
  
    """A cursor for use in pagination"""
    cursor: String!
  }
  
  input FlowFilterSetType {
    task: ID
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    createdBefore: DateTime
    createdAfter: DateTime
    modifiedBefore: DateTime
    modifiedAfter: DateTime
    invert: Boolean
  }
  
  """
  Flow jexl represents a jexl expression returning task slugs.
  
  Following transforms can be used:
  * task - return single task
  * tasks - return multiple tasks
  
  Examples:
  * 'task-slug'|task
  * ['task-slug1', 'task-slug2']|tasks
  """
  scalar FlowJexl
  
  input FlowOrderSetType {
    meta: String
    attribute: SortableFlowAttributes
    direction: AscDesc
  }
  
  type Form implements Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    slug: String!
    name: String!
    description: String
    meta: GenericScalar
    isPublished: Boolean!
    isArchived: Boolean!
    questions(offset: Int, before: String, after: String, first: Int, last: Int, filter: [QuestionFilterSetType], order: [QuestionOrderSetType]): QuestionConnection
  
    """Reference this form has been copied from"""
    source: Form
    documents(offset: Int, before: String, after: String, first: Int, last: Int): DocumentConnection!
  
    """The ID of the object"""
    id: ID!
  }
  
  type FormConnection {
    """Pagination data for this connection."""
    pageInfo: PageInfo!
  
    """Contains the nodes in this connection."""
    edges: [FormEdge]!
    totalCount: Int
  }
  
  """A Relay edge containing a `Form` and its cursor."""
  type FormEdge {
    """The item at the end of the edge"""
    node: Form
  
    """A cursor for use in pagination"""
    cursor: String!
  }
  
  input FormFilterSetType {
    name: String
    description: String
    isPublished: Boolean
    isArchived: Boolean
    questions: [String]
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    createdBefore: DateTime
    createdAfter: DateTime
    modifiedBefore: DateTime
    modifiedAfter: DateTime
    metaHasKey: String
    metaValue: [JSONValueFilterType]
    search: String
    slugs: [String]
    invert: Boolean
  }
  
  input FormOrderSetType {
    meta: String
    attribute: SortableFormAttributes
    direction: AscDesc
  }
  
  type FormQuestion implements Question & Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    slug: String!
    label: String!
  
    """Required expression is only evaluated when question is not hidden."""
    isRequired: QuestionJexl!
    isHidden: QuestionJexl!
    isArchived: Boolean!
    infoText: String
    meta: GenericScalar!
    source: Question
    forms(offset: Int, before: String, after: String, first: Int, last: Int, filter: [FormFilterSetType], order: [FormOrderSetType]): FormConnection
  
    """Form referenced in a FormQuestion"""
    subForm: Form
  
    """The ID of the object"""
    id: ID!
  }
  
  type FormatValidator {
    slug: String!
    name: String!
    regex: String!
    errorMsg: String!
  }
  
  type FormatValidatorConnection {
    """Pagination data for this connection."""
    pageInfo: PageInfo!
  
    """Contains the nodes in this connection."""
    edges: [FormatValidatorEdge]!
    totalCount: Int
  }
  
  """A Relay edge containing a `FormatValidator` and its cursor."""
  type FormatValidatorEdge {
    """The item at the end of the edge"""
    node: FormatValidator
  
    """A cursor for use in pagination"""
    cursor: String!
  }
  
  """
  The `GenericScalar` scalar type represents a generic
  GraphQL scalar value that could be:
  String, Boolean, Int, Float, List or Object.
  """
  scalar GenericScalar
  
  """
  Group jexl represents a jexl expression returning group names.
  
  Following transforms can be used:
  * groups - return list of group names
  
  Examples:
  * ['group-name1', 'group-name2']|groups
  """
  scalar GroupJexl
  
  """
  Lookup type to search document structures.
  
  When using lookup `ISNULL`, the provided `value` will be ignored.
  """
  input HasAnswerFilterType {
    question: ID!
    value: GenericScalar
    lookup: AnswerLookupMode
    hierarchy: AnswerHierarchyMode
  }
  
  interface HistoricalAnswer {
    id: ID
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    question: Question!
    meta: GenericScalar!
    historyDate: DateTime!
    historyUserId: String
    historyType: String
  }
  
  type HistoricalAnswerConnection {
    """Pagination data for this connection."""
    pageInfo: PageInfo!
  
    """Contains the nodes in this connection."""
    edges: [HistoricalAnswerEdge]!
    totalCount: Int
  }
  
  """A Relay edge containing a `HistoricalAnswer` and its cursor."""
  type HistoricalAnswerEdge {
    """The item at the end of the edge"""
    node: HistoricalAnswer
  
    """A cursor for use in pagination"""
    cursor: String!
  }
  
  type HistoricalDateAnswer implements HistoricalAnswer & Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    historyQuestionType: CalumaFormHistoricalAnswerHistoryQuestionTypeChoices!
  
    """The ID of the object"""
    id: ID!
    value: Date
    meta: GenericScalar!
    historyUserId: String
    question: Question!
    historyId: UUID!
    historyDate: DateTime!
    historyChangeReason: String
    historyType: String
    date: Date
  }
  
  type HistoricalDocument implements Node {
    historyUserId: String
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
  
    """The ID of the object"""
    id: ID!
    meta: GenericScalar
    form: Form
  
    """Reference this document has been copied from"""
    source: Document
    historyDate: DateTime!
    historyType: String
    historicalAnswers(asOf: DateTime!, before: String, after: String, first: Int, last: Int): HistoricalAnswerConnection
    documentId: UUID
  }
  
  type HistoricalFile implements Node {
    """The ID of the object"""
    id: ID!
    name: String!
    downloadUrl: String
    metadata: GenericScalar
    historicalAnswer: HistoricalFilesAnswer
    historyDate: DateTime!
    historyUserId: String
    historyType: String
  }
  
  type HistoricalFilesAnswer implements HistoricalAnswer & Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    historyQuestionType: CalumaFormHistoricalAnswerHistoryQuestionTypeChoices!
  
    """The ID of the object"""
    id: ID!
    value(asOf: DateTime!): [HistoricalFile]
    meta: GenericScalar!
    historyUserId: String
    question: Question!
    historyId: UUID!
    historyDate: DateTime!
    historyChangeReason: String
    historyType: String
  }
  
  type HistoricalFloatAnswer implements HistoricalAnswer & Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    historyQuestionType: CalumaFormHistoricalAnswerHistoryQuestionTypeChoices!
  
    """The ID of the object"""
    id: ID!
    value: Float
    meta: GenericScalar!
    historyUserId: String
    question: Question!
    historyId: UUID!
    historyDate: DateTime!
    historyChangeReason: String
    historyType: String
  }
  
  type HistoricalIntegerAnswer implements HistoricalAnswer & Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    historyQuestionType: CalumaFormHistoricalAnswerHistoryQuestionTypeChoices!
  
    """The ID of the object"""
    id: ID!
    value: Int
    meta: GenericScalar!
    historyUserId: String
    question: Question!
    historyId: UUID!
    historyDate: DateTime!
    historyChangeReason: String
    historyType: String
  }
  
  type HistoricalListAnswer implements HistoricalAnswer & Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    historyQuestionType: CalumaFormHistoricalAnswerHistoryQuestionTypeChoices!
  
    """The ID of the object"""
    id: ID!
    value: [String]
    meta: GenericScalar!
    historyUserId: String
    question: Question!
    historyId: UUID!
    historyDate: DateTime!
    historyChangeReason: String
    historyType: String
    selectedOptions(before: String, after: String, first: Int, last: Int): SelectedOptionConnection
  }
  
  type HistoricalStringAnswer implements HistoricalAnswer & Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    historyQuestionType: CalumaFormHistoricalAnswerHistoryQuestionTypeChoices!
  
    """The ID of the object"""
    id: ID!
    value: String
    meta: GenericScalar!
    historyUserId: String
    question: Question!
    historyId: UUID!
    historyDate: DateTime!
    historyChangeReason: String
    historyType: String
    selectedOption: SelectedOption
  }
  
  type HistoricalTableAnswer implements HistoricalAnswer & Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    historyQuestionType: CalumaFormHistoricalAnswerHistoryQuestionTypeChoices!
  
    """The ID of the object"""
    id: ID!
    value(asOf: DateTime!): [HistoricalDocument]
    meta: GenericScalar!
    historyUserId: String
    question: Question!
    historyId: UUID!
    historyDate: DateTime!
    historyChangeReason: String
    historyType: String
    document: Document
  }
  
  type IntegerAnswer implements Answer & Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
  
    """The ID of the object"""
    id: ID!
    question: Question!
    value: Int
    meta: GenericScalar!
  }
  
  type IntegerQuestion implements Question & Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    slug: String!
    label: String!
  
    """Required expression is only evaluated when question is not hidden."""
    isRequired: QuestionJexl!
    isHidden: QuestionJexl!
    isArchived: Boolean!
    placeholder: String
    infoText: String
    hintText: String
    meta: GenericScalar!
    source: Question
    defaultAnswer: IntegerAnswer
    forms(offset: Int, before: String, after: String, first: Int, last: Int, filter: [FormFilterSetType], order: [FormOrderSetType]): FormConnection
  
    """The ID of the object"""
    id: ID!
    maxValue: Int
    minValue: Int
  }
  
  enum JSONLookupMode {
    EXACT
    STARTSWITH
    CONTAINS
    ICONTAINS
    IN
    INTERSECTS
    GTE
    GT
    LTE
    LT
  }
  
  """
  Allows use of a JSON String for input / output from the GraphQL schema.
  
  Use of this type is *not recommended* as you lose the benefits of having a defined, static
  schema (one of the key benefits of GraphQL).
  """
  scalar JSONString
  
  input JSONValueFilterType {
    key: String!
    value: GenericScalar!
    lookup: JSONLookupMode
  }
  
  type ListAnswer implements Answer & Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
  
    """The ID of the object"""
    id: ID!
    question: Question!
    value: [String]
    meta: GenericScalar!
    selectedOptions(before: String, after: String, first: Int, last: Int): SelectedOptionConnection
  }
  
  type MultipleChoiceQuestion implements Question & Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    slug: String!
    label: String!
  
    """Required expression is only evaluated when question is not hidden."""
    isRequired: QuestionJexl!
    isHidden: QuestionJexl!
    isArchived: Boolean!
    infoText: String
    hintText: String
    meta: GenericScalar!
    source: Question
    defaultAnswer: ListAnswer
    forms(offset: Int, before: String, after: String, first: Int, last: Int, filter: [FormFilterSetType], order: [FormOrderSetType]): FormConnection
    options(offset: Int, before: String, after: String, first: Int, last: Int, filter: [OptionFilterSetType], order: [OptionOrderSetType]): OptionConnection
    staticContent: String
  
    """The ID of the object"""
    id: ID!
  }
  
  type Mutation {
    saveAnalyticsTable(input: SaveAnalyticsTableInput!): SaveAnalyticsTablePayload
    removeAnalyticsTable(input: RemoveAnalyticsTableInput!): RemoveAnalyticsTablePayload
    saveAnalyticsField(input: SaveAnalyticsFieldInput!): SaveAnalyticsFieldPayload
    removeAnalyticsField(input: RemoveAnalyticsFieldInput!): RemoveAnalyticsFieldPayload
    reorderAnalyticsFields(input: ReorderAnalyticsFieldsInput!): ReorderAnalyticsFieldsPayload
    saveWorkflow(input: SaveWorkflowInput!): SaveWorkflowPayload
    addWorkflowFlow(input: AddWorkflowFlowInput!): AddWorkflowFlowPayload
    removeFlow(input: RemoveFlowInput!): RemoveFlowPayload
    saveSimpleTask(input: SaveSimpleTaskInput!): SaveSimpleTaskPayload
    saveCompleteWorkflowFormTask(input: SaveCompleteWorkflowFormTaskInput!): SaveCompleteWorkflowFormTaskPayload
    saveCompleteTaskFormTask(input: SaveCompleteTaskFormTaskInput!): SaveCompleteTaskFormTaskPayload
    saveCase(input: SaveCaseInput!): SaveCasePayload
    cancelCase(input: CancelCaseInput!): CancelCasePayload
    suspendCase(input: SuspendCaseInput!): SuspendCasePayload
    resumeCase(input: ResumeCaseInput!): ResumeCasePayload
    reopenCase(input: ReopenCaseInput!): ReopenCasePayload
    completeWorkItem(input: CompleteWorkItemInput!): CompleteWorkItemPayload
    skipWorkItem(input: SkipWorkItemInput!): SkipWorkItemPayload
    cancelWorkItem(input: CancelWorkItemInput!): CancelWorkItemPayload
    suspendWorkItem(input: SuspendWorkItemInput!): SuspendWorkItemPayload
    resumeWorkItem(input: ResumeWorkItemInput!): ResumeWorkItemPayload
    redoWorkItem(input: RedoWorkItemInput!): RedoWorkItemPayload
    saveWorkItem(input: SaveWorkItemInput!): SaveWorkItemPayload
    createWorkItem(input: CreateWorkItemInput!): CreateWorkItemPayload
    saveForm(input: SaveFormInput!): SaveFormPayload
    copyForm(input: CopyFormInput!): CopyFormPayload
  
    """Add question at the end of form."""
    addFormQuestion(input: AddFormQuestionInput!): AddFormQuestionPayload
    removeFormQuestion(input: RemoveFormQuestionInput!): RemoveFormQuestionPayload
    reorderFormQuestions(input: ReorderFormQuestionsInput!): ReorderFormQuestionsPayload
    saveOption(input: SaveOptionInput!): SaveOptionPayload
    copyOption(input: CopyOptionInput!): CopyOptionPayload
    copyQuestion(input: CopyQuestionInput!): CopyQuestionPayload
    saveTextQuestion(input: SaveTextQuestionInput!): SaveTextQuestionPayload
    saveTextareaQuestion(input: SaveTextareaQuestionInput!): SaveTextareaQuestionPayload
    saveDateQuestion(input: SaveDateQuestionInput!): SaveDateQuestionPayload
    saveChoiceQuestion(input: SaveChoiceQuestionInput!): SaveChoiceQuestionPayload
    saveMultipleChoiceQuestion(input: SaveMultipleChoiceQuestionInput!): SaveMultipleChoiceQuestionPayload
    saveDynamicChoiceQuestion(input: SaveDynamicChoiceQuestionInput!): SaveDynamicChoiceQuestionPayload
    saveDynamicMultipleChoiceQuestion(input: SaveDynamicMultipleChoiceQuestionInput!): SaveDynamicMultipleChoiceQuestionPayload
    saveFloatQuestion(input: SaveFloatQuestionInput!): SaveFloatQuestionPayload
    saveIntegerQuestion(input: SaveIntegerQuestionInput!): SaveIntegerQuestionPayload
    saveTableQuestion(input: SaveTableQuestionInput!): SaveTableQuestionPayload
    saveFormQuestion(input: SaveFormQuestionInput!): SaveFormQuestionPayload
    saveFilesQuestion(input: SaveFilesQuestionInput!): SaveFilesQuestionPayload
    saveStaticQuestion(input: SaveStaticQuestionInput!): SaveStaticQuestionPayload
    saveCalculatedFloatQuestion(input: SaveCalculatedFloatQuestionInput!): SaveCalculatedFloatQuestionPayload
    saveActionButtonQuestion(input: SaveActionButtonQuestionInput!): SaveActionButtonQuestionPayload
    copyDocument(input: CopyDocumentInput!): CopyDocumentPayload
    saveDocument(input: SaveDocumentInput!): SaveDocumentPayload
    saveDocumentStringAnswer(input: SaveDocumentStringAnswerInput!): SaveDocumentStringAnswerPayload
    saveDocumentIntegerAnswer(input: SaveDocumentIntegerAnswerInput!): SaveDocumentIntegerAnswerPayload
    saveDocumentFloatAnswer(input: SaveDocumentFloatAnswerInput!): SaveDocumentFloatAnswerPayload
    saveDocumentDateAnswer(input: SaveDocumentDateAnswerInput!): SaveDocumentDateAnswerPayload
    saveDocumentListAnswer(input: SaveDocumentListAnswerInput!): SaveDocumentListAnswerPayload
    saveDocumentTableAnswer(input: SaveDocumentTableAnswerInput!): SaveDocumentTableAnswerPayload
    saveDocumentFilesAnswer(input: SaveDocumentFilesAnswerInput!): SaveDocumentFilesAnswerPayload
    saveDefaultStringAnswer(input: SaveDefaultStringAnswerInput!): SaveDefaultStringAnswerPayload
    saveDefaultIntegerAnswer(input: SaveDefaultIntegerAnswerInput!): SaveDefaultIntegerAnswerPayload
    saveDefaultFloatAnswer(input: SaveDefaultFloatAnswerInput!): SaveDefaultFloatAnswerPayload
    saveDefaultDateAnswer(input: SaveDefaultDateAnswerInput!): SaveDefaultDateAnswerPayload
    saveDefaultListAnswer(input: SaveDefaultListAnswerInput!): SaveDefaultListAnswerPayload
    saveDefaultTableAnswer(input: SaveDefaultTableAnswerInput!): SaveDefaultTableAnswerPayload
    removeAnswer(input: RemoveAnswerInput!): RemoveAnswerPayload
    removeDefaultAnswer(input: RemoveDefaultAnswerInput!): RemoveDefaultAnswerPayload
    removeDocument(input: RemoveDocumentInput!): RemoveDocumentPayload
  }
  
  """An object with an ID"""
  interface Node {
    """The ID of the object"""
    id: ID!
  }
  
  type Option implements Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    slug: String!
    label: String!
    isArchived: Boolean!
    meta: GenericScalar
  
    """Reference this option has been copied from"""
    source: Option
  
    """The ID of the object"""
    id: ID!
  }
  
  type OptionConnection {
    """Pagination data for this connection."""
    pageInfo: PageInfo!
  
    """Contains the nodes in this connection."""
    edges: [OptionEdge]!
    totalCount: Int
  }
  
  """A Relay edge containing a `Option` and its cursor."""
  type OptionEdge {
    """The item at the end of the edge"""
    node: Option
  
    """A cursor for use in pagination"""
    cursor: String!
  }
  
  input OptionFilterSetType {
    slug: String
    label: String
    isArchived: Boolean
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    createdBefore: DateTime
    createdAfter: DateTime
    modifiedBefore: DateTime
    modifiedAfter: DateTime
    metaHasKey: String
    metaValue: [JSONValueFilterType]
    search: String
    invert: Boolean
  }
  
  input OptionOrderSetType {
    meta: String
    attribute: SortableOptionAttributes
    direction: AscDesc
  }
  
  """
  The Relay compliant `PageInfo` type, containing data necessary to paginate this connection.
  """
  type PageInfo {
    """When paginating forwards, are there more items?"""
    hasNextPage: Boolean!
  
    """When paginating backwards, are there more items?"""
    hasPreviousPage: Boolean!
  
    """When paginating backwards, the cursor to continue."""
    startCursor: String
  
    """When paginating forwards, the cursor to continue."""
    endCursor: String
  }
  
  type Query {
    documentAsOf(id: ID!, asOf: DateTime!): HistoricalDocument
    allAnalyticsTables(offset: Int, before: String, after: String, first: Int, last: Int, filter: [AnalyticsTableFilterSetType], order: [AnalyticsTableOrderSetType]): AnalyticsTableConnection
    analyticsTable(slug: String!): AnalyticsTable
    allAnalyticsFields(offset: Int, before: String, after: String, first: Int, last: Int, filter: [AnalyticsFieldFilterSetType], order: [AnalyticsFieldOrderSetType]): AnalyticsFieldConnection
    allDataSources(before: String, after: String, first: Int, last: Int): DataSourceConnection
    dataSource(
      name: String!
  
      """Slug of the question passed as context to the data source"""
      question: String
  
      """JSON object passed as context to the data source"""
      context: JSONString
      before: String
      after: String
      first: Int
      last: Int
    ): DataSourceDataConnection
    allWorkflows(offset: Int, before: String, after: String, first: Int, last: Int, filter: [WorkflowFilterSetType], order: [WorkflowOrderSetType]): WorkflowConnection
    allTasks(offset: Int, before: String, after: String, first: Int, last: Int, filter: [TaskFilterSetType], order: [TaskOrderSetType]): TaskConnection
    allCases(offset: Int, before: String, after: String, first: Int, last: Int, filter: [CaseFilterSetType], order: [CaseOrderSetType]): CaseConnection
    allWorkItems(offset: Int, before: String, after: String, first: Int, last: Int, filter: [WorkItemFilterSetType], order: [WorkItemOrderSetType]): WorkItemConnection
    allForms(offset: Int, before: String, after: String, first: Int, last: Int, filter: [FormFilterSetType], order: [FormOrderSetType]): FormConnection
    allQuestions(offset: Int, before: String, after: String, first: Int, last: Int, filter: [QuestionFilterSetType], order: [QuestionOrderSetType]): QuestionConnection
    allDocuments(offset: Int, before: String, after: String, first: Int, last: Int, filter: [DocumentFilterSetType], order: [DocumentOrderSetType]): DocumentConnection
    allFormatValidators(before: String, after: String, first: Int, last: Int): FormatValidatorConnection
    allUsedDynamicOptions(offset: Int, before: String, after: String, first: Int, last: Int, filter: [DynamicOptionFilterSetType], order: [DynamicOptionOrderSetType]): DynamicOptionConnection
    documentValidity(id: ID!, dataSourceContext: JSONString, before: String, after: String, first: Int, last: Int): DocumentValidityConnection
    node(
      """The ID of the object"""
      id: ID!
    ): Node
    _debug: DjangoDebug
  }
  
  interface Question {
    id: ID!
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    slug: String!
    label: String!
    infoText: String
  
    """Required expression is only evaluated when question is not hidden."""
    isRequired: QuestionJexl!
    isHidden: QuestionJexl!
    isArchived: Boolean!
    meta: GenericScalar!
    forms(offset: Int, before: String, after: String, first: Int, last: Int, filter: [FormFilterSetType], order: [FormOrderSetType]): FormConnection
    source: Question
  }
  
  type QuestionConnection {
    """Pagination data for this connection."""
    pageInfo: PageInfo!
  
    """Contains the nodes in this connection."""
    edges: [QuestionEdge]!
    totalCount: Int
  }
  
  """A Relay edge containing a `Question` and its cursor."""
  type QuestionEdge {
    """The item at the end of the edge"""
    node: Question
  
    """A cursor for use in pagination"""
    cursor: String!
  }
  
  input QuestionFilterSetType {
    label: String
    isRequired: String
    isHidden: String
    isArchived: Boolean
    subForm: ID
    rowForm: ID
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    createdBefore: DateTime
    createdAfter: DateTime
    modifiedBefore: DateTime
    modifiedAfter: DateTime
    metaHasKey: String
    metaValue: [JSONValueFilterType]
    excludeForms: [ID]
    search: String
    slugs: [String]
    visibleInDocument: ID
    invert: Boolean
  }
  
  """
  Question jexl expression returning boolean.
  
  Following transforms can be used:
  * `answer`: get answer of document by question slug
  * `mapby`: map list by key. Helpful to work with table answers
    whereas an answer is a list of dicts.
  * `stringify`: JSON stringify
  * `flatten`: flatten list values
  * `min`: get min value in a list
  * `max`: get max value in a list
  * `sum`: sum of a list
  * `round`: round the value
  * `ceil`: round value up
  * `floor`: round value down
  * `debug`: debug output
  
  Following binary operators can be used:
  * `intersects`: list intersection operator
  
  Following context is available:
  * `form`: legacy property pointing to the root form (this should not be used anymore)
  * `info.form`: slug of the form this question is attached to
  * `info.formMeta`: meta property of the form this question is attached to
  * `info.parent.form`: parent form slug
  * `info.parent.formMeta`: parent form meta property
  * `info.root.form`: top level form slug
  * `info.root.formMeta`: top level form meta property
  
  Examples:
  * 'answer' == 'question-slug'|answer
  * 'answer' in 'list-question-slug'|answer
  * 'answer' in 'table-question-slug'|answer|mapby('column-question')
  * 'answer' in 'table-question-slug'|answer|mapby('multiple-choice-question')|flatten
  * 'form-slug' == info.form
  """
  scalar QuestionJexl
  
  input QuestionOrderSetType {
    meta: String
    attribute: SortableQuestionAttributes
    direction: AscDesc
  }
  
  input RedoWorkItemInput {
    id: ID!
  
    """Provide extra context for dynamic jexl transforms and events"""
    context: JSONString
    clientMutationId: String
  }
  
  type RedoWorkItemPayload {
    workItem: WorkItem
    clientMutationId: String
  }
  
  input RemoveAnalyticsFieldInput {
    id: ID!
    clientMutationId: String
  }
  
  type RemoveAnalyticsFieldPayload {
    analyticsField: AnalyticsField
    clientMutationId: String
  }
  
  input RemoveAnalyticsTableInput {
    slug: ID!
    clientMutationId: String
  }
  
  type RemoveAnalyticsTablePayload {
    analyticsTable: AnalyticsTable
    clientMutationId: String
  }
  
  input RemoveAnswerInput {
    answer: ID!
    clientMutationId: String
  }
  
  type RemoveAnswerPayload {
    answer: Answer
    clientMutationId: String
  }
  
  input RemoveDefaultAnswerInput {
    question: ID!
    clientMutationId: String
  }
  
  type RemoveDefaultAnswerPayload {
    question: Question
    clientMutationId: String
  }
  
  input RemoveDocumentInput {
    document: ID!
    clientMutationId: String
  }
  
  type RemoveDocumentPayload {
    document: Document
    clientMutationId: String
  }
  
  input RemoveFlowInput {
    flow: ID!
    clientMutationId: String
  }
  
  type RemoveFlowPayload {
    flow: Flow
    clientMutationId: String
  }
  
  input RemoveFormQuestionInput {
    form: ID!
    question: ID!
    clientMutationId: String
  }
  
  type RemoveFormQuestionPayload {
    form: Form
    clientMutationId: String
  }
  
  input ReopenCaseInput {
    id: ID!
  
    """List of work item ids to be readied when the case is reopened"""
    workItems: [ID]!
  
    """Provide extra context for dynamic jexl transforms and events"""
    context: JSONString
    clientMutationId: String
  }
  
  type ReopenCasePayload {
    case: Case
    clientMutationId: String
  }
  
  input ReorderAnalyticsFieldsInput {
    table: ID!
    fields: [ID]!
    clientMutationId: String
  }
  
  type ReorderAnalyticsFieldsPayload {
    analyticsTable: AnalyticsTable
    clientMutationId: String
  }
  
  input ReorderFormQuestionsInput {
    form: ID!
    questions: [ID]!
    clientMutationId: String
  }
  
  type ReorderFormQuestionsPayload {
    form: Form
    clientMutationId: String
  }
  
  input ResumeCaseInput {
    id: ID!
  
    """Provide extra context for dynamic jexl transforms and events"""
    context: JSONString
    clientMutationId: String
  }
  
  type ResumeCasePayload {
    case: Case
    clientMutationId: String
  }
  
  input ResumeWorkItemInput {
    id: ID!
  
    """Provide extra context for dynamic jexl transforms and events"""
    context: JSONString
    clientMutationId: String
  }
  
  type ResumeWorkItemPayload {
    workItem: WorkItem
    clientMutationId: String
  }
  
  input SaveActionButtonQuestionInput {
    label: String!
    slug: String!
    infoText: String
    isHidden: QuestionJexl
    meta: JSONString
    isArchived: Boolean
    action: ButtonAction!
    color: ButtonColor!
    validateOnEnter: Boolean!
    showValidation: Boolean!
    clientMutationId: String
  }
  
  type SaveActionButtonQuestionPayload {
    question: Question
    clientMutationId: String
  }
  
  input SaveAnalyticsFieldInput {
    id: ID
    alias: String!
    table: ID!
    dataSource: String!
    filters: [String]
    showOutput: Boolean
    meta: JSONString
    function: AggregateFunction!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    clientMutationId: String
  }
  
  type SaveAnalyticsFieldPayload {
    analyticsField: AnalyticsField
    clientMutationId: String
  }
  
  input SaveAnalyticsTableInput {
    slug: String!
    name: String!
    startingObject: StartingObject!
    disableVisibilities: Boolean
    meta: JSONString
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    clientMutationId: String
  }
  
  type SaveAnalyticsTablePayload {
    analyticsTable: AnalyticsTable
    clientMutationId: String
  }
  
  input SaveCalculatedFloatQuestionInput {
    slug: String!
    label: String!
    infoText: String
    isRequired: QuestionJexl
    isHidden: QuestionJexl
    meta: JSONString
    isArchived: Boolean
    calcExpression: QuestionJexl
    hintText: String
    clientMutationId: String
  }
  
  type SaveCalculatedFloatQuestionPayload {
    question: Question
    clientMutationId: String
  }
  
  input SaveCaseInput {
    id: String
    workflow: ID!
    meta: JSONString
    parentWorkItem: ID
    form: ID
  
    """Provide extra context for dynamic jexl transforms and events"""
    context: JSONString
    clientMutationId: String
  }
  
  type SaveCasePayload {
    case: Case
    clientMutationId: String
  }
  
  input SaveChoiceQuestionInput {
    slug: String!
    label: String!
    infoText: String
    isRequired: QuestionJexl
    isHidden: QuestionJexl
    meta: JSONString
    isArchived: Boolean
    options: [ID]!
    hintText: String
    clientMutationId: String
  }
  
  type SaveChoiceQuestionPayload {
    question: Question
    clientMutationId: String
  }
  
  input SaveCompleteTaskFormTaskInput {
    slug: String!
    name: String!
    description: String
    meta: JSONString
  
    """
    Group jexl returning what group(s) derived work items will be addressed to.
    """
    addressGroups: GroupJexl
  
    """
    Group jexl returning what group(s) derived work items will be assigned to for controlling.
    """
    controlGroups: GroupJexl
    isArchived: Boolean
  
    """Time in seconds task may take to be processed."""
    leadTime: Int
  
    """
    Allows creating multiple work items for this task using the `CreateWorkItem` mutation. If true, one work item will be created for each entry in `address_groups`.
    """
    isMultipleInstance: Boolean
  
    """
    Whether to continue the flow if the multiple instance work item has ready siblings
    """
    continueAsync: Boolean
    form: ID!
    clientMutationId: String
  }
  
  type SaveCompleteTaskFormTaskPayload {
    task: Task
    clientMutationId: String
  }
  
  input SaveCompleteWorkflowFormTaskInput {
    slug: String!
    name: String!
    description: String
    meta: JSONString
  
    """
    Group jexl returning what group(s) derived work items will be addressed to.
    """
    addressGroups: GroupJexl
  
    """
    Group jexl returning what group(s) derived work items will be assigned to for controlling.
    """
    controlGroups: GroupJexl
    isArchived: Boolean
  
    """Time in seconds task may take to be processed."""
    leadTime: Int
  
    """
    Allows creating multiple work items for this task using the `CreateWorkItem` mutation. If true, one work item will be created for each entry in `address_groups`.
    """
    isMultipleInstance: Boolean
  
    """
    Whether to continue the flow if the multiple instance work item has ready siblings
    """
    continueAsync: Boolean
    clientMutationId: String
  }
  
  type SaveCompleteWorkflowFormTaskPayload {
    task: Task
    clientMutationId: String
  }
  
  input SaveDateQuestionInput {
    slug: String!
    label: String!
    infoText: String
    isRequired: QuestionJexl
    isHidden: QuestionJexl
    meta: JSONString
    isArchived: Boolean
    hintText: String
    clientMutationId: String
  }
  
  type SaveDateQuestionPayload {
    question: Question
    clientMutationId: String
  }
  
  input SaveDefaultDateAnswerInput {
    question: ID!
    meta: JSONString
    value: Date
    clientMutationId: String
  }
  
  type SaveDefaultDateAnswerPayload {
    answer: Answer
    clientMutationId: String
  }
  
  input SaveDefaultFloatAnswerInput {
    question: ID!
    meta: JSONString
    value: Float
    clientMutationId: String
  }
  
  type SaveDefaultFloatAnswerPayload {
    answer: Answer
    clientMutationId: String
  }
  
  input SaveDefaultIntegerAnswerInput {
    question: ID!
    meta: JSONString
    value: Int
    clientMutationId: String
  }
  
  type SaveDefaultIntegerAnswerPayload {
    answer: Answer
    clientMutationId: String
  }
  
  input SaveDefaultListAnswerInput {
    question: ID!
    meta: JSONString
    value: [String]
    clientMutationId: String
  }
  
  type SaveDefaultListAnswerPayload {
    answer: Answer
    clientMutationId: String
  }
  
  input SaveDefaultStringAnswerInput {
    question: ID!
    meta: JSONString
    value: String
    clientMutationId: String
  }
  
  type SaveDefaultStringAnswerPayload {
    answer: Answer
    clientMutationId: String
  }
  
  input SaveDefaultTableAnswerInput {
    question: ID!
    meta: JSONString
  
    """List of document IDs representing the rows in the table."""
    value: [ID]
    clientMutationId: String
  }
  
  type SaveDefaultTableAnswerPayload {
    answer: Answer
    clientMutationId: String
  }
  
  input SaveDocumentDateAnswerInput {
    question: ID!
    document: ID!
    meta: JSONString
    value: Date
  
    """JSON object passed as context to the data source of dynamic questions"""
    dataSourceContext: JSONString
    clientMutationId: String
  }
  
  type SaveDocumentDateAnswerPayload {
    answer: Answer
    clientMutationId: String
  }
  
  input SaveDocumentFilesAnswerInput {
    value: [SaveFile]
    question: ID!
    document: ID!
    meta: JSONString
  
    """JSON object passed as context to the data source of dynamic questions"""
    dataSourceContext: JSONString
    clientMutationId: String
  }
  
  type SaveDocumentFilesAnswerPayload {
    answer: Answer
    clientMutationId: String
  }
  
  input SaveDocumentFloatAnswerInput {
    question: ID!
    document: ID!
    meta: JSONString
    value: Float
  
    """JSON object passed as context to the data source of dynamic questions"""
    dataSourceContext: JSONString
    clientMutationId: String
  }
  
  type SaveDocumentFloatAnswerPayload {
    answer: Answer
    clientMutationId: String
  }
  
  input SaveDocumentInput {
    id: String
    form: ID!
    meta: JSONString
    clientMutationId: String
  }
  
  input SaveDocumentIntegerAnswerInput {
    question: ID!
    document: ID!
    meta: JSONString
    value: Int
  
    """JSON object passed as context to the data source of dynamic questions"""
    dataSourceContext: JSONString
    clientMutationId: String
  }
  
  type SaveDocumentIntegerAnswerPayload {
    answer: Answer
    clientMutationId: String
  }
  
  input SaveDocumentListAnswerInput {
    question: ID!
    document: ID!
    meta: JSONString
    value: [String]
  
    """JSON object passed as context to the data source of dynamic questions"""
    dataSourceContext: JSONString
    clientMutationId: String
  }
  
  type SaveDocumentListAnswerPayload {
    answer: Answer
    clientMutationId: String
  }
  
  type SaveDocumentPayload {
    document: Document
    clientMutationId: String
  }
  
  input SaveDocumentStringAnswerInput {
    question: ID!
    document: ID!
    meta: JSONString
    value: String
  
    """JSON object passed as context to the data source of dynamic questions"""
    dataSourceContext: JSONString
    clientMutationId: String
  }
  
  type SaveDocumentStringAnswerPayload {
    answer: Answer
    clientMutationId: String
  }
  
  input SaveDocumentTableAnswerInput {
    question: ID!
    document: ID!
    meta: JSONString
  
    """List of document IDs representing the rows in the table."""
    value: [ID]
  
    """JSON object passed as context to the data source of dynamic questions"""
    dataSourceContext: JSONString
    clientMutationId: String
  }
  
  type SaveDocumentTableAnswerPayload {
    answer: Answer
    clientMutationId: String
  }
  
  input SaveDynamicChoiceQuestionInput {
    slug: String!
    label: String!
    infoText: String
    isRequired: QuestionJexl
    isHidden: QuestionJexl
    meta: JSONString
    isArchived: Boolean
    dataSource: String!
    hintText: String
    clientMutationId: String
  }
  
  type SaveDynamicChoiceQuestionPayload {
    question: Question
    clientMutationId: String
  }
  
  input SaveDynamicMultipleChoiceQuestionInput {
    slug: String!
    label: String!
    infoText: String
    isRequired: QuestionJexl
    isHidden: QuestionJexl
    meta: JSONString
    isArchived: Boolean
    dataSource: String!
    hintText: String
    clientMutationId: String
  }
  
  type SaveDynamicMultipleChoiceQuestionPayload {
    question: Question
    clientMutationId: String
  }
  
  input SaveFile {
    id: String
    name: String
  }
  
  input SaveFilesQuestionInput {
    slug: String!
    label: String!
    infoText: String
    isRequired: QuestionJexl
    isHidden: QuestionJexl
    meta: JSONString
    isArchived: Boolean
    hintText: String
    clientMutationId: String
  }
  
  type SaveFilesQuestionPayload {
    question: Question
    clientMutationId: String
  }
  
  input SaveFloatQuestionInput {
    slug: String!
    label: String!
    infoText: String
    isRequired: QuestionJexl
    isHidden: QuestionJexl
    meta: JSONString
    isArchived: Boolean
    minValue: Float
    maxValue: Float
    placeholder: String
    hintText: String
    clientMutationId: String
  }
  
  type SaveFloatQuestionPayload {
    question: Question
    clientMutationId: String
  }
  
  input SaveFormInput {
    slug: String!
    name: String!
    description: String
    meta: JSONString
    isArchived: Boolean
    isPublished: Boolean
    clientMutationId: String
  }
  
  type SaveFormPayload {
    form: Form
    clientMutationId: String
  }
  
  input SaveFormQuestionInput {
    slug: String!
    label: String!
    infoText: String
    isRequired: QuestionJexl
    isHidden: QuestionJexl
    meta: JSONString
    isArchived: Boolean
    subForm: ID!
    clientMutationId: String
  }
  
  type SaveFormQuestionPayload {
    question: Question
    clientMutationId: String
  }
  
  input SaveIntegerQuestionInput {
    slug: String!
    label: String!
    infoText: String
    isRequired: QuestionJexl
    isHidden: QuestionJexl
    meta: JSONString
    isArchived: Boolean
    minValue: Int
    maxValue: Int
    placeholder: String
    hintText: String
    clientMutationId: String
  }
  
  type SaveIntegerQuestionPayload {
    question: Question
    clientMutationId: String
  }
  
  input SaveMultipleChoiceQuestionInput {
    slug: String!
    label: String!
    infoText: String
    isRequired: QuestionJexl
    isHidden: QuestionJexl
    meta: JSONString
    isArchived: Boolean
    options: [ID]!
    hintText: String
    clientMutationId: String
  }
  
  type SaveMultipleChoiceQuestionPayload {
    question: Question
    clientMutationId: String
  }
  
  input SaveOptionInput {
    slug: String!
    label: String!
    isArchived: Boolean
    meta: JSONString
    clientMutationId: String
  }
  
  type SaveOptionPayload {
    option: Option
    clientMutationId: String
  }
  
  input SaveSimpleTaskInput {
    slug: String!
    name: String!
    description: String
    meta: JSONString
  
    """
    Group jexl returning what group(s) derived work items will be addressed to.
    """
    addressGroups: GroupJexl
  
    """
    Group jexl returning what group(s) derived work items will be assigned to for controlling.
    """
    controlGroups: GroupJexl
    isArchived: Boolean
  
    """Time in seconds task may take to be processed."""
    leadTime: Int
  
    """
    Allows creating multiple work items for this task using the `CreateWorkItem` mutation. If true, one work item will be created for each entry in `address_groups`.
    """
    isMultipleInstance: Boolean
  
    """
    Whether to continue the flow if the multiple instance work item has ready siblings
    """
    continueAsync: Boolean
    clientMutationId: String
  }
  
  type SaveSimpleTaskPayload {
    task: Task
    clientMutationId: String
  }
  
  input SaveStaticQuestionInput {
    label: String!
    slug: String!
    infoText: String
    isHidden: QuestionJexl
    meta: JSONString
    isArchived: Boolean
    staticContent: String
    clientMutationId: String
  }
  
  type SaveStaticQuestionPayload {
    question: Question
    clientMutationId: String
  }
  
  input SaveTableQuestionInput {
    slug: String!
    label: String!
    infoText: String
    isRequired: QuestionJexl
    isHidden: QuestionJexl
    meta: JSONString
    isArchived: Boolean
  
    """Form that represents rows of a TableQuestion"""
    rowForm: ID!
    hintText: String
    clientMutationId: String
  }
  
  type SaveTableQuestionPayload {
    question: Question
    clientMutationId: String
  }
  
  input SaveTextQuestionInput {
    slug: String!
    label: String!
    infoText: String
    isRequired: QuestionJexl
    isHidden: QuestionJexl
    meta: JSONString
    isArchived: Boolean
    minLength: Int
    maxLength: Int
    placeholder: String
    hintText: String
    formatValidators: [String]
    clientMutationId: String
  }
  
  type SaveTextQuestionPayload {
    question: Question
    clientMutationId: String
  }
  
  input SaveTextareaQuestionInput {
    slug: String!
    label: String!
    infoText: String
    isRequired: QuestionJexl
    isHidden: QuestionJexl
    meta: JSONString
    isArchived: Boolean
    minLength: Int
    maxLength: Int
    placeholder: String
    hintText: String
    formatValidators: [String]
    clientMutationId: String
  }
  
  type SaveTextareaQuestionPayload {
    question: Question
    clientMutationId: String
  }
  
  input SaveWorkItemInput {
    workItem: ID!
  
    """Will be set from Task, if not provided."""
    name: String
  
    """Will be set from Task, if not provided."""
    description: String
  
    """Users responsible to undertake given work item."""
    assignedUsers: [String]
    deadline: DateTime
    meta: JSONString
  
    """Provide extra context for dynamic jexl transforms and events"""
    context: JSONString
    clientMutationId: String
  }
  
  type SaveWorkItemPayload {
    workItem: WorkItem
    clientMutationId: String
  }
  
  input SaveWorkflowInput {
    slug: String!
    name: String!
    description: String
    meta: JSONString
  
    """Starting task(s) of the workflow."""
    startTasks: [ID]!
  
    """Allow workflow to be started with any form"""
    allowAllForms: Boolean
  
    """List of forms which are allowed to start workflow with"""
    allowForms: [ID]
    isArchived: Boolean
    isPublished: Boolean
    clientMutationId: String
  }
  
  type SaveWorkflowPayload {
    workflow: Workflow
    clientMutationId: String
  }
  
  """
  Lookup type to search in answers.
  
  You may pass in a list of question slugs and/or a list of form slugs to define
  which answers to search. If you pass in one or more forms, answers to the
  questions in that form will be searched. If you pass in one or more question
  slug, the corresponding answers are searched. If you pass both, a superset
  of both is searched (ie. they do not limit each other).
  """
  input SearchAnswersFilterType {
    questions: [ID]
    forms: [ID]
    value: GenericScalar!
    lookup: SearchLookupMode
  }
  
  enum SearchLookupMode {
    STARTSWITH
    CONTAINS
    TEXT
  }
  
  type SelectedOption {
    label: String!
    slug: String!
  }
  
  type SelectedOptionConnection {
    """Pagination data for this connection."""
    pageInfo: PageInfo!
  
    """Contains the nodes in this connection."""
    edges: [SelectedOptionEdge]!
    totalCount: Int
  }
  
  """A Relay edge containing a `SelectedOption` and its cursor."""
  type SelectedOptionEdge {
    """The item at the end of the edge"""
    node: SelectedOption
  
    """A cursor for use in pagination"""
    cursor: String!
  }
  
  type SimpleTask implements Task & Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    slug: String!
    name: String!
    description: String
    meta: GenericScalar!
    addressGroups: GroupJexl
    controlGroups: GroupJexl
    isArchived: Boolean!
  
    """Time in seconds task may take to be processed."""
    leadTime: Int
    isMultipleInstance: Boolean!
    continueAsync: Boolean
  
    """The ID of the object"""
    id: ID!
  }
  
  input SkipWorkItemInput {
    id: ID!
  
    """Provide extra context for dynamic jexl transforms and events"""
    context: JSONString
    clientMutationId: String
  }
  
  type SkipWorkItemPayload {
    workItem: WorkItem
    clientMutationId: String
  }
  
  enum SortableAnalyticsFieldAttributes {
    CREATED_AT
    MODIFIED_AT
    ALIAS
  }
  
  enum SortableAnalyticsTableAttributes {
    CREATED_AT
    MODIFIED_AT
    SLUG
    NAME
  }
  
  enum SortableAnswerAttributes {
    CREATED_AT
    MODIFIED_AT
    QUESTION
    VALUE
    DATE
  }
  
  enum SortableCaseAttributes {
    CREATED_AT
    MODIFIED_AT
    STATUS
    DOCUMENT__FORM__NAME
  }
  
  enum SortableDocumentAttributes {
    CREATED_AT
    MODIFIED_AT
    FORM
  }
  
  enum SortableDynamicOptionAttributes {
    CREATED_AT
    MODIFIED_AT
    SLUG
    LABEL
    QUESTION
  }
  
  enum SortableFlowAttributes {
    CREATED_AT
    MODIFIED_AT
    TASK
  }
  
  enum SortableFormAttributes {
    CREATED_AT
    MODIFIED_AT
    SLUG
    NAME
    DESCRIPTION
    IS_PUBLISHED
    IS_ARCHIVED
  }
  
  enum SortableOptionAttributes {
    CREATED_AT
    MODIFIED_AT
    SLUG
    LABEL
    IS_ARCHIVED
  }
  
  enum SortableQuestionAttributes {
    CREATED_AT
    MODIFIED_AT
    SLUG
    LABEL
    TYPE
    IS_REQUIRED
    IS_HIDDEN
    IS_ARCHIVED
    PLACEHOLDER
    INFO_TEXT
    HINT_TEXT
    CALC_EXPRESSION
  }
  
  enum SortableTaskAttributes {
    CREATED_AT
    MODIFIED_AT
    LEAD_TIME
    TYPE
    DESCRIPTION
    IS_ARCHIVED
    NAME
    SLUG
  }
  
  enum SortableWorkItemAttributes {
    CREATED_AT
    MODIFIED_AT
    CLOSED_AT
    DESCRIPTION
    NAME
    DEADLINE
    STATUS
    SLUG
    CASE__DOCUMENT__FORM__NAME
  }
  
  enum SortableWorkflowAttributes {
    CREATED_AT
    MODIFIED_AT
    ALLOW_ALL_FORMS
    DESCRIPTION
    IS_ARCHIVED
    IS_PUBLISHED
    NAME
    SLUG
  }
  
  """An enumeration."""
  enum StartingObject {
    CASES
    WORK_ITEMS
    DOCUMENTS
  }
  
  type StaticQuestion implements Question & Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    slug: String!
    label: String!
  
    """
    Required expression is only evaluated when question is not hidden. This should not be used for `StaticQuestion`, because it can never be satisfied.
    """
    isRequired: QuestionJexl!
    isHidden: QuestionJexl!
    isArchived: Boolean!
    infoText: String
    meta: GenericScalar!
    source: Question
    forms(offset: Int, before: String, after: String, first: Int, last: Int, filter: [FormFilterSetType], order: [FormOrderSetType]): FormConnection
    staticContent: String
    dataSource: String
  
    """The ID of the object"""
    id: ID!
  }
  
  """An enumeration."""
  enum Status {
    """Work item is ready to be processed."""
    READY
  
    """Work item is done."""
    COMPLETED
  
    """Work item is canceled."""
    CANCELED
  
    """Work item is skipped."""
    SKIPPED
  
    """Work item is suspended."""
    SUSPENDED
  
    """Work item has been marked for redo."""
    REDO
  }
  
  type StringAnswer implements Answer & Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
  
    """The ID of the object"""
    id: ID!
    question: Question!
    value: String
    meta: GenericScalar!
    selectedOption: SelectedOption
  }
  
  input SuspendCaseInput {
    id: ID!
  
    """Provide extra context for dynamic jexl transforms and events"""
    context: JSONString
    clientMutationId: String
  }
  
  type SuspendCasePayload {
    case: Case
    clientMutationId: String
  }
  
  input SuspendWorkItemInput {
    id: ID!
  
    """Provide extra context for dynamic jexl transforms and events"""
    context: JSONString
    clientMutationId: String
  }
  
  type SuspendWorkItemPayload {
    workItem: WorkItem
    clientMutationId: String
  }
  
  type TableAnswer implements Answer & Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
  
    """The ID of the object"""
    id: ID!
    question: Question!
    value: [Document]
    meta: GenericScalar!
    document: Document
  }
  
  type TableQuestion implements Question & Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    slug: String!
    label: String!
  
    """Required expression is only evaluated when question is not hidden."""
    isRequired: QuestionJexl!
    isHidden: QuestionJexl!
    isArchived: Boolean!
    infoText: String
    hintText: String
    meta: GenericScalar!
    source: Question
    defaultAnswer: TableAnswer
    forms(offset: Int, before: String, after: String, first: Int, last: Int, filter: [FormFilterSetType], order: [FormOrderSetType]): FormConnection
  
    """Form that represents rows of a TableQuestion"""
    rowForm: Form
  
    """The ID of the object"""
    id: ID!
  }
  
  interface Task {
    id: ID!
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    slug: String!
    name: String!
    description: String
    isArchived: Boolean!
    addressGroups: GroupJexl
    controlGroups: GroupJexl
    meta: GenericScalar!
    isMultipleInstance: Boolean!
    continueAsync: Boolean
  }
  
  type TaskConnection {
    """Pagination data for this connection."""
    pageInfo: PageInfo!
  
    """Contains the nodes in this connection."""
    edges: [TaskEdge]!
    totalCount: Int
  }
  
  """A Relay edge containing a `Task` and its cursor."""
  type TaskEdge {
    """The item at the end of the edge"""
    node: Task
  
    """A cursor for use in pagination"""
    cursor: String!
  }
  
  input TaskFilterSetType {
    slug: String
    name: String
    description: String
  
    """"""
    type: Type
    isArchived: Boolean
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    createdBefore: DateTime
    createdAfter: DateTime
    modifiedBefore: DateTime
    modifiedAfter: DateTime
    metaHasKey: String
    metaValue: [JSONValueFilterType]
    search: String
    invert: Boolean
  }
  
  input TaskOrderSetType {
    meta: String
    attribute: SortableTaskAttributes
    direction: AscDesc
  }
  
  type TextQuestion implements Question & Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    slug: String!
    label: String!
  
    """Required expression is only evaluated when question is not hidden."""
    isRequired: QuestionJexl!
    isHidden: QuestionJexl!
    isArchived: Boolean!
    placeholder: String
    infoText: String
    hintText: String
    meta: GenericScalar!
    source: Question
    formatValidators(before: String, after: String, first: Int, last: Int): FormatValidatorConnection
    defaultAnswer: StringAnswer
    forms(offset: Int, before: String, after: String, first: Int, last: Int, filter: [FormFilterSetType], order: [FormOrderSetType]): FormConnection
  
    """The ID of the object"""
    id: ID!
    minLength: Int
    maxLength: Int
  }
  
  type TextareaQuestion implements Question & Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    slug: String!
    label: String!
  
    """Required expression is only evaluated when question is not hidden."""
    isRequired: QuestionJexl!
    isHidden: QuestionJexl!
    isArchived: Boolean!
    placeholder: String
    infoText: String
    hintText: String
    meta: GenericScalar!
    source: Question
    formatValidators(before: String, after: String, first: Int, last: Int): FormatValidatorConnection
    defaultAnswer: StringAnswer
    forms(offset: Int, before: String, after: String, first: Int, last: Int, filter: [FormFilterSetType], order: [FormOrderSetType]): FormConnection
  
    """The ID of the object"""
    id: ID!
    minLength: Int
    maxLength: Int
  }
  
  """An enumeration."""
  enum Type {
    """Task which can simply be marked as completed."""
    SIMPLE
  
    """Task to complete a defined workflow form."""
    COMPLETE_WORKFLOW_FORM
  
    """Task to complete a defined task form."""
    COMPLETE_TASK_FORM
  }
  
  """
  Leverages the internal Python implementation of UUID (uuid.UUID) to provide native UUID objects
  in fields, resolvers and input.
  """
  scalar UUID
  
  type ValidationEntry {
    slug: String!
    errorMsg: String!
  }
  
  type ValidationResult {
    id: ID
    isValid: Boolean
    errors: [ValidationEntry]
  }
  
  type WorkItem implements Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
  
    """The ID of the object"""
    id: ID!
  
    """Will be set from Task, if not provided."""
    name: String!
  
    """Will be set from Task, if not provided."""
    description: String
  
    """Time when work item has either been canceled or completed"""
    closedAt: DateTime
    closedByUser: String
    closedByGroup: String
    deadline: DateTime
    task: Task!
    status: WorkItemStatus!
    meta: GenericScalar
    addressedGroups: [String]!
    controllingGroups: [String]!
    assignedUsers: [String]!
    case: Case!
  
    """Defines case of a sub-workflow"""
    childCase: Case
    document: Document
    previousWorkItem: WorkItem
    succeedingWorkItems(offset: Int, before: String, after: String, first: Int, last: Int): WorkItemConnection!
  
    """
    This property potentially performs poorly if used in a large setof entries, as the evaluation of the redoable jexl configurationcannot be performed on the database level. Please use carefully.
    """
    isRedoable: Boolean
  }
  
  type WorkItemConnection {
    """Pagination data for this connection."""
    pageInfo: PageInfo!
  
    """Contains the nodes in this connection."""
    edges: [WorkItemEdge]!
    totalCount: Int
  }
  
  """A Relay edge containing a `WorkItem` and its cursor."""
  type WorkItemEdge {
    """The item at the end of the edge"""
    node: WorkItem
  
    """A cursor for use in pagination"""
    cursor: String!
  }
  
  input WorkItemFilterSetType {
    """"""
    status: Status
    name: String
    task: ID
    tasks: [String]
    case: ID
    createdAt: DateTime
    closedAt: DateTime
    modifiedAt: DateTime
    deadline: DateTime
    hasDeadline: Boolean
    caseFamily: ID
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    createdBefore: DateTime
    createdAfter: DateTime
    modifiedBefore: DateTime
    modifiedAfter: DateTime
    metaHasKey: String
    metaValue: [JSONValueFilterType]
    id: ID
    addressedGroups: [String]
    controllingGroups: [String]
    assignedUsers: [String]
    documentHasAnswer: [HasAnswerFilterType]
    caseDocumentHasAnswer: [HasAnswerFilterType]
    caseDocumentForms: [String]
    caseMetaValue: [JSONValueFilterType]
    rootCaseMetaValue: [JSONValueFilterType]
    caseSearchAnswers: [SearchAnswersFilterType]
    deadlineBefore: DateTime
    deadlineAfter: DateTime
    invert: Boolean
  }
  
  input WorkItemOrderSetType {
    meta: String
    caseMeta: String
    attribute: SortableWorkItemAttributes
    documentAnswer: String
    caseDocumentAnswer: String
    direction: AscDesc
  }
  
  """An enumeration."""
  enum WorkItemStatus {
    READY
    COMPLETED
    CANCELED
    SKIPPED
    SUSPENDED
    REDO
  }
  
  type Workflow implements Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    slug: String!
    name: String!
    description: String
    meta: GenericScalar
    isPublished: Boolean!
    isArchived: Boolean!
    startTasks: [Task]!
  
    """Allow workflow to be started with any form"""
    allowAllForms: Boolean!
  
    """List of forms which are allowed to start workflow with"""
    allowForms(offset: Int, before: String, after: String, first: Int, last: Int): FormConnection!
  
    """The ID of the object"""
    id: ID!
  
    """List of tasks referenced in workflow"""
    tasks: [Task]!
    flows(offset: Int, before: String, after: String, first: Int, last: Int, filter: [FlowFilterSetType], order: [FlowOrderSetType]): FlowConnection
  }
  
  type WorkflowConnection {
    """Pagination data for this connection."""
    pageInfo: PageInfo!
  
    """Contains the nodes in this connection."""
    edges: [WorkflowEdge]!
    totalCount: Int
  }
  
  """A Relay edge containing a `Workflow` and its cursor."""
  type WorkflowEdge {
    """The item at the end of the edge"""
    node: Workflow
  
    """A cursor for use in pagination"""
    cursor: String!
  }
  
  input WorkflowFilterSetType {
    slug: String
    name: String
    description: String
    isPublished: Boolean
    isArchived: Boolean
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    createdBefore: DateTime
    createdAfter: DateTime
    modifiedBefore: DateTime
    modifiedAfter: DateTime
    metaHasKey: String
    metaValue: [JSONValueFilterType]
    search: String
    invert: Boolean
  }
  
  input WorkflowOrderSetType {
    meta: String
    attribute: SortableWorkflowAttributes
    direction: AscDesc
  }
  
  '''
# ---
