# name: test_schema_introspect
  '
  schema {
    query: Query
    mutation: Mutation
  }

  type ActionButtonQuestion implements Question, Node {
# name: test_schema_introspect_direct
  '
  type TextQuestion implements Question & Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    slug: String!
    label: String!
    isRequired: QuestionJexl!
    isHidden: QuestionJexl!
    isArchived: Boolean!
    infoText: String
    meta: GenericScalar!
    source: Question
    forms(before: String, after: String, first: Int, last: Int, metaValue: [JSONValueFilterType], orderBy: [FormOrdering], slug: String, name: String, description: String, isPublished: Boolean, isArchived: Boolean, questions: [String], createdByUser: String, createdByGroup: String, modifiedByUser: String, modifiedByGroup: String, createdBefore: DateTime, createdAfter: DateTime, metaHasKey: String, search: String, slugs: [String]): FormConnection
    id: ID!
    action: ButtonAction!
    color: ButtonColor!
    validateOnEnter: Boolean!
  }

  input AddFormQuestionInput {
    form: ID!
    question: ID!
    clientMutationId: String
  }

  type AddFormQuestionPayload {
    form: Form
    clientMutationId: String
  }

  input AddWorkflowFlowInput {
    workflow: ID!
    tasks: [ID]!
    next: FlowJexl!
    redoable: FlowJexl
    clientMutationId: String
  }

  type AddWorkflowFlowPayload {
    workflow: Workflow
    clientMutationId: String
  }

  type AnalyticsCell {
    alias: String
    value: String
  }

  type AnalyticsField implements Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    id: ID!
    alias: String!
    meta: GenericScalar
    dataSource: String!
    table: AnalyticsTable!
    filters: [String]
  }

  type AnalyticsFieldConnection {
    pageInfo: PageInfo!
    edges: [AnalyticsFieldEdge]!
    totalCount: Int
  }

  type AnalyticsFieldEdge {
    node: AnalyticsField
    cursor: String!
  }

  input AnalyticsFieldFilterSetType {
    alias: String
    table: ID
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    createdBefore: DateTime
    createdAfter: DateTime
    metaHasKey: String
    metaValue: [JSONValueFilterType]
    search: String
    slugs: [String]
    invert: Boolean
  }

  type AnalyticsOutput {
    records(before: String, after: String, first: Int, last: Int): AnalyticsTableContentConnection
  }

  type AnalyticsRowConnection {
    pageInfo: PageInfo!
    edges: [AnalyticsRowEdge]!
  }

  type AnalyticsRowEdge {
    node: AnalyticsCell
    cursor: String!
  }

  type AnalyticsTable implements Node {

    """Required expression is only evaluated when question is not hidden."""
    isRequired: QuestionJexl!
    isHidden: QuestionJexl!
    isArchived: Boolean!
    placeholder: String
    infoText: String
    meta: GenericScalar!
    source: Question
    formatValidators(before: String = null, after: String = null, first: Int = null, last: Int = null): FormatValidatorConnection
    defaultAnswer: StringAnswer
    forms(
      offset: Int = null
      before: String = null
      after: String = null
      first: Int = null
      last: Int = null
      slug: String = null
      name: String = null
      description: String = null
      isPublished: Boolean = null
      isArchived: Boolean = null
      questions: [String] = null
      createdByUser: String = null
      createdByGroup: String = null
      modifiedByUser: String = null
      modifiedByGroup: String = null

      """Only return entries created after the given DateTime (Exclusive)"""
      createdBefore: DateTime = null

      """
      Only return entries created at or before the given DateTime (Inclusive)
      """
      createdAfter: DateTime = null
      metaHasKey: String = null
      metaValue: [JSONValueFilterType] = null
      search: String = null

      """FormOrdering"""
      orderBy: [FormOrdering] = null
      slugs: [String] = null
    ): FormConnection

    """The ID of the object"""
    id: ID!
    minLength: Int
    maxLength: Int
  }

  interface Question {
    id: ID!
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    slug: String!
    meta: JSONString!
    disableVisibilities: Boolean!
    name: String!
    startingObject: AnalyticsTableStartingObject!
    fields(before: String, after: String, first: Int, last: Int): AnalyticsFieldConnection!
    id: ID!
    availableFields(prefix: String, depth: Int, before: String, after: String, first: Int, last: Int): AvailableFieldConnection
    resultData: AnalyticsOutput
  }

  type AnalyticsTableConnection {
    pageInfo: PageInfo!
    edges: [AnalyticsTableEdge]!
    totalCount: Int
  }

  type AnalyticsTableContentConnection {
    pageInfo: PageInfo!
    edges: [AnalyticsTableContentEdge]!
  }

  type AnalyticsTableContentEdge {
    node: AnalyticsRowConnection
    cursor: String!
  }

  type AnalyticsTableEdge {
    node: AnalyticsTable
    cursor: String!
  }

  input AnalyticsTableFilterSetType {
    slug: String
    name: String
    label: String!
    infoText: String

    """Required expression is only evaluated when question is not hidden."""
    isRequired: QuestionJexl!
    isHidden: QuestionJexl!
    isArchived: Boolean!
    meta: GenericScalar!
    forms(
      offset: Int = null
      before: String = null
      after: String = null
      first: Int = null
      last: Int = null
      slug: String = null
      name: String = null
      description: String = null
      isPublished: Boolean = null
      isArchived: Boolean = null
      questions: [String] = null
      createdByUser: String = null
      createdByGroup: String = null
      modifiedByUser: String = null
      modifiedByGroup: String = null

      """Only return entries created after the given DateTime (Exclusive)"""
      createdBefore: DateTime = null

      """
      Only return entries created at or before the given DateTime (Inclusive)
      """
      createdAfter: DateTime = null
      metaHasKey: String = null
      metaValue: [JSONValueFilterType] = null
      search: String = null

      """FormOrdering"""
      orderBy: [FormOrdering] = null
      slugs: [String] = null
    ): FormConnection
    source: Question
  }

  """
  The `DateTime` scalar type represents a DateTime
  value as specified by
  [iso8601](https://en.wikipedia.org/wiki/ISO_8601).
  """
  scalar DateTime

  """
  Question jexl expression returning boolean.

  Following transform can be used:
  * answer - access answer of document by question slug
  * mapby - map list by key. Helpful to work with table answers
    whereas an answer is a list of dicts.

  Following context is available:
  * form - access form of document

  Examples:
  * 'answer' == 'question-slug'|answer
  * 'answer' in 'list-question-slug'|answer
  * 'answer' in 'table-question-slug'|answer|mapby('column-question')
  * 'form-slug' == form
  """
  scalar QuestionJexl

  """
  The `GenericScalar` scalar type represents a generic
  GraphQL scalar value that could be:
  String, Boolean, Int, Float, List or Object.
  """
  scalar GenericScalar

  type FormConnection {
    """Pagination data for this connection."""
    pageInfo: PageInfo!

    """Contains the nodes in this connection."""
    edges: [FormEdge]!
    totalCount: Int
  }

  """
  The Relay compliant `PageInfo` type, containing data necessary to paginate this connection.
  """
  type PageInfo {
    """When paginating forwards, are there more items?"""
    hasNextPage: Boolean!

    """When paginating backwards, are there more items?"""
    hasPreviousPage: Boolean!

    """When paginating backwards, the cursor to continue."""
    startCursor: String

    """When paginating forwards, the cursor to continue."""
    endCursor: String
  }

  """A Relay edge containing a `Form` and its cursor."""
  type FormEdge {
    """The item at the end of the edge"""
    node: Form

    """A cursor for use in pagination"""
    cursor: String!
  }

  type Form implements Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    slug: String!
    name: String!
    description: String
    meta: GenericScalar
    isPublished: Boolean!
    isArchived: Boolean!
    questions(
      offset: Int = null
      before: String = null
      after: String = null
      first: Int = null
      last: Int = null
      metaValue: [JSONValueFilterType] = null
      slug: String = null
      label: String = null
      isRequired: String = null
      isHidden: String = null
      isArchived: Boolean = null
      subForm: ID = null
      rowForm: ID = null
      createdByUser: String = null
      createdByGroup: String = null
      modifiedByUser: String = null
      modifiedByGroup: String = null

      """Only return entries created after the given DateTime (Exclusive)"""
      createdBefore: DateTime = null

      """
      Only return entries created at or before the given DateTime (Inclusive)
      """
      createdAfter: DateTime = null
      metaHasKey: String = null
      excludeForms: [ID] = null
      search: String = null

      """QuestionOrdering"""
      orderBy: [QuestionOrdering] = null
      slugs: [String] = null
    ): QuestionConnection

    """Reference this form has been copied from"""
    source: Form
    documents(offset: Int = null, before: String = null, after: String = null, first: Int = null, last: Int = null): DocumentConnection!

    """The ID of the object"""
    id: ID!
  }

  """An object with an ID"""
  interface Node {
    """The ID of the object"""
    id: ID!
  }

  type QuestionConnection {
    """Pagination data for this connection."""
    pageInfo: PageInfo!

    """Contains the nodes in this connection."""
    edges: [QuestionEdge]!
    totalCount: Int
  }

  """A Relay edge containing a `Question` and its cursor."""
  type QuestionEdge {
    """The item at the end of the edge"""
    node: Question

    """A cursor for use in pagination"""
    cursor: String!
  }

  input JSONValueFilterType {
    key: String!
    value: GenericScalar!
    lookup: JSONLookupMode
  }

  enum JSONLookupMode {
    EXACT
    STARTSWITH
    CONTAINS
    ICONTAINS
    IN
    GTE
    GT
    LTE
    LT
  }

  """An enumeration."""
  enum QuestionOrdering {
    """Label"""
    LABEL_ASC

    """Label (descending)"""
    LABEL_DESC

    """Created at"""
    CREATED_AT_ASC

    """Created at (descending)"""
    CREATED_AT_DESC

    """Modified at"""
    MODIFIED_AT_ASC

    """Modified at (descending)"""
    MODIFIED_AT_DESC

    """Created by user"""
    CREATED_BY_USER_ASC

    """Created by user (descending)"""
    CREATED_BY_USER_DESC

    """Created by group"""
    CREATED_BY_GROUP_ASC

    """Created by group (descending)"""
    CREATED_BY_GROUP_DESC

    """Modified by user"""
    MODIFIED_BY_USER_ASC

    """Modified by user (descending)"""
    MODIFIED_BY_USER_DESC

    """Modified by group"""
    MODIFIED_BY_GROUP_ASC

    """Modified by group (descending)"""
    MODIFIED_BY_GROUP_DESC

    """Meta test-key"""
    META_TEST_KEY_ASC

    """Meta test-key (descending)"""
    META_TEST_KEY_DESC

    """Meta foobar"""
    META_FOOBAR_ASC

    """Meta foobar (descending)"""
    META_FOOBAR_DESC
  }

  type DocumentConnection {
    """Pagination data for this connection."""
    pageInfo: PageInfo!

    """Contains the nodes in this connection."""
    edges: [DocumentEdge]!
    totalCount: Int
  }

  """A Relay edge containing a `Document` and its cursor."""
  type DocumentEdge {
    """The item at the end of the edge"""
    node: Document

    """A cursor for use in pagination"""
    cursor: String!
  }

  type Document implements Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String

    """The ID of the object"""
    id: ID!
    form: Form!

    """Reference this document has been copied from"""
    source: Document
    meta: GenericScalar

    """Reference this document has been copied from"""
    copies(offset: Int = null, before: String = null, after: String = null, first: Int = null, last: Int = null): DocumentConnection!
    answers(
      offset: Int = null
      before: String = null
      after: String = null
      first: Int = null
      last: Int = null
      metaValue: [JSONValueFilterType] = null
      question: ID = null
      search: String = null

      """AnswerOrdering"""
      orderBy: [AnswerOrdering] = null
      filter: [AnswerFilterSetType] = null
      order: [AnswerOrderSetType] = null
      createdByUser: String = null
      createdByGroup: String = null
      modifiedByUser: String = null
      modifiedByGroup: String = null

      """Only return entries created after the given DateTime (Exclusive)"""
      createdBefore: DateTime = null

      """
      Only return entries created at or before the given DateTime (Inclusive)
      """
      createdAfter: DateTime = null
      metaHasKey: String = null
      questions: [ID] = null
      visibleInContext: Boolean = null
    ): AnswerConnection
    case: Case
    workItem: WorkItem
    modifiedContentAt: DateTime
    modifiedContentByUser: String
    modifiedContentByGroup: String
  }

  type AnswerConnection {
    """Pagination data for this connection."""
    pageInfo: PageInfo!

    """Contains the nodes in this connection."""
    edges: [AnswerEdge]!
    totalCount: Int
  }

  """A Relay edge containing a `Answer` and its cursor."""
  type AnswerEdge {
    """The item at the end of the edge"""
    node: Answer

    """A cursor for use in pagination"""
    cursor: String!
  }

  interface Answer {
    id: ID
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    question: Question!
    meta: GenericScalar!
  }

  type AnswerConnection {
    pageInfo: PageInfo!
    edges: [AnswerEdge]!
    totalCount: Int
  }

  type AnswerEdge {
    node: Answer
    cursor: String!
  """An enumeration."""
  enum AnswerOrdering {
    """Created at"""
    CREATED_AT_ASC

    """Created at (descending)"""
    CREATED_AT_DESC

    """Modified at"""
    MODIFIED_AT_ASC

    """Modified at (descending)"""
    MODIFIED_AT_DESC

    """Created by user"""
    CREATED_BY_USER_ASC

    """Created by user (descending)"""
    CREATED_BY_USER_DESC

    """Created by group"""
    CREATED_BY_GROUP_ASC

    """Created by group (descending)"""
    CREATED_BY_GROUP_DESC

    """Modified by user"""
    MODIFIED_BY_USER_ASC

    """Modified by user (descending)"""
    MODIFIED_BY_USER_DESC

    """Modified by group"""
    MODIFIED_BY_GROUP_ASC

    """Modified by group (descending)"""
    MODIFIED_BY_GROUP_DESC

    """Meta test-key"""
    META_TEST_KEY_ASC

    """Meta test-key (descending)"""
    META_TEST_KEY_DESC

    """Meta foobar"""
    META_FOOBAR_ASC

    """Meta foobar (descending)"""
    META_FOOBAR_DESC
  }

  input AnswerFilterSetType {
    question: ID
    search: String
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    createdBefore: DateTime
    createdAfter: DateTime
    metaHasKey: String
    metaValue: [JSONValueFilterType]
    orderBy: [AnswerOrdering]
    questions: [ID]
    visibleInContext: Boolean
    invert: Boolean
  }

  enum AnswerHierarchyMode {
    DIRECT
    FAMILY
  input AnswerOrderSetType {
    meta: String
    attribute: SortableAnswerAttributes
    direction: AscDesc
  }

  enum SortableAnswerAttributes {
    CREATED_AT
    MODIFIED_AT
    CREATED_BY_USER
    CREATED_BY_GROUP
    MODIFIED_BY_USER
    MODIFIED_BY_GROUP
    QUESTION
    VALUE
    DOCUMENT
    DATE
    FILE
  }

  enum AscDesc {
    ASC
    DESC
  }

  type Case implements Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String

    """The ID of the object"""
    id: ID!

    """Time when case has either been canceled or completed"""
    closedAt: DateTime
    closedByUser: String
    closedByGroup: String
    workflow: Workflow!
    status: CalumaWorkflowCaseStatusChoices!
    meta: GenericScalar
    document: Document
    workItems(
      offset: Int = null
      before: String = null
      after: String = null
      first: Int = null
      last: Int = null
      metaValue: [JSONValueFilterType] = null
      status: WorkItemStatusArgument = null
      name: String = null
      task: ID = null
      tasks: [String] = null
      case: ID = null
      createdAt: DateTime = null
      closedAt: DateTime = null
      modifiedAt: DateTime = null
      deadline: DateTime = null
      hasDeadline: Boolean = null
      caseFamily: ID = null

      """WorkItemOrdering"""
      orderBy: [WorkItemOrdering] = null
      filter: [WorkItemFilterSetType] = null
      order: [WorkItemOrderSetType] = null
      createdByUser: String = null
      createdByGroup: String = null
      modifiedByUser: String = null
      modifiedByGroup: String = null

      """Only return entries created after the given DateTime (Exclusive)"""
      createdBefore: DateTime = null

      """
      Only return entries created at or before the given DateTime (Inclusive)
      """
      createdAfter: DateTime = null
      metaHasKey: String = null
      id: ID = null
      addressedGroups: [String] = null
      controllingGroups: [String] = null
      assignedUsers: [String] = null
      documentHasAnswer: [HasAnswerFilterType] = null
      caseDocumentHasAnswer: [HasAnswerFilterType] = null
      caseMetaValue: [JSONValueFilterType] = null
      rootCaseMetaValue: [JSONValueFilterType] = null
    ): WorkItemConnection
    parentWorkItem: WorkItem
    familyWorkItems(
      offset: Int = null
      before: String = null
      after: String = null
      first: Int = null
      last: Int = null
      metaValue: [JSONValueFilterType] = null
      status: WorkItemStatusArgument = null

      """WorkItemOrdering"""
      orderBy: [WorkItemOrdering] = null
      filter: [WorkItemFilterSetType] = null
      order: [WorkItemOrderSetType] = null
      documentHasAnswer: [HasAnswerFilterType] = null
      caseDocumentHasAnswer: [HasAnswerFilterType] = null
      caseMetaValue: [JSONValueFilterType] = null
      rootCaseMetaValue: [JSONValueFilterType] = null
      name: String = null
      task: ID = null
      tasks: [String] = null
      case: ID = null
      createdAt: DateTime = null
      closedAt: DateTime = null
      modifiedAt: DateTime = null
      deadline: DateTime = null
      hasDeadline: Boolean = null
      caseFamily: ID = null
      createdByUser: String = null
      createdByGroup: String = null
      modifiedByUser: String = null
      modifiedByGroup: String = null

      """Only return entries created after the given DateTime (Exclusive)"""
      createdBefore: DateTime = null

      """
      Only return entries created at or before the given DateTime (Inclusive)
      """
      createdAfter: DateTime = null
      metaHasKey: String = null
      id: ID = null
      addressedGroups: [String] = null
      controllingGroups: [String] = null
      assignedUsers: [String] = null
    ): WorkItemConnection
  }

  type Workflow implements Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    slug: String!
    name: String!
    description: String
    meta: GenericScalar
    isPublished: Boolean!
    isArchived: Boolean!
    startTasks: [Task]!

    """Allow workflow to be started with any form"""
    allowAllForms: Boolean!

    """List of forms which are allowed to start workflow with"""
    allowForms(offset: Int = null, before: String = null, after: String = null, first: Int = null, last: Int = null): FormConnection!

    """The ID of the object"""
    id: ID!

    """List of tasks referenced in workflow"""
    tasks: [Task]!
    flows(
      offset: Int = null
      before: String = null
      after: String = null
      first: Int = null
      last: Int = null
      task: ID = null
      filter: [FlowFilterSetType] = null
      createdByUser: String = null
      createdByGroup: String = null
      modifiedByUser: String = null
      modifiedByGroup: String = null

      """Only return entries created after the given DateTime (Exclusive)"""
      createdBefore: DateTime = null

      """
      Only return entries created at or before the given DateTime (Inclusive)
      """
      createdAfter: DateTime = null
    ): FlowConnection
  }

  interface Task {
    id: ID!
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    slug: String!
    name: String!
    description: String
    isArchived: Boolean!
    addressGroups: GroupJexl
    controlGroups: GroupJexl
    meta: GenericScalar!
    isMultipleInstance: Boolean!
  }

  """
  Group jexl represents a jexl expression returning group names.

  Following transforms can be used:
  * groups - return list of group names

  Examples:
  * ['group-name1', 'group-name2']|groups
  """
  scalar GroupJexl

  type FlowConnection {
    """Pagination data for this connection."""
    pageInfo: PageInfo!

    """Contains the nodes in this connection."""
    edges: [FlowEdge]!
    totalCount: Int
  }

  """A Relay edge containing a `Flow` and its cursor."""
  type FlowEdge {
    """The item at the end of the edge"""
    node: Flow

    """A cursor for use in pagination"""
    cursor: String!
  }

  type Flow implements Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String

    """The ID of the object"""
    id: ID!
    next: FlowJexl!
    tasks: [Task]!
  }

  """
  Flow jexl represents a jexl expression returning task slugs.

  Following transforms can be used:
  * task - return single task
  * tasks - return multiple tasks

  Examples:
  * 'task-slug'|task
  * ['task-slug1', 'task-slug2']|tasks
  """
  scalar FlowJexl

  input FlowFilterSetType {
    task: ID
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    createdBefore: DateTime
    createdAfter: DateTime
    invert: Boolean
  }

  """An enumeration."""
  enum CalumaWorkflowCaseStatusChoices {
    """Case is running and work items need to be completed."""
    RUNNING

    """Case is done."""
    COMPLETED

    """Case is canceled."""
    CANCELED

    """Case is suspended."""
    SUSPENDED
  }

  type WorkItemConnection {
    """Pagination data for this connection."""
    pageInfo: PageInfo!

    """Contains the nodes in this connection."""
    edges: [WorkItemEdge]!
    totalCount: Int
  }

  """A Relay edge containing a `WorkItem` and its cursor."""
  type WorkItemEdge {
    """The item at the end of the edge"""
    node: WorkItem

    """A cursor for use in pagination"""
    cursor: String!
  }

  type WorkItem implements Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String

    """The ID of the object"""
    id: ID!

    """Will be set from Task, if not provided."""
    name: String!

    """Will be set from Task, if not provided."""
    description: String

    """Time when work item has either been canceled or completed"""
    closedAt: DateTime
    closedByUser: String
    closedByGroup: String
    deadline: DateTime
    task: Task!
    status: CalumaWorkflowWorkItemStatusChoices!
    meta: GenericScalar

    """
    Offer work item to be processed by a group of users, such are not committed to process it though.
    """
    addressedGroups: [String!]!

    """List of groups this work item is assigned to for controlling."""
    controllingGroups: [String!]!

    """Users responsible to undertake given work item."""
    assignedUsers: [String!]!
    case: Case!

    """Defines case of a sub-workflow"""
    childCase: Case
    document: Document
    previousWorkItem: WorkItem
    succeedingWorkItems(offset: Int = null, before: String = null, after: String = null, first: Int = null, last: Int = null): WorkItemConnection!
  }

  """An enumeration."""
  enum CalumaWorkflowWorkItemStatusChoices {
    """Work item is ready to be processed."""
    READY

    """Work item is done."""
    COMPLETED

    """Work item is canceled."""
    CANCELED

    """Work item is skipped."""
    SKIPPED

    """Work item is suspended."""
    SUSPENDED
  }

  """An enumeration."""
  enum WorkItemStatusArgument {
    """Work item is ready to be processed."""
    READY

    """Work item is done."""
    COMPLETED

    """Work item is canceled."""
    CANCELED

    """Work item is skipped."""
    SKIPPED

    """Work item is suspended."""
    SUSPENDED
  }

  """An enumeration."""
  enum WorkItemOrdering {
    """Status"""
    STATUS_ASC

    """Status (descending)"""
    STATUS_DESC

    """Deadline"""
    DEADLINE_ASC

    """Deadline (descending)"""
    DEADLINE_DESC

    """Created at"""
    CREATED_AT_ASC

    """Created at (descending)"""
    CREATED_AT_DESC

    """Modified at"""
    MODIFIED_AT_ASC

    """Modified at (descending)"""
    MODIFIED_AT_DESC

    """Created by user"""
    CREATED_BY_USER_ASC

    """Created by user (descending)"""
    CREATED_BY_USER_DESC

    """Created by group"""
    CREATED_BY_GROUP_ASC

    """Created by group (descending)"""
    CREATED_BY_GROUP_DESC

    """Modified by user"""
    MODIFIED_BY_USER_ASC

    """Modified by user (descending)"""
    MODIFIED_BY_USER_DESC

    """Modified by group"""
    MODIFIED_BY_GROUP_ASC

    """Modified by group (descending)"""
    MODIFIED_BY_GROUP_DESC

    """Meta test-key"""
    META_TEST_KEY_ASC

    """Meta test-key (descending)"""
    META_TEST_KEY_DESC

    """Meta foobar"""
    META_FOOBAR_ASC

    """Meta foobar (descending)"""
    META_FOOBAR_DESC
  }

  input WorkItemFilterSetType {
    """"""
    status: Status
    name: String
    task: ID
    tasks: [String]
    case: ID
    createdAt: DateTime
    closedAt: DateTime
    modifiedAt: DateTime
    deadline: DateTime
    hasDeadline: Boolean
    caseFamily: ID
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    createdBefore: DateTime
    createdAfter: DateTime
    metaHasKey: String
    metaValue: [JSONValueFilterType]
    id: ID

    """"""
    orderBy: [WorkItemOrdering]
    addressedGroups: [String]
    controllingGroups: [String]
    assignedUsers: [String]
    documentHasAnswer: [HasAnswerFilterType]
    caseDocumentHasAnswer: [HasAnswerFilterType]
    caseMetaValue: [JSONValueFilterType]
    rootCaseMetaValue: [JSONValueFilterType]
    invert: Boolean
  }

  """An enumeration."""
  enum Status {
    """Work item is ready to be processed."""
    READY

    """Work item is done."""
    COMPLETED

    """Work item is canceled."""
    CANCELED

    """Work item is skipped."""
    SKIPPED

    """Work item is suspended."""
    SUSPENDED
  }

  """
  Lookup type to search document structures.

  When using lookup `ISNULL`, the provided `value` will be ignored.
  """
  input HasAnswerFilterType {
    question: ID!
    value: GenericScalar
    lookup: AnswerLookupMode
    hierarchy: AnswerHierarchyMode
  }

  enum AnswerLookupMode {
    EXACT
    STARTSWITH
    CONTAINS
    ICONTAINS
    INTERSECTS
    ISNULL
    GTE
    GT
    LTE
    LT
  }

  enum AnswerHierarchyMode {
    DIRECT
    FAMILY
  }

  input WorkItemOrderSetType {
    meta: String
    caseMeta: String
    attribute: SortableWorkItemAttributes
    documentAnswer: String
    caseDocumentAnswer: String
    direction: AscDesc
  }

  enum SortableWorkItemAttributes {
    ALLOW_ALL_FORMS
    CREATED_BY_GROUP
    CREATED_BY_USER
    DESCRIPTION
    CREATED_AT
    MODIFIED_AT
    CLOSED_AT
    IS_ARCHIVED
    IS_PUBLISHED
    NAME
    DEADLINE
    STATUS
    SLUG
  }

  """An enumeration."""
  enum FormOrdering {
    """Name"""
    NAME_ASC

    """Name (descending)"""
    NAME_DESC

    """Created at"""
    CREATED_AT_ASC

    """Created at (descending)"""
    CREATED_AT_DESC

    """Modified at"""
    MODIFIED_AT_ASC

    """Modified at (descending)"""
    MODIFIED_AT_DESC

    """Created by user"""
    CREATED_BY_USER_ASC

    """Created by user (descending)"""
    CREATED_BY_USER_DESC

    """Created by group"""
    CREATED_BY_GROUP_ASC

    """Created by group (descending)"""
    CREATED_BY_GROUP_DESC

    """Modified by user"""
    MODIFIED_BY_USER_ASC

    """Modified by user (descending)"""
    MODIFIED_BY_USER_DESC

    """Modified by group"""
    MODIFIED_BY_GROUP_ASC

    """Modified by group (descending)"""
    MODIFIED_BY_GROUP_DESC

    """Meta test-key"""
    META_TEST_KEY_ASC

    """Meta test-key (descending)"""
    META_TEST_KEY_DESC

    """Meta foobar"""
    META_FOOBAR_ASC

    """Meta foobar (descending)"""
    META_FOOBAR_DESC
  }

  type FormatValidatorConnection {
    """Pagination data for this connection."""
    pageInfo: PageInfo!

    """Contains the nodes in this connection."""
    edges: [FormatValidatorEdge]!
    totalCount: Int
  }

  """A Relay edge containing a `FormatValidator` and its cursor."""
  type FormatValidatorEdge {
    """The item at the end of the edge"""
    node: FormatValidator

    """A cursor for use in pagination"""
    cursor: String!
  }

  type FormatValidator {
    slug: String!
    name: String!
    regex: String!
    errorMsg: String!
  }

  type ChoiceQuestion implements Question & Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    slug: String!
    label: String!

    """Required expression is only evaluated when question is not hidden."""
    isRequired: QuestionJexl!
    isHidden: QuestionJexl!
    isArchived: Boolean!
    infoText: String
    hintText: String
    meta: GenericScalar!
    source: Question
    forms(before: String, after: String, first: Int, last: Int, metaValue: [JSONValueFilterType], orderBy: [FormOrdering], slug: String, name: String, description: String, isPublished: Boolean, isArchived: Boolean, questions: [String], createdByUser: String, createdByGroup: String, modifiedByUser: String, modifiedByGroup: String, createdBefore: DateTime, createdAfter: DateTime, metaHasKey: String, search: String, slugs: [String]): FormConnection
    calcExpression: String
    id: ID!
  }

  input CancelCaseInput {
    id: ID!
    context: JSONString
    clientMutationId: String
  }

  type CancelCasePayload {
    case: Case
    clientMutationId: String
  }

  input CancelWorkItemInput {
    id: ID!
    context: JSONString
    clientMutationId: String
  }

  type CancelWorkItemPayload {
    workItem: WorkItem
    clientMutationId: String
  }

  type Case implements Node {
    meta: GenericScalar!
    source: Question
    defaultAnswer: StringAnswer
    forms(
      offset: Int = null
      before: String = null
      after: String = null
      first: Int = null
      last: Int = null
      slug: String = null
      name: String = null
      description: String = null
      isPublished: Boolean = null
      isArchived: Boolean = null
      questions: [String] = null
      createdByUser: String = null
      createdByGroup: String = null
      modifiedByUser: String = null
      modifiedByGroup: String = null

      """Only return entries created after the given DateTime (Exclusive)"""
      createdBefore: DateTime = null

      """
      Only return entries created at or before the given DateTime (Inclusive)
      """
      createdAfter: DateTime = null
      metaHasKey: String = null
      metaValue: [JSONValueFilterType] = null
      search: String = null

      """FormOrdering"""
      orderBy: [FormOrdering] = null
      slugs: [String] = null
    ): FormConnection
    options(
      offset: Int = null
      before: String = null
      after: String = null
      first: Int = null
      last: Int = null
      metaValue: [JSONValueFilterType] = null
      slug: String = null
      label: String = null
      isArchived: Boolean = null
      createdByUser: String = null
      createdByGroup: String = null
      modifiedByUser: String = null
      modifiedByGroup: String = null

      """Only return entries created after the given DateTime (Exclusive)"""
      createdBefore: DateTime = null

      """
      Only return entries created at or before the given DateTime (Inclusive)
      """
      createdAfter: DateTime = null
      metaHasKey: String = null
      search: String = null

      """OptionOrdering"""
      orderBy: [OptionOrdering] = null
    ): OptionConnection

    """The ID of the object"""
    id: ID!
  }

  type OptionConnection {
    """Pagination data for this connection."""
    pageInfo: PageInfo!

    """Contains the nodes in this connection."""
    edges: [OptionEdge]!
    totalCount: Int
  }

  """A Relay edge containing a `Option` and its cursor."""
  type OptionEdge {
    """The item at the end of the edge"""
    node: Option

    """A cursor for use in pagination"""
    cursor: String!
  }

  type Option implements Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    id: ID!
    closedAt: DateTime
    closedByUser: String
    closedByGroup: String
    workflow: Workflow!
    status: CaseStatus!
    meta: GenericScalar
    document: Document
    workItems(before: String, after: String, first: Int, last: Int, metaValue: [JSONValueFilterType], status: WorkItemStatusArgument, name: String, task: ID, tasks: [String], case: ID, createdAt: DateTime, closedAt: DateTime, modifiedAt: DateTime, deadline: DateTime, hasDeadline: Boolean, caseFamily: ID, orderBy: [WorkItemOrdering], filter: [WorkItemFilterSetType], order: [WorkItemOrderSetType], createdByUser: String, createdByGroup: String, modifiedByUser: String, modifiedByGroup: String, createdBefore: DateTime, createdAfter: DateTime, metaHasKey: String, id: ID, addressedGroups: [String], controllingGroups: [String], assignedUsers: [String], documentHasAnswer: [HasAnswerFilterType], caseDocumentHasAnswer: [HasAnswerFilterType], caseMetaValue: [JSONValueFilterType], rootCaseMetaValue: [JSONValueFilterType]): WorkItemConnection
    parentWorkItem: WorkItem
    familyWorkItems(before: String, after: String, first: Int, last: Int, metaValue: [JSONValueFilterType], status: WorkItemStatusArgument, orderBy: [WorkItemOrdering], filter: [WorkItemFilterSetType], order: [WorkItemOrderSetType], documentHasAnswer: [HasAnswerFilterType], caseDocumentHasAnswer: [HasAnswerFilterType], caseMetaValue: [JSONValueFilterType], rootCaseMetaValue: [JSONValueFilterType], name: String, task: ID, tasks: [String], case: ID, createdAt: DateTime, closedAt: DateTime, modifiedAt: DateTime, deadline: DateTime, hasDeadline: Boolean, caseFamily: ID, createdByUser: String, createdByGroup: String, modifiedByUser: String, modifiedByGroup: String, createdBefore: DateTime, createdAfter: DateTime, metaHasKey: String, id: ID, addressedGroups: [String], controllingGroups: [String], assignedUsers: [String]): WorkItemConnection
  }

  type CaseConnection {
    pageInfo: PageInfo!
    slug: String!
    label: String!
    isArchived: Boolean!
    meta: GenericScalar

    """Reference this option has been copied from"""
    source: Option

    """The ID of the object"""
    id: ID!
  }

  """An enumeration."""
  enum OptionOrdering {
    """Label"""
    LABEL_ASC

    """Label (descending)"""
    LABEL_DESC

    """Created at"""
    CREATED_AT_ASC

    """Created at (descending)"""
    CREATED_AT_DESC

    """Modified at"""
    MODIFIED_AT_ASC

    """Modified at (descending)"""
    MODIFIED_AT_DESC

    """Created by user"""
    CREATED_BY_USER_ASC

    """Created by user (descending)"""
    CREATED_BY_USER_DESC

    """Created by group"""
    CREATED_BY_GROUP_ASC

    """Created by group (descending)"""
    CREATED_BY_GROUP_DESC

    """Modified by user"""
    MODIFIED_BY_USER_ASC

    """Modified by user (descending)"""
    MODIFIED_BY_USER_DESC

    """Modified by group"""
    MODIFIED_BY_GROUP_ASC

    """Modified by group (descending)"""
    MODIFIED_BY_GROUP_DESC

    """Meta test-key"""
    META_TEST_KEY_ASC

    """Meta test-key (descending)"""
    META_TEST_KEY_DESC

    """Meta foobar"""
    META_FOOBAR_ASC

    """Meta foobar (descending)"""
    META_FOOBAR_DESC
  }

  type MultipleChoiceQuestion implements Question & Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    slug: String!
    label: String!

    """Required expression is only evaluated when question is not hidden."""
    isRequired: QuestionJexl!
    isHidden: QuestionJexl!
    isArchived: Boolean!
    infoText: String
    meta: GenericScalar!
    source: Question
    defaultAnswer: ListAnswer
    forms(
      offset: Int = null
      before: String = null
      after: String = null
      first: Int = null
      last: Int = null
      slug: String = null
      name: String = null
      description: String = null
      isPublished: Boolean = null
      isArchived: Boolean = null
      questions: [String] = null
      createdByUser: String = null
      createdByGroup: String = null
      modifiedByUser: String = null
      modifiedByGroup: String = null

      """Only return entries created after the given DateTime (Exclusive)"""
      createdBefore: DateTime = null

      """
      Only return entries created at or before the given DateTime (Inclusive)
      """
      createdAfter: DateTime = null
      metaHasKey: String = null
      metaValue: [JSONValueFilterType] = null
      search: String = null

      """FormOrdering"""
      orderBy: [FormOrdering] = null
      slugs: [String] = null
    ): FormConnection
    options(
      offset: Int = null
      before: String = null
      after: String = null
      first: Int = null
      last: Int = null
      metaValue: [JSONValueFilterType] = null

      """OptionOrdering"""
      orderBy: [OptionOrdering] = null
      slug: String = null
      label: String = null
      isArchived: Boolean = null
      createdByUser: String = null
      createdByGroup: String = null
      modifiedByUser: String = null
      modifiedByGroup: String = null

      """Only return entries created after the given DateTime (Exclusive)"""
      createdBefore: DateTime = null

      """
      Only return entries created at or before the given DateTime (Inclusive)
      """
      createdAfter: DateTime = null
      metaHasKey: String = null
      search: String = null
    ): OptionConnection
    staticContent: String

    """The ID of the object"""
    id: ID!
  }

  type DynamicChoiceQuestion implements Question & DynamicQuestion & Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    slug: String!
    label: String!

    """Required expression is only evaluated when question is not hidden."""
    isRequired: QuestionJexl!
    isHidden: QuestionJexl!
    isArchived: Boolean!
    infoText: String
    meta: GenericScalar!
    source: Question
    forms(
      offset: Int = null
      before: String = null
      after: String = null
      first: Int = null
      last: Int = null
      slug: String = null
      name: String = null
      description: String = null
      isPublished: Boolean = null
      isArchived: Boolean = null
      questions: [String] = null
      createdByUser: String = null
      createdByGroup: String = null
      modifiedByUser: String = null
      modifiedByGroup: String = null

      """Only return entries created after the given DateTime (Exclusive)"""
      createdBefore: DateTime = null

      """
      Only return entries created at or before the given DateTime (Inclusive)
      """
      createdAfter: DateTime = null
      metaHasKey: String = null
      metaValue: [JSONValueFilterType] = null
      search: String = null

      """FormOrdering"""
      orderBy: [FormOrdering] = null
      slugs: [String] = null
    ): FormConnection
    options(before: String = null, after: String = null, first: Int = null, last: Int = null): DataSourceDataConnection
    dataSource: String!

    """The ID of the object"""
    id: ID!
  }

  interface DynamicQuestion {
    options(before: String = null, after: String = null, first: Int = null, last: Int = null): DataSourceDataConnection
    dataSource: String!
  }

  type DataSourceDataConnection {
    """Pagination data for this connection."""
    pageInfo: PageInfo!

    """Contains the nodes in this connection."""
    edges: [DataSourceDataEdge]!
    totalCount: Int
  }

  """A Relay edge containing a `DataSourceData` and its cursor."""
  type DataSourceDataEdge {
    """The item at the end of the edge"""
    node: DataSourceData

    """A cursor for use in pagination"""
    cursor: String!
  }

  type DataSourceData {
    label: String!
    slug: String!
  }

  type DynamicMultipleChoiceQuestion implements Question & DynamicQuestion & Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    slug: String!
    label: String!

    """Required expression is only evaluated when question is not hidden."""
    isRequired: QuestionJexl!
    isHidden: QuestionJexl!
    isArchived: Boolean!
    infoText: String
    meta: GenericScalar!
    source: Question
    forms(
      offset: Int = null
      before: String = null
      after: String = null
      first: Int = null
      last: Int = null
      slug: String = null
      name: String = null
      description: String = null
      isPublished: Boolean = null
      isArchived: Boolean = null
      questions: [String] = null
      createdByUser: String = null
      createdByGroup: String = null
      modifiedByUser: String = null
      modifiedByGroup: String = null

      """Only return entries created after the given DateTime (Exclusive)"""
      createdBefore: DateTime = null

      """
      Only return entries created at or before the given DateTime (Inclusive)
      """
      createdAfter: DateTime = null
      metaHasKey: String = null
      metaValue: [JSONValueFilterType] = null
      search: String = null

      """FormOrdering"""
      orderBy: [FormOrdering] = null
      slugs: [String] = null
    ): FormConnection
    options(before: String = null, after: String = null, first: Int = null, last: Int = null): DataSourceDataConnection
    dataSource: String!

    """The ID of the object"""
    id: ID!
  }

  type TextareaQuestion implements Question & Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    slug: String!
    label: String!

    """Required expression is only evaluated when question is not hidden."""
    isRequired: QuestionJexl!
    isHidden: QuestionJexl!
    isArchived: Boolean!
    placeholder: String
    infoText: String
    meta: GenericScalar!
    source: Question
    formatValidators(before: String = null, after: String = null, first: Int = null, last: Int = null): FormatValidatorConnection
    defaultAnswer: StringAnswer
    forms(
      offset: Int = null
      before: String = null
      after: String = null
      first: Int = null
      last: Int = null
      slug: String = null
      name: String = null
      description: String = null
      isPublished: Boolean = null
      isArchived: Boolean = null
      questions: [String] = null
      createdByUser: String = null
      createdByGroup: String = null
      modifiedByUser: String = null
      modifiedByGroup: String = null

      """Only return entries created after the given DateTime (Exclusive)"""
      createdBefore: DateTime = null

      """
      Only return entries created at or before the given DateTime (Inclusive)
      """
      createdAfter: DateTime = null
      metaHasKey: String = null
      metaValue: [JSONValueFilterType] = null
      search: String = null

      """FormOrdering"""
      orderBy: [FormOrdering] = null
      slugs: [String] = null
    ): FormConnection

    """The ID of the object"""
    id: ID!
    minLength: Int
    maxLength: Int
  }

  type FloatQuestion implements Question & Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    slug: String!
    label: String!

    """Required expression is only evaluated when question is not hidden."""
    isRequired: QuestionJexl!
    isHidden: QuestionJexl!
    isArchived: Boolean!
    placeholder: String
    infoText: String
    meta: GenericScalar!
    source: Question
    defaultAnswer: FloatAnswer
    forms(
      offset: Int = null
      before: String = null
      after: String = null
      first: Int = null
      last: Int = null
      slug: String = null
      name: String = null
      description: String = null
      isPublished: Boolean = null
      isArchived: Boolean = null
      questions: [String] = null
      createdByUser: String = null
      createdByGroup: String = null
      modifiedByUser: String = null
      modifiedByGroup: String = null

      """Only return entries created after the given DateTime (Exclusive)"""
      createdBefore: DateTime = null

      """
      Only return entries created at or before the given DateTime (Inclusive)
      """
      createdAfter: DateTime = null
      metaHasKey: String = null
      metaValue: [JSONValueFilterType] = null
      search: String = null

      """FormOrdering"""
      orderBy: [FormOrdering] = null
      slugs: [String] = null
    ): FormConnection

    """The ID of the object"""
    id: ID!
    minValue: Float
    maxValue: Float
  }

  type IntegerQuestion implements Question & Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    slug: String!
    label: String!

    """Required expression is only evaluated when question is not hidden."""
    isRequired: QuestionJexl!
    isHidden: QuestionJexl!
    isArchived: Boolean!
    placeholder: String
    infoText: String
    meta: GenericScalar!
    source: Question
    defaultAnswer: IntegerAnswer
    forms(
      offset: Int = null
      before: String = null
      after: String = null
      first: Int = null
      last: Int = null
      slug: String = null
      name: String = null
      description: String = null
      isPublished: Boolean = null
      isArchived: Boolean = null
      questions: [String] = null
      createdByUser: String = null
      createdByGroup: String = null
      modifiedByUser: String = null
      modifiedByGroup: String = null

      """Only return entries created after the given DateTime (Exclusive)"""
      createdBefore: DateTime = null

      """
      Only return entries created at or before the given DateTime (Inclusive)
      """
      createdAfter: DateTime = null
      metaHasKey: String = null
      metaValue: [JSONValueFilterType] = null
      search: String = null

      """FormOrdering"""
      orderBy: [FormOrdering] = null
      slugs: [String] = null
    ): FormConnection

    """The ID of the object"""
    id: ID!
    maxValue: Int
    minValue: Int
  }

  type DateQuestion implements Question & Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    slug: String!
    label: String!

    """Required expression is only evaluated when question is not hidden."""
    isRequired: QuestionJexl!
    isHidden: QuestionJexl!
    isArchived: Boolean!
    infoText: String
    meta: GenericScalar!
    source: Question
    defaultAnswer: DateAnswer
    forms(
      offset: Int = null
      before: String = null
      after: String = null
      first: Int = null
      last: Int = null
      slug: String = null
      name: String = null
      description: String = null
      isPublished: Boolean = null
      isArchived: Boolean = null
      questions: [String] = null
      createdByUser: String = null
      createdByGroup: String = null
      modifiedByUser: String = null
      modifiedByGroup: String = null

      """Only return entries created after the given DateTime (Exclusive)"""
      createdBefore: DateTime = null

      """
      Only return entries created at or before the given DateTime (Inclusive)
      """
      createdAfter: DateTime = null
      metaHasKey: String = null
      metaValue: [JSONValueFilterType] = null
      search: String = null

      """FormOrdering"""
      orderBy: [FormOrdering] = null
      slugs: [String] = null
    ): FormConnection

    """The ID of the object"""
    id: ID!
  }

  type TableQuestion implements Question & Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    slug: String!
    label: String!

    """Required expression is only evaluated when question is not hidden."""
    isRequired: QuestionJexl!
    isHidden: QuestionJexl!
    isArchived: Boolean!
    infoText: String
    meta: GenericScalar!
    source: Question
    defaultAnswer: TableAnswer
    forms(
      offset: Int = null
      before: String = null
      after: String = null
      first: Int = null
      last: Int = null
      slug: String = null
      name: String = null
      description: String = null
      isPublished: Boolean = null
      isArchived: Boolean = null
      questions: [String] = null
      createdByUser: String = null
      createdByGroup: String = null
      modifiedByUser: String = null
      modifiedByGroup: String = null

      """Only return entries created after the given DateTime (Exclusive)"""
      createdBefore: DateTime = null

      """
      Only return entries created at or before the given DateTime (Inclusive)
      """
      createdAfter: DateTime = null
      metaHasKey: String = null
      metaValue: [JSONValueFilterType] = null
      search: String = null

      """FormOrdering"""
      orderBy: [FormOrdering] = null
      slugs: [String] = null
    ): FormConnection

    """Form that represents rows of a TableQuestion"""
    rowForm: Form

    """The ID of the object"""
    id: ID!
  }

  type FormQuestion implements Question & Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    slug: String!
    label: String!

    """Required expression is only evaluated when question is not hidden."""
    isRequired: QuestionJexl!
    isHidden: QuestionJexl!
    isArchived: Boolean!
    infoText: String
    meta: GenericScalar!
    source: Question
    forms(
      offset: Int = null
      before: String = null
      after: String = null
      first: Int = null
      last: Int = null
      slug: String = null
      name: String = null
      description: String = null
      isPublished: Boolean = null
      isArchived: Boolean = null
      questions: [String] = null
      createdByUser: String = null
      createdByGroup: String = null
      modifiedByUser: String = null
      modifiedByGroup: String = null

      """Only return entries created after the given DateTime (Exclusive)"""
      createdBefore: DateTime = null

      """
      Only return entries created at or before the given DateTime (Inclusive)
      """
      createdAfter: DateTime = null
      metaHasKey: String = null
      metaValue: [JSONValueFilterType] = null
      search: String = null

      """FormOrdering"""
      orderBy: [FormOrdering] = null
      slugs: [String] = null
    ): FormConnection

    """Form referenced in a FormQuestion"""
    subForm: Form

    """The ID of the object"""
    id: ID!
  }

  type FileQuestion implements Question & Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    slug: String!
    label: String!

    """Required expression is only evaluated when question is not hidden."""
    isRequired: QuestionJexl!
    isHidden: QuestionJexl!
    isArchived: Boolean!
    infoText: String
    meta: GenericScalar!
    source: Question
    forms(
      offset: Int = null
      before: String = null
      after: String = null
      first: Int = null
      last: Int = null
      slug: String = null
      name: String = null
      description: String = null
      isPublished: Boolean = null
      isArchived: Boolean = null
      questions: [String] = null
      createdByUser: String = null
      createdByGroup: String = null
      modifiedByUser: String = null
      modifiedByGroup: String = null

      """Only return entries created after the given DateTime (Exclusive)"""
      createdBefore: DateTime = null

      """
      Only return entries created at or before the given DateTime (Inclusive)
      """
      createdAfter: DateTime = null
      metaHasKey: String = null
      metaValue: [JSONValueFilterType] = null
      search: String = null

      """FormOrdering"""
      orderBy: [FormOrdering] = null
      slugs: [String] = null
    ): FormConnection

    """The ID of the object"""
    id: ID!
  }

  type StaticQuestion implements Question & Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    slug: String!
    label: String!

    """
    Required expression is only evaluated when question is not hidden. This should not be used for `StaticQuestion`, because it can never be satisfied.
    """
    isRequired: QuestionJexl!
    isHidden: QuestionJexl!
    isArchived: Boolean!
    infoText: String
    meta: GenericScalar!
    source: Question
    forms(
      offset: Int = null
      before: String = null
      after: String = null
      first: Int = null
      last: Int = null
      slug: String = null
      name: String = null
      description: String = null
      isPublished: Boolean = null
      isArchived: Boolean = null
      questions: [String] = null
      createdByUser: String = null
      createdByGroup: String = null
      modifiedByUser: String = null
      modifiedByGroup: String = null

      """Only return entries created after the given DateTime (Exclusive)"""
      createdBefore: DateTime = null

      """
      Only return entries created at or before the given DateTime (Inclusive)
      """
      createdAfter: DateTime = null
      metaHasKey: String = null
      metaValue: [JSONValueFilterType] = null
      search: String = null

      """FormOrdering"""
      orderBy: [FormOrdering] = null
      slugs: [String] = null
    ): FormConnection
    staticContent: String
    dataSource: String

    """The ID of the object"""
    id: ID!
  }

  type StringAnswer implements Answer & Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String

    """The ID of the object"""
    id: ID!
    question: Question!
    value: String
    meta: GenericScalar!
    selectedOption: SelectedOption
  }

  type SelectedOption {
    label: String!
    slug: String!
  }

  type ListAnswer implements Answer & Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String

    """The ID of the object"""
    id: ID!
    question: Question!
    value: [String]
    meta: GenericScalar!
    selectedOptions(before: String = null, after: String = null, first: Int = null, last: Int = null): SelectedOptionConnection
  }

  type SelectedOptionConnection {
    """Pagination data for this connection."""
    pageInfo: PageInfo!

    """Contains the nodes in this connection."""
    edges: [SelectedOptionEdge]!
    totalCount: Int
  }

  """A Relay edge containing a `SelectedOption` and its cursor."""
  type SelectedOptionEdge {
    """The item at the end of the edge"""
    node: SelectedOption

    """A cursor for use in pagination"""
    cursor: String!
  }

  type IntegerAnswer implements Answer & Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String

    """The ID of the object"""
    id: ID!
    question: Question!
    value: Int
    meta: GenericScalar!
  }

  type FloatAnswer implements Answer & Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String

    """The ID of the object"""
    id: ID!
    question: Question!
    value: Float
    meta: GenericScalar!
  }

  type DateAnswer implements Answer & Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String

    """The ID of the object"""
    id: ID!
    question: Question!
    value: Date
    meta: GenericScalar!
    date: Date
  }

  """
  The `Date` scalar type represents a Date
  value as specified by
  [iso8601](https://en.wikipedia.org/wiki/ISO_8601).
  """
  scalar Date

  type TableAnswer implements Answer & Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String

    """The ID of the object"""
    id: ID!
    question: Question!
    value: [Document]
    meta: GenericScalar!
    document: Document
  }

  type FileAnswer implements Answer & Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String

    """The ID of the object"""
    id: ID!
    question: Question!
    value: File!
    meta: GenericScalar!
    file: File
  }

  type File implements Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String

    """The ID of the object"""
    id: ID!
    name: String!
    answer: FileAnswer
    uploadUrl: String
    downloadUrl: String
    metadata: GenericScalar
  }

  type CalculatedFloatQuestion implements Question & Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    slug: String!
    label: String!

    """Required expression is only evaluated when question is not hidden."""
    isRequired: QuestionJexl!
    isHidden: QuestionJexl!
    isArchived: Boolean!
    infoText: String
    meta: GenericScalar!
    source: Question
    forms(
      offset: Int = null
      before: String = null
      after: String = null
      first: Int = null
      last: Int = null
      slug: String = null
      name: String = null
      description: String = null
      isPublished: Boolean = null
      isArchived: Boolean = null
      questions: [String] = null
      createdByUser: String = null
      createdByGroup: String = null
      modifiedByUser: String = null
      modifiedByGroup: String = null

      """Only return entries created after the given DateTime (Exclusive)"""
      createdBefore: DateTime = null

      """
      Only return entries created at or before the given DateTime (Inclusive)
      """
      createdAfter: DateTime = null
      metaHasKey: String = null
      metaValue: [JSONValueFilterType] = null
      search: String = null

      """FormOrdering"""
      orderBy: [FormOrdering] = null
      slugs: [String] = null
    ): FormConnection
    calcExpression: String

    """The ID of the object"""
    id: ID!
  }

  type ActionButtonQuestion implements Question & Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    slug: String!
    label: String!

    """Required expression is only evaluated when question is not hidden."""
    isRequired: QuestionJexl!
    isHidden: QuestionJexl!
    isArchived: Boolean!
    infoText: String
    meta: GenericScalar!
    source: Question
    forms(
      offset: Int = null
      before: String = null
      after: String = null
      first: Int = null
      last: Int = null
      slug: String = null
      name: String = null
      description: String = null
      isPublished: Boolean = null
      isArchived: Boolean = null
      questions: [String] = null
      createdByUser: String = null
      createdByGroup: String = null
      modifiedByUser: String = null
      modifiedByGroup: String = null

      """Only return entries created after the given DateTime (Exclusive)"""
      createdBefore: DateTime = null

      """
      Only return entries created at or before the given DateTime (Inclusive)
      """
      createdAfter: DateTime = null
      metaHasKey: String = null
      metaValue: [JSONValueFilterType] = null
      search: String = null

      """FormOrdering"""
      orderBy: [FormOrdering] = null
      slugs: [String] = null
    ): FormConnection

    """The ID of the object"""
    id: ID!
    action: ButtonAction!
    color: ButtonColor!
    validateOnEnter: Boolean!
  }

  """An enumeration."""
  enum ButtonAction {
    COMPLETE
    SKIP
  }

  """An enumeration."""
  enum ButtonColor {
    PRIMARY
    SECONDARY
    DEFAULT
  }

  type SimpleTask implements Task & Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    slug: String!
    name: String!
    description: String
    type: CalumaWorkflowTaskTypeChoices!
    meta: GenericScalar!
    addressGroups: GroupJexl
    controlGroups: GroupJexl
    isArchived: Boolean!

    """Time in seconds task may take to be processed."""
    leadTime: Int
    isMultipleInstance: Boolean!

    """The ID of the object"""
    id: ID!
  }

  """An enumeration."""
  enum CalumaWorkflowTaskTypeChoices {
    """Task which can simply be marked as completed."""
    SIMPLE

    """Task to complete a defined workflow form."""
    COMPLETE_WORKFLOW_FORM

    """Task to complete a defined task form."""
    COMPLETE_TASK_FORM
  }

  type CompleteWorkflowFormTask implements Task & Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    slug: String!
    name: String!
    description: String
    type: CalumaWorkflowTaskTypeChoices!
    meta: GenericScalar!
    addressGroups: GroupJexl
    controlGroups: GroupJexl
    isArchived: Boolean!

    """Time in seconds task may take to be processed."""
    leadTime: Int
    isMultipleInstance: Boolean!

    """The ID of the object"""
    id: ID!
  }

  type CompleteTaskFormTask implements Task & Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    slug: String!
    name: String!
    description: String
    type: CalumaWorkflowTaskTypeChoices!
    meta: GenericScalar!
    addressGroups: GroupJexl
    controlGroups: GroupJexl
    isArchived: Boolean!

    """Time in seconds task may take to be processed."""
    leadTime: Int
    isMultipleInstance: Boolean!
    form: Form!

    """The ID of the object"""
    id: ID!
  }

  type HistoricalStringAnswer implements HistoricalAnswer & Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String

    """The ID of the object"""
    id: ID!
    value: String
    meta: GenericScalar!
    historyQuestionType: String!
    historyUserId: String
    question: Question!
    historyId: UUID!
    historyDate: DateTime!
    historyChangeReason: String
    historyType: String
    selectedOption: SelectedOption
  }

  interface HistoricalAnswer {
    id: ID
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    question: Question!
    meta: GenericScalar!
    historyDate: DateTime!
    historyUserId: String
    historyType: String
  }

  """
  Leverages the internal Python implementation of UUID (uuid.UUID) to provide native UUID objects
  in fields, resolvers and input.
  """
  scalar UUID

  type HistoricalListAnswer implements HistoricalAnswer & Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String

    """The ID of the object"""
    id: ID!
    value: [String]
    meta: GenericScalar!
    historyQuestionType: String!
    historyUserId: String
    question: Question!
    historyId: UUID!
    historyDate: DateTime!
    historyChangeReason: String
    historyType: String
    selectedOptions(before: String = null, after: String = null, first: Int = null, last: Int = null): SelectedOptionConnection
  }

  type HistoricalIntegerAnswer implements HistoricalAnswer & Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String

    """The ID of the object"""
    id: ID!
    value: Int
    meta: GenericScalar!
    historyQuestionType: String!
    historyUserId: String
    question: Question!
    historyId: UUID!
    historyDate: DateTime!
    historyChangeReason: String
    historyType: String
  }

  type HistoricalFloatAnswer implements HistoricalAnswer & Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String

    """The ID of the object"""
    id: ID!
    value: Float
    meta: GenericScalar!
    historyQuestionType: String!
    historyUserId: String
    question: Question!
    historyId: UUID!
    historyDate: DateTime!
    historyChangeReason: String
    historyType: String
  }

  type HistoricalDateAnswer implements HistoricalAnswer & Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String

    """The ID of the object"""
    id: ID!
    value: Date
    meta: GenericScalar!
    date: Date
    historyQuestionType: String!
    historyUserId: String
    question: Question!
    historyId: UUID!
    historyDate: DateTime!
    historyChangeReason: String
    historyType: String
  }

  type HistoricalTableAnswer implements HistoricalAnswer & Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String

    """The ID of the object"""
    id: ID!
    value(asOf: DateTime!): [HistoricalDocument]
    meta: GenericScalar!
    historyQuestionType: String!
    historyUserId: String
    question: Question!
    historyId: UUID!
    historyDate: DateTime!
    historyChangeReason: String
    historyType: String
    document: Document
  }

  type HistoricalDocument implements Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String

    """The ID of the object"""
    id: ID!
    meta: GenericScalar
    historyUserId: String
    form: Form

    """Reference this document has been copied from"""
    source: Document
    historyDate: DateTime!
    historyType: String
    historicalAnswers(asOf: DateTime!, before: String = null, after: String = null, first: Int = null, last: Int = null): HistoricalAnswerConnection
    documentId: UUID
  }

  type HistoricalAnswerConnection {
    """Pagination data for this connection."""
    pageInfo: PageInfo!

    """Contains the nodes in this connection."""
    edges: [HistoricalAnswerEdge]!
    totalCount: Int
  }

  """A Relay edge containing a `HistoricalAnswer` and its cursor."""
  type HistoricalAnswerEdge {
    """The item at the end of the edge"""
    node: HistoricalAnswer

    """A cursor for use in pagination"""
    cursor: String!
  }

  type HistoricalFileAnswer implements HistoricalAnswer & Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String

    """The ID of the object"""
    id: ID!
    value(asOf: DateTime!): HistoricalFile
    meta: GenericScalar!
    historyQuestionType: String!
    historyUserId: String
    question: Question!
    historyId: UUID!
    historyDate: DateTime!
    historyChangeReason: String
    historyType: String
    file: File
  }

  type HistoricalFile implements Node {
    """The ID of the object"""
    id: ID!
    name: String!
    downloadUrl: String
    metadata: GenericScalar
    historicalAnswer: HistoricalFileAnswer
    historyDate: DateTime!
    historyUserId: String
    historyType: String
  }

  type Query {
    documentAsOf(id: ID!, asOf: DateTime!): HistoricalDocument
    allDataSources(before: String = null, after: String = null, first: Int = null, last: Int = null): DataSourceConnection
    dataSource(name: String!, before: String = null, after: String = null, first: Int = null, last: Int = null): DataSourceDataConnection
    allWorkflows(
      offset: Int = null
      before: String = null
      after: String = null
      first: Int = null
      last: Int = null
      metaValue: [JSONValueFilterType] = null
      slug: String = null
      name: String = null
      description: String = null
      isPublished: Boolean = null
      isArchived: Boolean = null

      """WorkflowOrdering"""
      orderBy: [WorkflowOrdering] = null
      filter: [WorkflowFilterSetType] = null
      order: [WorkflowOrderSetType] = null
      createdByUser: String = null
      createdByGroup: String = null
      modifiedByUser: String = null
      modifiedByGroup: String = null

      """Only return entries created after the given DateTime (Exclusive)"""
      createdBefore: DateTime = null

      """
      Only return entries created at or before the given DateTime (Inclusive)
      """
      createdAfter: DateTime = null
      metaHasKey: String = null
      search: String = null
    ): WorkflowConnection
    allTasks(
      offset: Int = null
      before: String = null
      after: String = null
      first: Int = null
      last: Int = null
      metaValue: [JSONValueFilterType] = null
      slug: String = null
      name: String = null
      description: String = null
      type: TaskTypeArgument = null
      isArchived: Boolean = null

      """TaskOrdering"""
      orderBy: [TaskOrdering] = null
      filter: [TaskFilterSetType] = null
      order: [TaskOrderSetType] = null
      createdByUser: String = null
      createdByGroup: String = null
      modifiedByUser: String = null
      modifiedByGroup: String = null

      """Only return entries created after the given DateTime (Exclusive)"""
      createdBefore: DateTime = null

      """
      Only return entries created at or before the given DateTime (Inclusive)
      """
      createdAfter: DateTime = null
      metaHasKey: String = null
      search: String = null
    ): TaskConnection
    allCases(
      offset: Int = null
      before: String = null
      after: String = null
      first: Int = null
      last: Int = null
      metaValue: [JSONValueFilterType] = null
      workflow: ID = null

      """CaseOrdering"""
      orderBy: [CaseOrdering] = null
      filter: [CaseFilterSetType] = null
      order: [CaseOrderSetType] = null
      createdByUser: String = null
      createdByGroup: String = null
      modifiedByUser: String = null
      modifiedByGroup: String = null

      """Only return entries created after the given DateTime (Exclusive)"""
      createdBefore: DateTime = null

      """
      Only return entries created at or before the given DateTime (Inclusive)
      """
      createdAfter: DateTime = null
      metaHasKey: String = null
      id: ID = null
      documentForm: String = null
      documentForms: [String] = null
      hasAnswer: [HasAnswerFilterType] = null
      workItemDocumentHasAnswer: [HasAnswerFilterType] = null
      rootCase: ID = null
      searchAnswers: [SearchAnswersFilterType] = null
      status: [[CaseStatusArgument]] = null

      """
      Expects a question slug. If the slug is prefixed with a hyphen, the order will be reversed

      For file questions, the filename is used for sorting.

      Table questions are not supported at this time.
      """
      orderByQuestionAnswerValue: String = null
    ): CaseConnection
    allWorkItems(
      offset: Int = null
      before: String = null
      after: String = null
      first: Int = null
      last: Int = null
      metaValue: [JSONValueFilterType] = null
      status: WorkItemStatusArgument = null

      """WorkItemOrdering"""
      orderBy: [WorkItemOrdering] = null
      filter: [WorkItemFilterSetType] = null
      order: [WorkItemOrderSetType] = null
      documentHasAnswer: [HasAnswerFilterType] = null
      caseDocumentHasAnswer: [HasAnswerFilterType] = null
      caseMetaValue: [JSONValueFilterType] = null
      rootCaseMetaValue: [JSONValueFilterType] = null
      name: String = null
      task: ID = null
      tasks: [String] = null
      case: ID = null
      createdAt: DateTime = null
      closedAt: DateTime = null
      modifiedAt: DateTime = null
      deadline: DateTime = null
      hasDeadline: Boolean = null
      caseFamily: ID = null
      createdByUser: String = null
      createdByGroup: String = null
      modifiedByUser: String = null
      modifiedByGroup: String = null

      """Only return entries created after the given DateTime (Exclusive)"""
      createdBefore: DateTime = null

      """
      Only return entries created at or before the given DateTime (Inclusive)
      """
      createdAfter: DateTime = null
      metaHasKey: String = null
      id: ID = null
      addressedGroups: [String] = null
      controllingGroups: [String] = null
      assignedUsers: [String] = null
    ): WorkItemConnection
    allForms(
      offset: Int = null
      before: String = null
      after: String = null
      first: Int = null
      last: Int = null
      metaValue: [JSONValueFilterType] = null

      """FormOrdering"""
      orderBy: [FormOrdering] = null
      slug: String = null
      name: String = null
      description: String = null
      isPublished: Boolean = null
      isArchived: Boolean = null
      questions: [String] = null
      filter: [FormFilterSetType] = null
      order: [FormOrderSetType] = null
      createdByUser: String = null
      createdByGroup: String = null
      modifiedByUser: String = null
      modifiedByGroup: String = null

      """Only return entries created after the given DateTime (Exclusive)"""
      createdBefore: DateTime = null

      """
      Only return entries created at or before the given DateTime (Inclusive)
      """
      createdAfter: DateTime = null
      metaHasKey: String = null
      search: String = null
      slugs: [String] = null
    ): FormConnection
    allQuestions(
      offset: Int = null
      before: String = null
      after: String = null
      first: Int = null
      last: Int = null
      metaValue: [JSONValueFilterType] = null

      """QuestionOrdering"""
      orderBy: [QuestionOrdering] = null
      slug: String = null
      label: String = null
      isRequired: String = null
      isHidden: String = null
      isArchived: Boolean = null
      subForm: ID = null
      rowForm: ID = null
      filter: [QuestionFilterSetType] = null
      order: [QuestionOrderSetType] = null
      createdByUser: String = null
      createdByGroup: String = null
      modifiedByUser: String = null
      modifiedByGroup: String = null

      """Only return entries created after the given DateTime (Exclusive)"""
      createdBefore: DateTime = null

      """
      Only return entries created at or before the given DateTime (Inclusive)
      """
      createdAfter: DateTime = null
      metaHasKey: String = null
      excludeForms: [ID] = null
      search: String = null
      slugs: [String] = null
    ): QuestionConnection
    allDocuments(
      offset: Int = null
      before: String = null
      after: String = null
      first: Int = null
      last: Int = null
      metaValue: [JSONValueFilterType] = null
      form: ID = null
      forms: [ID] = null
      search: String = null
      id: ID = null

      """DocumentOrdering"""
      orderBy: [DocumentOrdering] = null
      filter: [DocumentFilterSetType] = null
      order: [DocumentOrderSetType] = null
      createdByUser: String = null
      createdByGroup: String = null
      modifiedByUser: String = null
      modifiedByGroup: String = null

      """Only return entries created after the given DateTime (Exclusive)"""
      createdBefore: DateTime = null

      """
      Only return entries created at or before the given DateTime (Inclusive)
      """
      createdAfter: DateTime = null
      metaHasKey: String = null
      rootDocument: ID = null
      hasAnswer: [HasAnswerFilterType] = null
      searchAnswers: [SearchAnswersFilterType] = null
    ): DocumentConnection
    allFormatValidators(before: String = null, after: String = null, first: Int = null, last: Int = null): FormatValidatorConnection
    allUsedDynamicOptions(
      offset: Int = null
      before: String = null
      after: String = null
      first: Int = null
      last: Int = null
      question: ID = null
      document: ID = null
      filter: [DynamicOptionFilterSetType] = null
      createdByUser: String = null
      createdByGroup: String = null
      modifiedByUser: String = null
      modifiedByGroup: String = null

      """Only return entries created after the given DateTime (Exclusive)"""
      createdBefore: DateTime = null

      """
      Only return entries created at or before the given DateTime (Inclusive)
      """
      createdAfter: DateTime = null
    ): DynamicOptionConnection
    documentValidity(id: ID!, before: String = null, after: String = null, first: Int = null, last: Int = null): DocumentValidityConnection
    node(
      """The ID of the object"""
      id: ID!
    ): Node
    _debug: DjangoDebug
  }

  type DataSourceConnection {
    """Pagination data for this connection."""
    pageInfo: PageInfo!

    """Contains the nodes in this connection."""
    edges: [DataSourceEdge]!
    totalCount: Int
  }

  """A Relay edge containing a `DataSource` and its cursor."""
  type DataSourceEdge {
    """The item at the end of the edge"""
    node: DataSource

    """A cursor for use in pagination"""
    cursor: String!
  }

  type DataSource {
    info: String
    name: String!
  }

  type WorkflowConnection {
    """Pagination data for this connection."""
    pageInfo: PageInfo!

    """Contains the nodes in this connection."""
    edges: [WorkflowEdge]!
    totalCount: Int
  }

  """A Relay edge containing a `Workflow` and its cursor."""
  type WorkflowEdge {
    """The item at the end of the edge"""
    node: Workflow

    """A cursor for use in pagination"""
    cursor: String!
  }

  """An enumeration."""
  enum WorkflowOrdering {
    """Name"""
    NAME_ASC

    """Name (descending)"""
    NAME_DESC

    """Description"""
    DESCRIPTION_ASC

    """Description (descending)"""
    DESCRIPTION_DESC

    """Created at"""
    CREATED_AT_ASC

    """Created at (descending)"""
    CREATED_AT_DESC

    """Modified at"""
    MODIFIED_AT_ASC

    """Modified at (descending)"""
    MODIFIED_AT_DESC

    """Created by user"""
    CREATED_BY_USER_ASC

    """Created by user (descending)"""
    CREATED_BY_USER_DESC

    """Created by group"""
    CREATED_BY_GROUP_ASC

    """Created by group (descending)"""
    CREATED_BY_GROUP_DESC

    """Modified by user"""
    MODIFIED_BY_USER_ASC

    """Modified by user (descending)"""
    MODIFIED_BY_USER_DESC

    """Modified by group"""
    MODIFIED_BY_GROUP_ASC

    """Modified by group (descending)"""
    MODIFIED_BY_GROUP_DESC

    """Meta test-key"""
    META_TEST_KEY_ASC

    """Meta test-key (descending)"""
    META_TEST_KEY_DESC

    """Meta foobar"""
    META_FOOBAR_ASC

    """Meta foobar (descending)"""
    META_FOOBAR_DESC
  }

  input WorkflowFilterSetType {
    slug: String
    name: String
    description: String
    isPublished: Boolean
    isArchived: Boolean
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    createdBefore: DateTime
    createdAfter: DateTime
    metaHasKey: String
    metaValue: [JSONValueFilterType]
    search: String

    """"""
    orderBy: [WorkflowOrdering]
    invert: Boolean
  }

  input WorkflowOrderSetType {
    meta: String
    attribute: SortableWorkflowAttributes
    direction: AscDesc
  }

  enum SortableWorkflowAttributes {
    ALLOW_ALL_FORMS
    CREATED_BY_GROUP
    CREATED_BY_USER
    DESCRIPTION
    IS_ARCHIVED
    IS_PUBLISHED
    NAME
    SLUG
  }

  type TaskConnection {
    """Pagination data for this connection."""
    pageInfo: PageInfo!

    """Contains the nodes in this connection."""
    edges: [TaskEdge]!
    totalCount: Int
  }

  """A Relay edge containing a `Task` and its cursor."""
  type TaskEdge {
    """The item at the end of the edge"""
    node: Task

    """A cursor for use in pagination"""
    cursor: String!
  }

  """An enumeration."""
  enum TaskTypeArgument {
    """Task which can simply be marked as completed."""
    SIMPLE

    """Task to complete a defined workflow form."""
    COMPLETE_WORKFLOW_FORM

    """Task to complete a defined task form."""
    COMPLETE_TASK_FORM
  }

  """An enumeration."""
  enum TaskOrdering {
    """Name"""
    NAME_ASC

    """Name (descending)"""
    NAME_DESC

    """Description"""
    DESCRIPTION_ASC

    """Description (descending)"""
    DESCRIPTION_DESC

    """Type"""
    TYPE_ASC

    """Type (descending)"""
    TYPE_DESC

    """Created at"""
    CREATED_AT_ASC

    """Created at (descending)"""
    CREATED_AT_DESC

    """Modified at"""
    MODIFIED_AT_ASC

    """Modified at (descending)"""
    MODIFIED_AT_DESC

    """Created by user"""
    CREATED_BY_USER_ASC

    """Created by user (descending)"""
    CREATED_BY_USER_DESC

    """Created by group"""
    CREATED_BY_GROUP_ASC

    """Created by group (descending)"""
    CREATED_BY_GROUP_DESC

    """Modified by user"""
    MODIFIED_BY_USER_ASC

    """Modified by user (descending)"""
    MODIFIED_BY_USER_DESC

    """Modified by group"""
    MODIFIED_BY_GROUP_ASC

    """Modified by group (descending)"""
    MODIFIED_BY_GROUP_DESC

    """Meta test-key"""
    META_TEST_KEY_ASC

    """Meta test-key (descending)"""
    META_TEST_KEY_DESC

    """Meta foobar"""
    META_FOOBAR_ASC

    """Meta foobar (descending)"""
    META_FOOBAR_DESC
  }

  input TaskFilterSetType {
    slug: String
    name: String
    description: String

    """"""
    type: Type
    isArchived: Boolean
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    createdBefore: DateTime
    createdAfter: DateTime
    metaHasKey: String
    metaValue: [JSONValueFilterType]
    search: String

    """"""
    orderBy: [TaskOrdering]
    invert: Boolean
  }

  """An enumeration."""
  enum Type {
    """Task which can simply be marked as completed."""
    SIMPLE

    """Task to complete a defined workflow form."""
    COMPLETE_WORKFLOW_FORM

    """Task to complete a defined task form."""
    COMPLETE_TASK_FORM
  }

  input TaskOrderSetType {
    meta: String
    attribute: SortableTaskAttributes
    direction: AscDesc
  }

  enum SortableTaskAttributes {
    ALLOW_ALL_FORMS
    LEAD_TIME
    TYPE
    CREATED_BY_GROUP
    CREATED_BY_USER
    DESCRIPTION
    IS_ARCHIVED
    IS_PUBLISHED
    NAME
    SLUG
  }

  type CaseConnection {
    """Pagination data for this connection."""
    pageInfo: PageInfo!

    """Contains the nodes in this connection."""
    edges: [CaseEdge]!
    totalCount: Int
  }

  """A Relay edge containing a `Case` and its cursor."""
  type CaseEdge {
    node: Case
    cursor: String!
  }

  """An enumeration."""
  enum CaseOrdering {
    """Status"""
    STATUS_ASC

    """Status (descending)"""
    STATUS_DESC

    """Created at"""
    CREATED_AT_ASC

    """Created at (descending)"""
    CREATED_AT_DESC

    """Modified at"""
    MODIFIED_AT_ASC

    """Modified at (descending)"""
    MODIFIED_AT_DESC

    """Created by user"""
    CREATED_BY_USER_ASC

    """Created by user (descending)"""
    CREATED_BY_USER_DESC

    """Created by group"""
    CREATED_BY_GROUP_ASC

    """Created by group (descending)"""
    CREATED_BY_GROUP_DESC

    """Modified by user"""
    MODIFIED_BY_USER_ASC

    """Modified by user (descending)"""
    MODIFIED_BY_USER_DESC

    """Modified by group"""
    MODIFIED_BY_GROUP_ASC

    """Modified by group (descending)"""
    MODIFIED_BY_GROUP_DESC

    """Meta test-key"""
    META_TEST_KEY_ASC

    """Meta test-key (descending)"""
    META_TEST_KEY_DESC

    """Meta foobar"""
    META_FOOBAR_ASC

    """Meta foobar (descending)"""
    META_FOOBAR_DESC
  }

  input CaseFilterSetType {
    workflow: ID
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    createdBefore: DateTime
    createdAfter: DateTime
    metaHasKey: String
    metaValue: [JSONValueFilterType]
    id: ID

    """"""
    orderBy: [CaseOrdering]
    documentForm: String
    documentForms: [String]
    hasAnswer: [HasAnswerFilterType]
    workItemDocumentHasAnswer: [HasAnswerFilterType]
    rootCase: ID
    searchAnswers: [SearchAnswersFilterType]
    status: [CaseStatusArgument]
    orderByQuestionAnswerValue: String
    invert: Boolean
  }

  """Lookup type to search in answers."""
  input SearchAnswersFilterType {
    questions: [ID]
    value: GenericScalar!
    lookup: SearchLookupMode
  }

  enum SearchLookupMode {
    STARTSWITH
    CONTAINS
    TEXT
  }

  """An enumeration."""
  enum CaseStatusArgument {
    """Case is running and work items need to be completed."""
    RUNNING

    """Case is done."""
    COMPLETED

    """Case is canceled."""
    CANCELED

    """Case is suspended."""
    SUSPENDED
  }

  input CaseOrderSetType {
    meta: String
    attribute: SortableCaseAttributes
    documentAnswer: String
    direction: AscDesc
  }

  enum CaseOrdering {
    STATUS_ASC
    STATUS_DESC
    CREATED_AT_ASC
    CREATED_AT_DESC
    MODIFIED_AT_ASC
    MODIFIED_AT_DESC
    CREATED_BY_USER_ASC
    CREATED_BY_USER_DESC
    CREATED_BY_GROUP_ASC
    CREATED_BY_GROUP_DESC
    MODIFIED_BY_USER_ASC
    MODIFIED_BY_USER_DESC
    MODIFIED_BY_GROUP_ASC
    MODIFIED_BY_GROUP_DESC
    META_TEST_KEY_ASC
    META_TEST_KEY_DESC
    META_FOOBAR_ASC
    META_FOOBAR_DESC
  }

  enum CaseStatus {
    RUNNING
    COMPLETED
    CANCELED
    SUSPENDED
  }

  enum CaseStatusArgument {
    RUNNING
    COMPLETED
    CANCELED
    SUSPENDED
  }

  type ChoiceQuestion implements Question, Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    slug: String!
    label: String!
    isRequired: QuestionJexl!
    isHidden: QuestionJexl!
    isArchived: Boolean!
    infoText: String
    hintText: String
    meta: GenericScalar!
    source: Question
    defaultAnswer: StringAnswer
    forms(before: String, after: String, first: Int, last: Int, metaValue: [JSONValueFilterType], orderBy: [FormOrdering], slug: String, name: String, description: String, isPublished: Boolean, isArchived: Boolean, questions: [String], createdByUser: String, createdByGroup: String, modifiedByUser: String, modifiedByGroup: String, createdBefore: DateTime, createdAfter: DateTime, metaHasKey: String, search: String, slugs: [String]): FormConnection
    options(before: String, after: String, first: Int, last: Int, metaValue: [JSONValueFilterType], slug: String, label: String, isArchived: Boolean, createdByUser: String, createdByGroup: String, modifiedByUser: String, modifiedByGroup: String, createdBefore: DateTime, createdAfter: DateTime, metaHasKey: String, search: String, orderBy: [OptionOrdering]): OptionConnection
    id: ID!
  }

  type CompleteTaskFormTask implements Task, Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    slug: String!
    name: String!
    description: String
    type: TaskType!
    meta: GenericScalar!
    addressGroups: GroupJexl
    controlGroups: GroupJexl
    isArchived: Boolean!
    leadTime: Int
    isMultipleInstance: Boolean!
    form: Form!
    id: ID!
  }

  input CompleteWorkItemInput {
    id: ID!
    context: JSONString
    clientMutationId: String
  }

  type CompleteWorkItemPayload {
    workItem: WorkItem
    clientMutationId: String
  }

  type CompleteWorkflowFormTask implements Task, Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    slug: String!
    name: String!
    description: String
    type: TaskType!
    meta: GenericScalar!
    addressGroups: GroupJexl
    controlGroups: GroupJexl
    isArchived: Boolean!
    leadTime: Int
    isMultipleInstance: Boolean!
    id: ID!
  }

  input CopyDocumentInput {
    source: ID!
    clientMutationId: String
  }

  type CopyDocumentPayload {
    document: Document
    clientMutationId: String
  }

  input CopyFormInput {
    slug: String!
    name: String!
    description: String
    source: ID!
    isPublished: Boolean
    clientMutationId: String
  }

  type CopyFormPayload {
    form: Form
    clientMutationId: String
  }

  input CopyOptionInput {
    slug: String!
    label: String!
    source: ID!
    clientMutationId: String
  }

  type CopyOptionPayload {
    option: Option
    clientMutationId: String
  }

  input CopyQuestionInput {
    slug: String!
    label: String!
    source: ID!
    clientMutationId: String
  }

  type CopyQuestionPayload {
    question: Question
    clientMutationId: String
  }

  input CreateWorkItemInput {
    case: ID!
    multipleInstanceTask: ID!
    name: String
    description: String
    assignedUsers: [String]
    addressedGroups: [String]
    controllingGroups: [String]
    deadline: DateTime
    meta: JSONString
    context: JSONString
    clientMutationId: String
  }

  type CreateWorkItemPayload {
    workItem: WorkItem
    clientMutationId: String
  }

  type DataSource {
    info: String
    name: String!
  }

  type DataSourceConnection {
    pageInfo: PageInfo!
    edges: [DataSourceEdge]!
    totalCount: Int
  }

  type DataSourceData {
    label: String!
    slug: String!
  }

  type DataSourceDataConnection {
    pageInfo: PageInfo!
    edges: [DataSourceDataEdge]!
    totalCount: Int
  }

  type DataSourceDataEdge {
    node: DataSourceData
    cursor: String!
  }

  type DataSourceEdge {
    node: DataSource
    cursor: String!
  }

  scalar Date

  type DateAnswer implements Answer, Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    id: ID!
    question: Question!
    value: Date
    meta: GenericScalar!
    date: Date
  }

  type DateQuestion implements Question, Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    slug: String!
    label: String!
    isRequired: QuestionJexl!
    isHidden: QuestionJexl!
    isArchived: Boolean!
    infoText: String
    hintText: String
    meta: GenericScalar!
    source: Question
    defaultAnswer: DateAnswer
    forms(before: String, after: String, first: Int, last: Int, metaValue: [JSONValueFilterType], orderBy: [FormOrdering], slug: String, name: String, description: String, isPublished: Boolean, isArchived: Boolean, questions: [String], createdByUser: String, createdByGroup: String, modifiedByUser: String, modifiedByGroup: String, createdBefore: DateTime, createdAfter: DateTime, metaHasKey: String, search: String, slugs: [String]): FormConnection
    id: ID!
  }

  scalar DateTime

  type DjangoDebug {
    sql: [DjangoDebugSQL]
  }

  type DjangoDebugSQL {
    vendor: String!
    alias: String!
    sql: String
    duration: Float!
    rawSql: String!
    params: String!
    startTime: Float!
    stopTime: Float!
    isSlow: Boolean!
    isSelect: Boolean!
    transId: String
    transStatus: String
    isoLevel: String
    encoding: String
  }

  type Document implements Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    id: ID!
    form: Form!
    source: Document
    meta: GenericScalar
    copies(before: String, after: String, first: Int, last: Int): DocumentConnection!
    answers(before: String, after: String, first: Int, last: Int, metaValue: [JSONValueFilterType], question: ID, search: String, orderBy: [AnswerOrdering], filter: [AnswerFilterSetType], order: [AnswerOrderSetType], createdByUser: String, createdByGroup: String, modifiedByUser: String, modifiedByGroup: String, createdBefore: DateTime, createdAfter: DateTime, metaHasKey: String, questions: [ID], visibleInContext: Boolean): AnswerConnection
    case: Case
    workItem: WorkItem
    modifiedContentAt: DateTime
    modifiedContentByUser: String
    modifiedContentByGroup: String
  }

  type DocumentConnection {
    pageInfo: PageInfo!
    edges: [DocumentEdge]!
    totalCount: Int
  }

  type DocumentEdge {
    node: Document
    cursor: String!
  }

  input DocumentFilterSetType {
    form: ID
    forms: [ID]
    search: String
    id: ID
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    createdBefore: DateTime
    createdAfter: DateTime
    metaHasKey: String
    metaValue: [JSONValueFilterType]
    orderBy: [DocumentOrdering]
    rootDocument: ID
    hasAnswer: [HasAnswerFilterType]
    searchAnswers: [SearchAnswersFilterType]
    invert: Boolean
  }

  input DocumentOrderSetType {
    meta: String
    answerValue: String
    attribute: SortableDocumentAttributes
    direction: AscDesc
  }

  enum DocumentOrdering {
    CREATED_AT_ASC
    CREATED_AT_DESC
    MODIFIED_AT_ASC
    MODIFIED_AT_DESC
    CREATED_BY_USER_ASC
    CREATED_BY_USER_DESC
    CREATED_BY_GROUP_ASC
    CREATED_BY_GROUP_DESC
    MODIFIED_BY_USER_ASC
    MODIFIED_BY_USER_DESC
    MODIFIED_BY_GROUP_ASC
    MODIFIED_BY_GROUP_DESC
    META_TEST_KEY_ASC
    META_TEST_KEY_DESC
    META_FOOBAR_ASC
    META_FOOBAR_DESC
  }

  type DocumentValidityConnection {
    pageInfo: PageInfo!
    edges: [DocumentValidityEdge]!
    totalCount: Int
  }

  type DocumentValidityEdge {
    node: ValidationResult
    cursor: String!
  }

  type DynamicChoiceQuestion implements Question, DynamicQuestion, Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    slug: String!
    label: String!
    isRequired: QuestionJexl!
    isHidden: QuestionJexl!
    isArchived: Boolean!
    infoText: String
    hintText: String
    meta: GenericScalar!
    source: Question
    forms(before: String, after: String, first: Int, last: Int, metaValue: [JSONValueFilterType], orderBy: [FormOrdering], slug: String, name: String, description: String, isPublished: Boolean, isArchived: Boolean, questions: [String], createdByUser: String, createdByGroup: String, modifiedByUser: String, modifiedByGroup: String, createdBefore: DateTime, createdAfter: DateTime, metaHasKey: String, search: String, slugs: [String]): FormConnection
    options(before: String, after: String, first: Int, last: Int): DataSourceDataConnection
    dataSource: String!
    id: ID!
  }

  type DynamicMultipleChoiceQuestion implements Question, DynamicQuestion, Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    slug: String!
    label: String!
    isRequired: QuestionJexl!
    isHidden: QuestionJexl!
    isArchived: Boolean!
    infoText: String
    hintText: String
    meta: GenericScalar!
    source: Question
    forms(before: String, after: String, first: Int, last: Int, metaValue: [JSONValueFilterType], orderBy: [FormOrdering], slug: String, name: String, description: String, isPublished: Boolean, isArchived: Boolean, questions: [String], createdByUser: String, createdByGroup: String, modifiedByUser: String, modifiedByGroup: String, createdBefore: DateTime, createdAfter: DateTime, metaHasKey: String, search: String, slugs: [String]): FormConnection
    options(before: String, after: String, first: Int, last: Int): DataSourceDataConnection
    dataSource: String!
    id: ID!
  }

  type DynamicOption implements Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    id: ID!
    slug: String!
    label: String!
    document: Document!
    question: DynamicQuestion!
  }

  type DynamicOptionConnection {
    pageInfo: PageInfo!
    edges: [DynamicOptionEdge]!
    totalCount: Int
  }

  type DynamicOptionEdge {
    node: DynamicOption
    cursor: String!
  }

  input DynamicOptionFilterSetType {
    question: ID
    document: ID
    invert: Boolean
  }

  interface DynamicQuestion {
    options(before: String, after: String, first: Int, last: Int): DataSourceDataConnection
    dataSource: String!
    hintText: String
  }

  type File implements Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    id: ID!
    name: String!
    answer: FileAnswer
    uploadUrl: String
    downloadUrl: String
    metadata: GenericScalar
  }

  type FileAnswer implements Answer, Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    id: ID!
    question: Question!
    value: File!
    meta: GenericScalar!
    file: File
  }

  type FileQuestion implements Question, Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    slug: String!
    label: String!
    isRequired: QuestionJexl!
    isHidden: QuestionJexl!
    isArchived: Boolean!
    infoText: String
    hintText: String
    meta: GenericScalar!
    source: Question
    forms(before: String, after: String, first: Int, last: Int, metaValue: [JSONValueFilterType], orderBy: [FormOrdering], slug: String, name: String, description: String, isPublished: Boolean, isArchived: Boolean, questions: [String], createdByUser: String, createdByGroup: String, modifiedByUser: String, modifiedByGroup: String, createdBefore: DateTime, createdAfter: DateTime, metaHasKey: String, search: String, slugs: [String]): FormConnection
    id: ID!
  }

  type FloatAnswer implements Answer, Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    id: ID!
    question: Question!
    value: Float
    meta: GenericScalar!
  }

  type FloatQuestion implements Question, Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    slug: String!
    label: String!
    isRequired: QuestionJexl!
    isHidden: QuestionJexl!
    isArchived: Boolean!
    placeholder: String
    infoText: String
    hintText: String
    meta: GenericScalar!
    source: Question
    defaultAnswer: FloatAnswer
    forms(before: String, after: String, first: Int, last: Int, metaValue: [JSONValueFilterType], orderBy: [FormOrdering], slug: String, name: String, description: String, isPublished: Boolean, isArchived: Boolean, questions: [String], createdByUser: String, createdByGroup: String, modifiedByUser: String, modifiedByGroup: String, createdBefore: DateTime, createdAfter: DateTime, metaHasKey: String, search: String, slugs: [String]): FormConnection
    id: ID!
    minValue: Float
    maxValue: Float
  }

  type Flow implements Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    id: ID!
    next: FlowJexl!
    tasks: [Task]!
  }

  type FlowConnection {
    pageInfo: PageInfo!
    edges: [FlowEdge]!
    totalCount: Int
  }

  type FlowEdge {
    node: Flow
    cursor: String!
  }

  input FlowFilterSetType {
    task: ID
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    createdBefore: DateTime
    createdAfter: DateTime
    invert: Boolean
  }

  scalar FlowJexl

  type Form implements Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    slug: String!
    name: String!
    description: String
    meta: GenericScalar
    isPublished: Boolean!
    isArchived: Boolean!
    questions(before: String, after: String, first: Int, last: Int, metaValue: [JSONValueFilterType], slug: String, label: String, isRequired: String, isHidden: String, isArchived: Boolean, subForm: ID, rowForm: ID, createdByUser: String, createdByGroup: String, modifiedByUser: String, modifiedByGroup: String, createdBefore: DateTime, createdAfter: DateTime, metaHasKey: String, excludeForms: [ID], search: String, orderBy: [QuestionOrdering], slugs: [String]): QuestionConnection
    source: Form
    documents(before: String, after: String, first: Int, last: Int): DocumentConnection!
    id: ID!
  }

  type FormConnection {
    pageInfo: PageInfo!
    edges: [FormEdge]!
    totalCount: Int
  }

  type FormEdge {
    node: Form
    cursor: String!
  }

  input FormFilterSetType {
  enum SortableCaseAttributes {
    ALLOW_ALL_FORMS
    CREATED_BY_GROUP
    CREATED_BY_USER
    DESCRIPTION
    IS_ARCHIVED
    IS_PUBLISHED
    NAME
    STATUS
    SLUG
  }

  input FormFilterSetType {
    """"""
    orderBy: [FormOrdering]
    slug: String
    name: String
    description: String
    isPublished: Boolean
    isArchived: Boolean
    questions: [String]
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    createdBefore: DateTime
    createdAfter: DateTime
    metaHasKey: String
    metaValue: [JSONValueFilterType]
    search: String
    slugs: [String]
    invert: Boolean
  }

  input FormOrderSetType {
    meta: String
    attribute: SortableFormAttributes
    direction: AscDesc
  }

  enum SortableFormAttributes {
    CREATED_AT
    MODIFIED_AT
    CREATED_BY_USER
    CREATED_BY_GROUP
    MODIFIED_BY_USER
    MODIFIED_BY_GROUP
    SLUG
    NAME
    DESCRIPTION
    IS_PUBLISHED
    IS_ARCHIVED
  }

  input QuestionFilterSetType {
    """"""
    orderBy: [QuestionOrdering]
    slug: String
    label: String
    isRequired: String
    isHidden: String
    isArchived: Boolean
    subForm: ID
    rowForm: ID
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    createdBefore: DateTime
    createdAfter: DateTime
    metaHasKey: String
    metaValue: [JSONValueFilterType]
    excludeForms: [ID]
    search: String
    slugs: [String]
    invert: Boolean
  }

  input QuestionOrderSetType {
    meta: String
    attribute: SortableQuestionAttributes
    direction: AscDesc
  }

  enum SortableQuestionAttributes {
    CREATED_AT
    MODIFIED_AT
    CREATED_BY_USER
    CREATED_BY_GROUP
    MODIFIED_BY_USER
    MODIFIED_BY_GROUP
    SLUG
    LABEL
    TYPE
    IS_REQUIRED
    IS_HIDDEN
    IS_ARCHIVED
    PLACEHOLDER
    INFO_TEXT
    CALC_EXPRESSION
  }

  """An enumeration."""
  enum DocumentOrdering {
    """Created at"""
    CREATED_AT_ASC

    """Created at (descending)"""
    CREATED_AT_DESC

    """Modified at"""
    MODIFIED_AT_ASC

    """Modified at (descending)"""
    MODIFIED_AT_DESC

    """Created by user"""
    CREATED_BY_USER_ASC

    """Created by user (descending)"""
    CREATED_BY_USER_DESC

    """Created by group"""
    CREATED_BY_GROUP_ASC

    """Created by group (descending)"""
    CREATED_BY_GROUP_DESC

    """Modified by user"""
    MODIFIED_BY_USER_ASC

    """Modified by user (descending)"""
    MODIFIED_BY_USER_DESC

    """Modified by group"""
    MODIFIED_BY_GROUP_ASC

    """Modified by group (descending)"""
    MODIFIED_BY_GROUP_DESC

    """Meta test-key"""
    META_TEST_KEY_ASC

    """Meta test-key (descending)"""
    META_TEST_KEY_DESC

    """Meta foobar"""
    META_FOOBAR_ASC

    """Meta foobar (descending)"""
    META_FOOBAR_DESC
  }

  input DocumentFilterSetType {
    form: ID
    forms: [ID]
    search: String
    id: ID
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    createdBefore: DateTime
    createdAfter: DateTime
    metaHasKey: String
    metaValue: [JSONValueFilterType]

    """"""
    orderBy: [DocumentOrdering]
    rootDocument: ID
    hasAnswer: [HasAnswerFilterType]
    searchAnswers: [SearchAnswersFilterType]
    invert: Boolean
  }

  input DocumentOrderSetType {
    meta: String
    answerValue: String
    attribute: SortableDocumentAttributes
    direction: AscDesc
  }

  enum SortableDocumentAttributes {
    CREATED_AT
    MODIFIED_AT
    CREATED_BY_USER
    CREATED_BY_GROUP
    MODIFIED_BY_USER
    MODIFIED_BY_GROUP
    FORM
    SOURCE
  }

  type DynamicOptionConnection {
    """Pagination data for this connection."""
    pageInfo: PageInfo!

    """Contains the nodes in this connection."""
    edges: [DynamicOptionEdge]!
    totalCount: Int
  }

  """A Relay edge containing a `DynamicOption` and its cursor."""
  type DynamicOptionEdge {
    """The item at the end of the edge"""
    node: DynamicOption

    """A cursor for use in pagination"""
    cursor: String!
  }

  type DynamicOption implements Node {
  enum FormOrdering {
    NAME_ASC
    NAME_DESC
    CREATED_AT_ASC
    CREATED_AT_DESC
    MODIFIED_AT_ASC
    MODIFIED_AT_DESC
    CREATED_BY_USER_ASC
    CREATED_BY_USER_DESC
    CREATED_BY_GROUP_ASC
    CREATED_BY_GROUP_DESC
    MODIFIED_BY_USER_ASC
    MODIFIED_BY_USER_DESC
    MODIFIED_BY_GROUP_ASC
    MODIFIED_BY_GROUP_DESC
    META_TEST_KEY_ASC
    META_TEST_KEY_DESC
    META_FOOBAR_ASC
    META_FOOBAR_DESC
  }

  type FormQuestion implements Question, Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    slug: String!
    label: String!
    isRequired: QuestionJexl!
    isHidden: QuestionJexl!
    isArchived: Boolean!
    infoText: String
    meta: GenericScalar!
    source: Question
    forms(before: String, after: String, first: Int, last: Int, metaValue: [JSONValueFilterType], orderBy: [FormOrdering], slug: String, name: String, description: String, isPublished: Boolean, isArchived: Boolean, questions: [String], createdByUser: String, createdByGroup: String, modifiedByUser: String, modifiedByGroup: String, createdBefore: DateTime, createdAfter: DateTime, metaHasKey: String, search: String, slugs: [String]): FormConnection
    subForm: Form
    id: ID!
  }

  type FormatValidator {
    slug: String!
    name: String!
    regex: String!
    errorMsg: String!
  }

  type FormatValidatorConnection {
    pageInfo: PageInfo!
    edges: [FormatValidatorEdge]!
    totalCount: Int
  }

  type FormatValidatorEdge {
    node: FormatValidator
    cursor: String!
  }

  scalar GenericScalar

  scalar GroupJexl

  input HasAnswerFilterType {
    question: ID!
    value: GenericScalar
    lookup: AnswerLookupMode
    hierarchy: AnswerHierarchyMode
  }

  interface HistoricalAnswer {
    id: ID
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    question: Question!
    meta: GenericScalar!
    historyDate: DateTime!
    historyUserId: String
    historyType: String
  }

  type HistoricalAnswerConnection {
    pageInfo: PageInfo!
    edges: [HistoricalAnswerEdge]!
    totalCount: Int
  }

  type HistoricalAnswerEdge {
    node: HistoricalAnswer
    cursor: String!
  }

  enum HistoricalAnswerHistoryQuestionType {
    MULTIPLE_CHOICE
    INTEGER
    FLOAT
    DATE
    CHOICE
    TEXTAREA
    TEXT
    TABLE
    FORM
    FILE
    DYNAMIC_CHOICE
    DYNAMIC_MULTIPLE_CHOICE
    STATIC
    CALCULATED_FLOAT
    ACTION_BUTTON
  }

  type HistoricalDateAnswer implements HistoricalAnswer, Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    historyQuestionType: HistoricalAnswerHistoryQuestionType!
    id: ID!
    value: Date
    meta: GenericScalar!
    historyUserId: String
    question: Question!
    historyId: UUID!
    historyDate: DateTime!
    historyChangeReason: String
    historyType: String
    date: Date
  }

  type HistoricalDocument implements Node {
    historyUserId: String
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    id: ID!
    meta: GenericScalar
    form: Form
    source: Document
    historyDate: DateTime!
    historyType: String
    historicalAnswers(asOf: DateTime!, before: String, after: String, first: Int, last: Int): HistoricalAnswerConnection
    documentId: UUID
  }

  type HistoricalFile implements Node {
    id: ID!
    name: String!
    downloadUrl: String
    metadata: GenericScalar
    historicalAnswer: HistoricalFileAnswer
    historyDate: DateTime!
    historyUserId: String
    historyType: String
  }

  type HistoricalFileAnswer implements HistoricalAnswer, Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    historyQuestionType: HistoricalAnswerHistoryQuestionType!
    id: ID!
    value(asOf: DateTime!): HistoricalFile
    meta: GenericScalar!
    historyUserId: String
    question: Question!
    historyId: UUID!
    historyDate: DateTime!
    historyChangeReason: String
    historyType: String
    file: File
  }

  type HistoricalFloatAnswer implements HistoricalAnswer, Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    historyQuestionType: HistoricalAnswerHistoryQuestionType!
    id: ID!
    value: Float
    meta: GenericScalar!
    historyUserId: String
    question: Question!
    historyId: UUID!
    historyDate: DateTime!
    historyChangeReason: String
    historyType: String
  }

  type HistoricalIntegerAnswer implements HistoricalAnswer, Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    historyQuestionType: HistoricalAnswerHistoryQuestionType!
    id: ID!
    value: Int
    meta: GenericScalar!
    historyUserId: String
    question: Question!
    historyId: UUID!
    historyDate: DateTime!
    historyChangeReason: String
    historyType: String
  }

  type HistoricalListAnswer implements HistoricalAnswer, Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    historyQuestionType: HistoricalAnswerHistoryQuestionType!
    id: ID!
    value: [String]
    meta: GenericScalar!
    historyUserId: String
    question: Question!
    historyId: UUID!
    historyDate: DateTime!
    historyChangeReason: String
    historyType: String
    selectedOptions(before: String, after: String, first: Int, last: Int): SelectedOptionConnection
  }

  type HistoricalStringAnswer implements HistoricalAnswer, Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    historyQuestionType: HistoricalAnswerHistoryQuestionType!
    id: ID!
    value: String
    meta: GenericScalar!
    historyUserId: String
    question: Question!
    historyId: UUID!
    historyDate: DateTime!
    historyChangeReason: String
    historyType: String
    selectedOption: SelectedOption
  }

  type HistoricalTableAnswer implements HistoricalAnswer, Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    historyQuestionType: HistoricalAnswerHistoryQuestionType!
    id: ID!
    value(asOf: DateTime!): [HistoricalDocument]
    meta: GenericScalar!
    historyUserId: String
    question: Question!
    historyId: UUID!
    historyDate: DateTime!
    historyChangeReason: String
    historyType: String
    document: Document
  }

  type IntegerAnswer implements Answer, Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    id: ID!
    question: Question!
    value: Int
    meta: GenericScalar!
  }

  type IntegerQuestion implements Question, Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    slug: String!
    label: String!
    isRequired: QuestionJexl!
    isHidden: QuestionJexl!
    isArchived: Boolean!
    placeholder: String
    infoText: String
    hintText: String
    meta: GenericScalar!
    source: Question
    defaultAnswer: IntegerAnswer
    forms(before: String, after: String, first: Int, last: Int, metaValue: [JSONValueFilterType], orderBy: [FormOrdering], slug: String, name: String, description: String, isPublished: Boolean, isArchived: Boolean, questions: [String], createdByUser: String, createdByGroup: String, modifiedByUser: String, modifiedByGroup: String, createdBefore: DateTime, createdAfter: DateTime, metaHasKey: String, search: String, slugs: [String]): FormConnection
    id: ID!
    maxValue: Int
    minValue: Int
  }

  enum JSONLookupMode {
    EXACT
    STARTSWITH
    CONTAINS
    ICONTAINS
    IN
    GTE
    GT
    LTE
    LT
  }

  scalar JSONString

  input JSONValueFilterType {
    key: String!
    value: GenericScalar!
    lookup: JSONLookupMode
  }

  type ListAnswer implements Answer, Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    id: ID!
    question: Question!
    value: [String]
    meta: GenericScalar!
    selectedOptions(before: String, after: String, first: Int, last: Int): SelectedOptionConnection
  }

  type MultipleChoiceQuestion implements Question, Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    slug: String!
    label: String!
    isRequired: QuestionJexl!
    isHidden: QuestionJexl!
    isArchived: Boolean!
    infoText: String
    hintText: String
    meta: GenericScalar!
    source: Question
    defaultAnswer: ListAnswer
    forms(before: String, after: String, first: Int, last: Int, metaValue: [JSONValueFilterType], orderBy: [FormOrdering], slug: String, name: String, description: String, isPublished: Boolean, isArchived: Boolean, questions: [String], createdByUser: String, createdByGroup: String, modifiedByUser: String, modifiedByGroup: String, createdBefore: DateTime, createdAfter: DateTime, metaHasKey: String, search: String, slugs: [String]): FormConnection
    options(before: String, after: String, first: Int, last: Int, metaValue: [JSONValueFilterType], orderBy: [OptionOrdering], slug: String, label: String, isArchived: Boolean, createdByUser: String, createdByGroup: String, modifiedByUser: String, modifiedByGroup: String, createdBefore: DateTime, createdAfter: DateTime, metaHasKey: String, search: String): OptionConnection
    staticContent: String
    id: ID!
  }

  type Mutation {
    saveAnalyticsTable(input: SaveAnalyticsTableInput!): SaveAnalyticsTablePayload
    removeAnalyticsTable(input: RemoveAnalyticsTableInput!): RemoveAnalyticsTablePayload
    saveAnalyticsField(input: SaveAnalyticsFieldInput!): SaveAnalyticsFieldPayload
    removeAnalyticsField(input: RemoveAnalyticsFieldInput!): RemoveAnalyticsFieldPayload

    """The ID of the object"""
    id: ID!
    slug: String!
    label: String!
    document: Document!
    question: DynamicQuestion!
  }

  input DynamicOptionFilterSetType {
    question: ID
    document: ID
    invert: Boolean
  }

  type DocumentValidityConnection {
    """Pagination data for this connection."""
    pageInfo: PageInfo!

    """Contains the nodes in this connection."""
    edges: [DocumentValidityEdge]!
    totalCount: Int
  }

  """A Relay edge containing a `DocumentValidity` and its cursor."""
  type DocumentValidityEdge {
    """The item at the end of the edge"""
    node: ValidationResult

    """A cursor for use in pagination"""
    cursor: String!
  }

  type ValidationResult {
    id: ID
    isValid: Boolean
    errors: [ValidationEntry]
  }

  type ValidationEntry {
    slug: String!
    errorMsg: String!
  }

  """Debugging information for the current query."""
  type DjangoDebug {
    """Executed SQL queries for this API query."""
    sql: [DjangoDebugSQL]
  }

  """Represents a single database query made to a Django managed DB."""
  type DjangoDebugSQL {
    """The type of database being used (e.g. postrgesql, mysql, sqlite)."""
    vendor: String!

    """The Django database alias (e.g. 'default')."""
    alias: String!

    """The actual SQL sent to this database."""
    sql: String

    """Duration of this database query in seconds."""
    duration: Float!

    """The raw SQL of this query, without params."""
    rawSql: String!

    """JSON encoded database query parameters."""
    params: String!

    """Start time of this database query."""
    startTime: Float!

    """Stop time of this database query."""
    stopTime: Float!

    """Whether this database query took more than 10 seconds."""
    isSlow: Boolean!

    """Whether this database query was a SELECT."""
    isSelect: Boolean!

    """Postgres transaction ID if available."""
    transId: String

    """Postgres transaction status if available."""
    transStatus: String

    """Postgres isolation level if available."""
    isoLevel: String

    """Postgres connection encoding if available."""
    encoding: String
  }

  type Mutation {
    saveWorkflow(input: SaveWorkflowInput!): SaveWorkflowPayload
    addWorkflowFlow(input: AddWorkflowFlowInput!): AddWorkflowFlowPayload
    removeFlow(input: RemoveFlowInput!): RemoveFlowPayload
    saveSimpleTask(input: SaveSimpleTaskInput!): SaveSimpleTaskPayload
    saveCompleteWorkflowFormTask(input: SaveCompleteWorkflowFormTaskInput!): SaveCompleteWorkflowFormTaskPayload
    saveCompleteTaskFormTask(input: SaveCompleteTaskFormTaskInput!): SaveCompleteTaskFormTaskPayload
    startCase(input: StartCaseInput!): StartCasePayload @deprecated(reason: "Use SaveCase mutation instead")
    saveCase(input: SaveCaseInput!): SaveCasePayload
    cancelCase(input: CancelCaseInput!): CancelCasePayload
    suspendCase(input: SuspendCaseInput!): SuspendCasePayload
    resumeCase(input: ResumeCaseInput!): ResumeCasePayload
    completeWorkItem(input: CompleteWorkItemInput!): CompleteWorkItemPayload
    skipWorkItem(input: SkipWorkItemInput!): SkipWorkItemPayload
    cancelWorkItem(input: CancelWorkItemInput!): CancelWorkItemPayload
    suspendWorkItem(input: SuspendWorkItemInput!): SuspendWorkItemPayload
    resumeWorkItem(input: ResumeWorkItemInput!): ResumeWorkItemPayload
    redoWorkItem(input: RedoWorkItemInput!): RedoWorkItemPayload
    saveWorkItem(input: SaveWorkItemInput!): SaveWorkItemPayload
    createWorkItem(input: CreateWorkItemInput!): CreateWorkItemPayload
    saveForm(input: SaveFormInput!): SaveFormPayload
    copyForm(input: CopyFormInput!): CopyFormPayload

    """Add question at the end of form."""
    addFormQuestion(input: AddFormQuestionInput!): AddFormQuestionPayload
    removeFormQuestion(input: RemoveFormQuestionInput!): RemoveFormQuestionPayload
    reorderFormQuestions(input: ReorderFormQuestionsInput!): ReorderFormQuestionsPayload
    saveOption(input: SaveOptionInput!): SaveOptionPayload
    copyOption(input: CopyOptionInput!): CopyOptionPayload
    copyQuestion(input: CopyQuestionInput!): CopyQuestionPayload
    saveTextQuestion(input: SaveTextQuestionInput!): SaveTextQuestionPayload
    saveTextareaQuestion(input: SaveTextareaQuestionInput!): SaveTextareaQuestionPayload
    saveDateQuestion(input: SaveDateQuestionInput!): SaveDateQuestionPayload
    saveChoiceQuestion(input: SaveChoiceQuestionInput!): SaveChoiceQuestionPayload
    saveMultipleChoiceQuestion(input: SaveMultipleChoiceQuestionInput!): SaveMultipleChoiceQuestionPayload
    saveDynamicChoiceQuestion(input: SaveDynamicChoiceQuestionInput!): SaveDynamicChoiceQuestionPayload
    saveDynamicMultipleChoiceQuestion(input: SaveDynamicMultipleChoiceQuestionInput!): SaveDynamicMultipleChoiceQuestionPayload
    saveFloatQuestion(input: SaveFloatQuestionInput!): SaveFloatQuestionPayload
    saveIntegerQuestion(input: SaveIntegerQuestionInput!): SaveIntegerQuestionPayload
    saveTableQuestion(input: SaveTableQuestionInput!): SaveTableQuestionPayload
    saveFormQuestion(input: SaveFormQuestionInput!): SaveFormQuestionPayload
    saveFileQuestion(input: SaveFileQuestionInput!): SaveFileQuestionPayload
    saveStaticQuestion(input: SaveStaticQuestionInput!): SaveStaticQuestionPayload
    saveCalculatedFloatQuestion(input: SaveCalculatedFloatQuestionInput!): SaveCalculatedFloatQuestionPayload
    saveActionButtonQuestion(input: SaveActionButtonQuestionInput!): SaveActionButtonQuestionPayload
    copyDocument(input: CopyDocumentInput!): CopyDocumentPayload
    saveDocument(input: SaveDocumentInput!): SaveDocumentPayload
    saveDocumentStringAnswer(input: SaveDocumentStringAnswerInput!): SaveDocumentStringAnswerPayload
    saveDocumentIntegerAnswer(input: SaveDocumentIntegerAnswerInput!): SaveDocumentIntegerAnswerPayload
    saveDocumentFloatAnswer(input: SaveDocumentFloatAnswerInput!): SaveDocumentFloatAnswerPayload
    saveDocumentDateAnswer(input: SaveDocumentDateAnswerInput!): SaveDocumentDateAnswerPayload
    saveDocumentListAnswer(input: SaveDocumentListAnswerInput!): SaveDocumentListAnswerPayload
    saveDocumentTableAnswer(input: SaveDocumentTableAnswerInput!): SaveDocumentTableAnswerPayload
    saveDocumentFileAnswer(input: SaveDocumentFileAnswerInput!): SaveDocumentFileAnswerPayload
    saveDefaultStringAnswer(input: SaveDefaultStringAnswerInput!): SaveDefaultStringAnswerPayload
    saveDefaultIntegerAnswer(input: SaveDefaultIntegerAnswerInput!): SaveDefaultIntegerAnswerPayload
    saveDefaultFloatAnswer(input: SaveDefaultFloatAnswerInput!): SaveDefaultFloatAnswerPayload
    saveDefaultDateAnswer(input: SaveDefaultDateAnswerInput!): SaveDefaultDateAnswerPayload
    saveDefaultListAnswer(input: SaveDefaultListAnswerInput!): SaveDefaultListAnswerPayload
    saveDefaultTableAnswer(input: SaveDefaultTableAnswerInput!): SaveDefaultTableAnswerPayload
    removeAnswer(input: RemoveAnswerInput!): RemoveAnswerPayload
    removeDefaultAnswer(input: RemoveDefaultAnswerInput!): RemoveDefaultAnswerPayload
    removeDocument(input: RemoveDocumentInput!): RemoveDocumentPayload
  }

  interface Node {
    id: ID!
  }

  type Option implements Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    slug: String!
    label: String!
    isArchived: Boolean!
    meta: GenericScalar
    source: Option
    id: ID!
  }

  type OptionConnection {
    pageInfo: PageInfo!
    edges: [OptionEdge]!
    totalCount: Int
  }

  type OptionEdge {
    node: Option
    cursor: String!
  }

  enum OptionOrdering {
    LABEL_ASC
    LABEL_DESC
    CREATED_AT_ASC
    CREATED_AT_DESC
    MODIFIED_AT_ASC
    MODIFIED_AT_DESC
    CREATED_BY_USER_ASC
    CREATED_BY_USER_DESC
    CREATED_BY_GROUP_ASC
    CREATED_BY_GROUP_DESC
    MODIFIED_BY_USER_ASC
    MODIFIED_BY_USER_DESC
    MODIFIED_BY_GROUP_ASC
    MODIFIED_BY_GROUP_DESC
    META_TEST_KEY_ASC
    META_TEST_KEY_DESC
    META_FOOBAR_ASC
    META_FOOBAR_DESC
  }

  type PageInfo {
    hasNextPage: Boolean!
    hasPreviousPage: Boolean!
    startCursor: String
    endCursor: String
  }

  type Query {
    documentAsOf(id: ID!, asOf: DateTime!): HistoricalDocument
    allAnalyticsTables(before: String, after: String, first: Int, last: Int, metaValue: [JSONValueFilterType], slug: String, name: String, filter: [AnalyticsTableFilterSetType], order: [AnalyticsTableOrderSetType], createdByUser: String, createdByGroup: String, modifiedByUser: String, modifiedByGroup: String, createdBefore: DateTime, createdAfter: DateTime, metaHasKey: String, search: String, slugs: [String]): AnalyticsTableConnection
    analyticsTable(slug: String!): AnalyticsTable
    allAnalyticsFields(before: String, after: String, first: Int, last: Int, metaValue: [JSONValueFilterType], alias: String, table: ID, filter: [AnalyticsFieldFilterSetType], createdByUser: String, createdByGroup: String, modifiedByUser: String, modifiedByGroup: String, createdBefore: DateTime, createdAfter: DateTime, metaHasKey: String, search: String, slugs: [String]): AnalyticsFieldConnection
    allDataSources(before: String, after: String, first: Int, last: Int): DataSourceConnection
    dataSource(name: String!, before: String, after: String, first: Int, last: Int): DataSourceDataConnection
    allWorkflows(before: String, after: String, first: Int, last: Int, metaValue: [JSONValueFilterType], slug: String, name: String, description: String, isPublished: Boolean, isArchived: Boolean, orderBy: [WorkflowOrdering], filter: [WorkflowFilterSetType], order: [WorkflowOrderSetType], createdByUser: String, createdByGroup: String, modifiedByUser: String, modifiedByGroup: String, createdBefore: DateTime, createdAfter: DateTime, metaHasKey: String, search: String): WorkflowConnection
    allTasks(before: String, after: String, first: Int, last: Int, metaValue: [JSONValueFilterType], slug: String, name: String, description: String, type: TaskTypeArgument, isArchived: Boolean, orderBy: [TaskOrdering], filter: [TaskFilterSetType], order: [TaskOrderSetType], createdByUser: String, createdByGroup: String, modifiedByUser: String, modifiedByGroup: String, createdBefore: DateTime, createdAfter: DateTime, metaHasKey: String, search: String): TaskConnection
    allCases(before: String, after: String, first: Int, last: Int, metaValue: [JSONValueFilterType], workflow: ID, orderBy: [CaseOrdering], filter: [CaseFilterSetType], order: [CaseOrderSetType], createdByUser: String, createdByGroup: String, modifiedByUser: String, modifiedByGroup: String, createdBefore: DateTime, createdAfter: DateTime, metaHasKey: String, id: ID, documentForm: String, documentForms: [String], hasAnswer: [HasAnswerFilterType], workItemDocumentHasAnswer: [HasAnswerFilterType], rootCase: ID, searchAnswers: [SearchAnswersFilterType], status: [CaseStatusArgument], orderByQuestionAnswerValue: String): CaseConnection
    allWorkItems(before: String, after: String, first: Int, last: Int, metaValue: [JSONValueFilterType], status: WorkItemStatusArgument, orderBy: [WorkItemOrdering], filter: [WorkItemFilterSetType], order: [WorkItemOrderSetType], documentHasAnswer: [HasAnswerFilterType], caseDocumentHasAnswer: [HasAnswerFilterType], caseMetaValue: [JSONValueFilterType], rootCaseMetaValue: [JSONValueFilterType], name: String, task: ID, tasks: [String], case: ID, createdAt: DateTime, closedAt: DateTime, modifiedAt: DateTime, deadline: DateTime, hasDeadline: Boolean, caseFamily: ID, createdByUser: String, createdByGroup: String, modifiedByUser: String, modifiedByGroup: String, createdBefore: DateTime, createdAfter: DateTime, metaHasKey: String, id: ID, addressedGroups: [String], controllingGroups: [String], assignedUsers: [String]): WorkItemConnection
    allForms(before: String, after: String, first: Int, last: Int, metaValue: [JSONValueFilterType], orderBy: [FormOrdering], slug: String, name: String, description: String, isPublished: Boolean, isArchived: Boolean, questions: [String], filter: [FormFilterSetType], order: [FormOrderSetType], createdByUser: String, createdByGroup: String, modifiedByUser: String, modifiedByGroup: String, createdBefore: DateTime, createdAfter: DateTime, metaHasKey: String, search: String, slugs: [String]): FormConnection
    allQuestions(before: String, after: String, first: Int, last: Int, metaValue: [JSONValueFilterType], orderBy: [QuestionOrdering], slug: String, label: String, isRequired: String, isHidden: String, isArchived: Boolean, subForm: ID, rowForm: ID, filter: [QuestionFilterSetType], order: [QuestionOrderSetType], createdByUser: String, createdByGroup: String, modifiedByUser: String, modifiedByGroup: String, createdBefore: DateTime, createdAfter: DateTime, metaHasKey: String, excludeForms: [ID], search: String, slugs: [String]): QuestionConnection
    allDocuments(before: String, after: String, first: Int, last: Int, metaValue: [JSONValueFilterType], form: ID, forms: [ID], search: String, id: ID, orderBy: [DocumentOrdering], filter: [DocumentFilterSetType], order: [DocumentOrderSetType], createdByUser: String, createdByGroup: String, modifiedByUser: String, modifiedByGroup: String, createdBefore: DateTime, createdAfter: DateTime, metaHasKey: String, rootDocument: ID, hasAnswer: [HasAnswerFilterType], searchAnswers: [SearchAnswersFilterType]): DocumentConnection
    allFormatValidators(before: String, after: String, first: Int, last: Int): FormatValidatorConnection
    allUsedDynamicOptions(before: String, after: String, first: Int, last: Int, question: ID, document: ID, filter: [DynamicOptionFilterSetType], createdByUser: String, createdByGroup: String, modifiedByUser: String, modifiedByGroup: String, createdBefore: DateTime, createdAfter: DateTime): DynamicOptionConnection
    documentValidity(id: ID!, before: String, after: String, first: Int, last: Int): DocumentValidityConnection
    node(id: ID!): Node
    _debug: DjangoDebug
  }

  interface Question {
    id: ID!
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    slug: String!
    label: String!
    infoText: String
    isRequired: QuestionJexl!
    isHidden: QuestionJexl!
    isArchived: Boolean!
    meta: GenericScalar!
    forms(before: String, after: String, first: Int, last: Int, slug: String, name: String, description: String, isPublished: Boolean, isArchived: Boolean, questions: [String], createdByUser: String, createdByGroup: String, modifiedByUser: String, modifiedByGroup: String, createdBefore: DateTime, createdAfter: DateTime, metaHasKey: String, metaValue: [JSONValueFilterType], search: String, orderBy: [FormOrdering], slugs: [String]): FormConnection
    source: Question
  }

  type QuestionConnection {
    pageInfo: PageInfo!
    edges: [QuestionEdge]!
    totalCount: Int
  }

  type QuestionEdge {
    node: Question
    cursor: String!
  }

  input QuestionFilterSetType {
    orderBy: [QuestionOrdering]
    slug: String
    label: String
    isRequired: String
    isHidden: String
    isArchived: Boolean
    subForm: ID
    rowForm: ID
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    createdBefore: DateTime
    createdAfter: DateTime
    metaHasKey: String
    metaValue: [JSONValueFilterType]
    excludeForms: [ID]
    search: String
    slugs: [String]
    invert: Boolean
  }

  scalar QuestionJexl

  input QuestionOrderSetType {
    meta: String
    attribute: SortableQuestionAttributes
    direction: AscDesc
  }

  enum QuestionOrdering {
    LABEL_ASC
    LABEL_DESC
    CREATED_AT_ASC
    CREATED_AT_DESC
    MODIFIED_AT_ASC
    MODIFIED_AT_DESC
    CREATED_BY_USER_ASC
    CREATED_BY_USER_DESC
    CREATED_BY_GROUP_ASC
    CREATED_BY_GROUP_DESC
    MODIFIED_BY_USER_ASC
    MODIFIED_BY_USER_DESC
    MODIFIED_BY_GROUP_ASC
    MODIFIED_BY_GROUP_DESC
    META_TEST_KEY_ASC
    META_TEST_KEY_DESC
    META_FOOBAR_ASC
    META_FOOBAR_DESC
  }

  input RedoWorkItemInput {
    id: ID!
    context: JSONString
    clientMutationId: String
  }

  type RedoWorkItemPayload {
    workItem: WorkItem
    clientMutationId: String
  }

  input RemoveAnalyticsFieldInput {
    id: ID!
    clientMutationId: String
  }

  type RemoveAnalyticsFieldPayload {
    analyticsField: AnalyticsField
    clientMutationId: String
  }

  input RemoveAnalyticsTableInput {
    slug: ID!
    clientMutationId: String
  }

  type RemoveAnalyticsTablePayload {
    analyticsTable: AnalyticsTable
    clientMutationId: String
  }

  input RemoveAnswerInput {
    answer: ID!
    clientMutationId: String
  }

  type RemoveAnswerPayload {
    answer: Answer
    clientMutationId: String
  }

  input RemoveDefaultAnswerInput {
    question: ID!
    clientMutationId: String
  }

  type RemoveDefaultAnswerPayload {
    question: Question
    clientMutationId: String
  }

  input RemoveDocumentInput {
    document: ID!
    clientMutationId: String
  }

  type RemoveDocumentPayload {
    document: Document
    clientMutationId: String
  }

  input RemoveFlowInput {
    flow: ID!
  type SaveWorkflowPayload {
    workflow: Workflow
    clientMutationId: String
  }

  input SaveWorkflowInput {
    slug: String!
    name: String!
    description: String
    meta: JSONString

    """Starting task(s) of the workflow."""
    startTasks: [ID]!

    """Allow workflow to be started with any form"""
    allowAllForms: Boolean

    """List of forms which are allowed to start workflow with"""
    allowForms: [ID]
    isArchived: Boolean
    isPublished: Boolean
    clientMutationId: String
  }

  """
  Allows use of a JSON String for input / output from the GraphQL schema.

  Use of this type is *not recommended* as you lose the benefits of having a defined, static
  schema (one of the key benefits of GraphQL).
  """
  scalar JSONString

  type AddWorkflowFlowPayload {
    workflow: Workflow
    clientMutationId: String
  }

  input AddWorkflowFlowInput {
    workflow: ID!
    tasks: [ID]!
    next: FlowJexl!
    clientMutationId: String
  }

  type RemoveFlowPayload {
    flow: Flow
    clientMutationId: String
  }

  input RemoveFlowInput {
    flow: ID!
    clientMutationId: String
  }

  type SaveSimpleTaskPayload {
    task: Task
    clientMutationId: String
  }

  input SaveSimpleTaskInput {
    slug: String!
    name: String!
    description: String
    meta: JSONString

    """
    Group jexl returning what group(s) derived work items will be addressed to.
    """
    addressGroups: GroupJexl

    """
    Group jexl returning what group(s) derived work items will be assigned to for controlling.
    """
    controlGroups: GroupJexl
    isArchived: Boolean

    """Time in seconds task may take to be processed."""
    leadTime: Int

    """
    Allows creating multiple work items for this task using the `CreateWorkItem` mutation. If true, one work item will be created for each entry in `address_groups`.
    """
    isMultipleInstance: Boolean
    clientMutationId: String
  }

  type SaveCompleteWorkflowFormTaskPayload {
    task: Task
    clientMutationId: String
  }

  input SaveCompleteWorkflowFormTaskInput {
    slug: String!
    name: String!
    description: String
    meta: JSONString

    """
    Group jexl returning what group(s) derived work items will be addressed to.
    """
    addressGroups: GroupJexl

    """
    Group jexl returning what group(s) derived work items will be assigned to for controlling.
    """
    controlGroups: GroupJexl
    isArchived: Boolean

    """Time in seconds task may take to be processed."""
    leadTime: Int

    """
    Allows creating multiple work items for this task using the `CreateWorkItem` mutation. If true, one work item will be created for each entry in `address_groups`.
    """
    isMultipleInstance: Boolean
    clientMutationId: String
  }

  type SaveCompleteTaskFormTaskPayload {
    task: Task
    clientMutationId: String
  }

  input SaveCompleteTaskFormTaskInput {
    slug: String!
    name: String!
    description: String
    meta: JSONString

    """
    Group jexl returning what group(s) derived work items will be addressed to.
    """
    addressGroups: GroupJexl

    """
    Group jexl returning what group(s) derived work items will be assigned to for controlling.
    """
    controlGroups: GroupJexl
    isArchived: Boolean

    """Time in seconds task may take to be processed."""
    leadTime: Int

    """
    Allows creating multiple work items for this task using the `CreateWorkItem` mutation. If true, one work item will be created for each entry in `address_groups`.
    """
    isMultipleInstance: Boolean
    form: ID!
    clientMutationId: String
  }

  type StartCasePayload {
    case: Case
    clientMutationId: String
  }

  input StartCaseInput {
    workflow: ID!
    meta: JSONString
    parentWorkItem: ID
    form: ID

    """Provide extra context for dynamic jexl transforms and events"""
    context: JSONString
    clientMutationId: String
  }

  type SaveCasePayload {
    case: Case
    clientMutationId: String
  }

  input SaveCaseInput {
    id: String
    workflow: ID!
    meta: JSONString
    parentWorkItem: ID
    form: ID

    """Provide extra context for dynamic jexl transforms and events"""
    context: JSONString
    clientMutationId: String
  }

  type CancelCasePayload {
    case: Case
    clientMutationId: String
  }

  input CancelCaseInput {
    id: ID!

    """Provide extra context for dynamic jexl transforms and events"""
    context: JSONString
    clientMutationId: String
  }

  type SuspendCasePayload {
    case: Case
    clientMutationId: String
  }

  input SuspendCaseInput {
    id: ID!

    """Provide extra context for dynamic jexl transforms and events"""
    context: JSONString
    clientMutationId: String
  }

  type ResumeCasePayload {
    case: Case
    clientMutationId: String
  }

  input ResumeCaseInput {
    id: ID!

    """Provide extra context for dynamic jexl transforms and events"""
    context: JSONString
    clientMutationId: String
  }

  type CompleteWorkItemPayload {
    workItem: WorkItem
    clientMutationId: String
  }

  input CompleteWorkItemInput {
    id: ID!

    """Provide extra context for dynamic jexl transforms and events"""
    context: JSONString
    clientMutationId: String
  }

  type SkipWorkItemPayload {
    workItem: WorkItem
    clientMutationId: String
  }

  input SkipWorkItemInput {
    id: ID!

    """Provide extra context for dynamic jexl transforms and events"""
    context: JSONString
    clientMutationId: String
  }

  type CancelWorkItemPayload {
    workItem: WorkItem
    clientMutationId: String
  }

  input CancelWorkItemInput {
    id: ID!

    """Provide extra context for dynamic jexl transforms and events"""
    context: JSONString
    clientMutationId: String
  }

  type SuspendWorkItemPayload {
    workItem: WorkItem
    clientMutationId: String
  }

  input SuspendWorkItemInput {
    id: ID!

    """Provide extra context for dynamic jexl transforms and events"""
    context: JSONString
    clientMutationId: String
  }

  type ResumeWorkItemPayload {
    workItem: WorkItem
    clientMutationId: String
  }

  input ResumeWorkItemInput {
    id: ID!

    """Provide extra context for dynamic jexl transforms and events"""
    context: JSONString
    clientMutationId: String
  }

  type SaveWorkItemPayload {
    workItem: WorkItem
    clientMutationId: String
  }

  input SaveWorkItemInput {
    workItem: ID!

    """Will be set from Task, if not provided."""
    name: String

    """Will be set from Task, if not provided."""
    description: String

    """Users responsible to undertake given work item."""
    assignedUsers: [String]
    deadline: DateTime
    meta: JSONString

    """Provide extra context for dynamic jexl transforms and events"""
    context: JSONString
    clientMutationId: String
  }

  type CreateWorkItemPayload {
    workItem: WorkItem
    clientMutationId: String
  }

  input CreateWorkItemInput {
    case: ID!
    multipleInstanceTask: ID!

    """Will be set from Task, if not provided."""
    name: String

    """Will be set from Task, if not provided."""
    description: String

    """Users responsible to undertake given work item."""
    assignedUsers: [String]
    addressedGroups: [String]
    controllingGroups: [String]
    deadline: DateTime
    meta: JSONString

    """Provide extra context for dynamic jexl transforms and events"""
    context: JSONString
    clientMutationId: String
  }

  type SaveFormPayload {
    form: Form
    clientMutationId: String
  }

  input SaveFormInput {
    slug: String!
    name: String!
    description: String
    meta: JSONString
    isArchived: Boolean
    isPublished: Boolean
    clientMutationId: String
  }

  type CopyFormPayload {
    form: Form
    clientMutationId: String
  }

  input CopyFormInput {
    slug: String!
    name: String!
    description: String
    source: ID!
    isPublished: Boolean
    clientMutationId: String
  }

  """Add question at the end of form."""
  type AddFormQuestionPayload {
    form: Form
    clientMutationId: String
  }

  input AddFormQuestionInput {
  input RemoveFormQuestionInput {
    form: ID!
    question: ID!
    clientMutationId: String
  }

  type RemoveFormQuestionPayload {
    form: Form
    clientMutationId: String
  }

  input ReorderFormQuestionsInput {
    form: ID!
    questions: [ID]!
  input RemoveFormQuestionInput {
    form: ID!
    question: ID!
    clientMutationId: String
  }

  type ReorderFormQuestionsPayload {
    form: Form
    clientMutationId: String
  }

  input ResumeCaseInput {
    id: ID!
    context: JSONString
    clientMutationId: String
  }

  type ResumeCasePayload {
    case: Case
    clientMutationId: String
  }

  input ResumeWorkItemInput {
    id: ID!
    context: JSONString
    clientMutationId: String
  }

  type ResumeWorkItemPayload {
    workItem: WorkItem
  input ReorderFormQuestionsInput {
    form: ID!
    questions: [ID]!
    clientMutationId: String
  }

  type SaveOptionPayload {
    option: Option
    clientMutationId: String
  }

  input SaveOptionInput {
    slug: String!
    label: String!
    isArchived: Boolean
    meta: JSONString
    clientMutationId: String
  }

  type CopyOptionPayload {
    option: Option
    clientMutationId: String
  }

  input CopyOptionInput {
    slug: String!
    label: String!
    source: ID!
    clientMutationId: String
  }

  type CopyQuestionPayload {
    question: Question
    clientMutationId: String
  }

  input CopyQuestionInput {
    slug: String!
    label: String!
    source: ID!
    clientMutationId: String
  }

  type SaveTextQuestionPayload {
    question: Question
    clientMutationId: String
  }

  input SaveTextQuestionInput {
    slug: String!
    label: String!
    infoText: String
    isRequired: QuestionJexl
    isHidden: QuestionJexl
    meta: JSONString
    isArchived: Boolean
    minLength: Int
    maxLength: Int
    placeholder: String
    formatValidators: [String]
    clientMutationId: String
  }

  type SaveTextareaQuestionPayload {
    question: Question
    clientMutationId: String
  }

  input SaveTextareaQuestionInput {
    slug: String!
    label: String!
    infoText: String
    isRequired: QuestionJexl
    isHidden: QuestionJexl
    meta: JSONString
    isArchived: Boolean
    minLength: Int
    maxLength: Int
    placeholder: String
    formatValidators: [String]
    clientMutationId: String
  }

  type SaveDateQuestionPayload {
    question: Question
    clientMutationId: String
  }

  input SaveDateQuestionInput {
    slug: String!
    label: String!
    infoText: String
    isRequired: QuestionJexl
    isHidden: QuestionJexl
    meta: JSONString
    isArchived: Boolean
    clientMutationId: String
  }

  type SaveChoiceQuestionPayload {
    question: Question
    clientMutationId: String
  }

  input SaveChoiceQuestionInput {
    slug: String!
    label: String!
    infoText: String
    isRequired: QuestionJexl
    isHidden: QuestionJexl
    meta: JSONString
    isArchived: Boolean
    options: [ID]!
    clientMutationId: String
  }

  type SaveMultipleChoiceQuestionPayload {
    question: Question
    clientMutationId: String
  }

  input SaveMultipleChoiceQuestionInput {
    slug: String!
    label: String!
    infoText: String
    isRequired: QuestionJexl
    isHidden: QuestionJexl
    meta: JSONString
    isArchived: Boolean
    options: [ID]!
    clientMutationId: String
  }

  type SaveDynamicChoiceQuestionPayload {
    question: Question
    clientMutationId: String
  }

  input SaveDynamicChoiceQuestionInput {
    slug: String!
    label: String!
    infoText: String
    isRequired: QuestionJexl
    isHidden: QuestionJexl
    meta: JSONString
    isArchived: Boolean
    dataSource: String!
    clientMutationId: String
  }

  type SaveDynamicMultipleChoiceQuestionPayload {
    question: Question
    clientMutationId: String
  }

  input SaveDynamicMultipleChoiceQuestionInput {
    slug: String!
    label: String!
    infoText: String
    isRequired: QuestionJexl
    isHidden: QuestionJexl
    meta: JSONString
    isArchived: Boolean
    dataSource: String!
    clientMutationId: String
  }

  type SaveFloatQuestionPayload {
    question: Question
    clientMutationId: String
  }

  input SaveFloatQuestionInput {
    slug: String!
    label: String!
    infoText: String
    isRequired: QuestionJexl
    isHidden: QuestionJexl
    meta: JSONString
    isArchived: Boolean
    minValue: Float
    maxValue: Float
    placeholder: String
    clientMutationId: String
  }

  type SaveIntegerQuestionPayload {
    question: Question
    clientMutationId: String
  }

  input SaveIntegerQuestionInput {
    slug: String!
    label: String!
    infoText: String
    isRequired: QuestionJexl
    isHidden: QuestionJexl
    meta: JSONString
    isArchived: Boolean
    minValue: Int
    maxValue: Int
    placeholder: String
    clientMutationId: String
  }

  type SaveTableQuestionPayload {
    question: Question
    clientMutationId: String
  }

  input SaveTableQuestionInput {
    slug: String!
    label: String!
    infoText: String
    isRequired: QuestionJexl
    isHidden: QuestionJexl
    meta: JSONString
    isArchived: Boolean

    """Form that represents rows of a TableQuestion"""
    rowForm: ID!
    clientMutationId: String
  }

  type SaveFormQuestionPayload {
    question: Question
    clientMutationId: String
  }

  input SaveFormQuestionInput {
    slug: String!
    label: String!
    infoText: String
    isRequired: QuestionJexl
    isHidden: QuestionJexl
    meta: JSONString
    isArchived: Boolean
    subForm: ID!
    clientMutationId: String
  }

  type SaveFileQuestionPayload {
    question: Question
    clientMutationId: String
  }

  input SaveFileQuestionInput {
    slug: String!
    label: String!
    infoText: String
    isRequired: QuestionJexl
    isHidden: QuestionJexl
    meta: JSONString
    isArchived: Boolean
    clientMutationId: String
  }

  type SaveStaticQuestionPayload {
    question: Question
    clientMutationId: String
  }

  input SaveStaticQuestionInput {
    label: String!
    slug: String!
    infoText: String
    isHidden: QuestionJexl
    meta: JSONString
    isArchived: Boolean
    staticContent: String
    clientMutationId: String
  }

  type SaveCalculatedFloatQuestionPayload {
    question: Question
    clientMutationId: String
  }

  input SaveCalculatedFloatQuestionInput {
    slug: String!
    label: String!
    infoText: String
    isRequired: QuestionJexl
    isHidden: QuestionJexl
    meta: JSONString
    isArchived: Boolean
    calcExpression: QuestionJexl
    clientMutationId: String
  }

  type SaveActionButtonQuestionPayload {
    question: Question
    clientMutationId: String
  }

  input SaveActionButtonQuestionInput {
    label: String!
    slug: String!
    infoText: String
    isHidden: QuestionJexl
    meta: JSONString
    isArchived: Boolean
    action: ButtonAction!
    color: ButtonColor!
    validateOnEnter: Boolean!
    clientMutationId: String
  }

  type SaveActionButtonQuestionPayload {
    question: Question
    clientMutationId: String
  }

  input SaveAnalyticsFieldInput {
    id: ID
    alias: String!
    table: ID!
    dataSource: String!
    filters: [String]
    meta: JSONString
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    clientMutationId: String
  }

  type SaveAnalyticsFieldPayload {
    analyticsField: AnalyticsField
    clientMutationId: String
  }

  input SaveAnalyticsTableInput {
    slug: String!
    name: String!
    startingObject: starting_object!
    disableVisibilities: Boolean
    meta: JSONString
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    clientMutationId: String
  }

  type SaveAnalyticsTablePayload {
    analyticsTable: AnalyticsTable
    clientMutationId: String
  }

  input SaveCalculatedFloatQuestionInput {
    slug: String!
    label: String!
    infoText: String
    isRequired: QuestionJexl
    isHidden: QuestionJexl
    meta: JSONString
    isArchived: Boolean
    calcExpression: QuestionJexl
    hintText: String
    clientMutationId: String
  }

  type SaveCalculatedFloatQuestionPayload {
    question: Question
    clientMutationId: String
  }

  input SaveCaseInput {
    id: String
    workflow: ID!
    meta: JSONString
    parentWorkItem: ID
    form: ID
    context: JSONString
    clientMutationId: String
  }

  type SaveCasePayload {
    case: Case
    clientMutationId: String
  }

  input SaveChoiceQuestionInput {
    slug: String!
    label: String!
    infoText: String
    isRequired: QuestionJexl
    isHidden: QuestionJexl
    meta: JSONString
    isArchived: Boolean
    options: [ID]!
    hintText: String
    clientMutationId: String
  }

  type SaveChoiceQuestionPayload {
    question: Question
    clientMutationId: String
  }

  input SaveCompleteTaskFormTaskInput {
    slug: String!
    name: String!
    description: String
    meta: JSONString
    addressGroups: GroupJexl
    controlGroups: GroupJexl
    isArchived: Boolean
    leadTime: Int
    isMultipleInstance: Boolean
    form: ID!
    clientMutationId: String
  }

  type SaveCompleteTaskFormTaskPayload {
    task: Task
    clientMutationId: String
  }

  input SaveCompleteWorkflowFormTaskInput {
    slug: String!
    name: String!
    description: String
    meta: JSONString
    addressGroups: GroupJexl
    controlGroups: GroupJexl
    isArchived: Boolean
    leadTime: Int
    isMultipleInstance: Boolean
    clientMutationId: String
  }

  type SaveCompleteWorkflowFormTaskPayload {
    task: Task
    clientMutationId: String
  }

  input SaveDateQuestionInput {
    slug: String!
    label: String!
    infoText: String
    isRequired: QuestionJexl
    isHidden: QuestionJexl
    meta: JSONString
    isArchived: Boolean
    hintText: String
    clientMutationId: String
  }

  type SaveDateQuestionPayload {
    question: Question
    clientMutationId: String
  }

  input SaveDefaultDateAnswerInput {
    question: ID!
    meta: JSONString
    value: Date
    clientMutationId: String
  }

  type SaveDefaultDateAnswerPayload {
  type CopyDocumentPayload {
    document: Document
    clientMutationId: String
  }

  input CopyDocumentInput {
    source: ID!
    clientMutationId: String
  }

  type SaveDocumentPayload {
    document: Document
    clientMutationId: String
  }

  input SaveDocumentInput {
    id: String
    form: ID!
    meta: JSONString
    clientMutationId: String
  }

  type SaveDocumentStringAnswerPayload {
    answer: Answer
    clientMutationId: String
  }

  input SaveDocumentStringAnswerInput {
    question: ID!
    document: ID!
    meta: JSONString
    value: String
    clientMutationId: String
  }

  type SaveDocumentIntegerAnswerPayload {
  input SaveDefaultFloatAnswerInput {
    question: ID!
    meta: JSONString
    value: Float
    clientMutationId: String
  }

  type SaveDefaultFloatAnswerPayload {
    answer: Answer
    clientMutationId: String
  }

  input SaveDocumentIntegerAnswerInput {
    question: ID!
    document: ID!
  input SaveDefaultIntegerAnswerInput {
    question: ID!
    meta: JSONString
    value: Int
    clientMutationId: String
  }

  type SaveDocumentFloatAnswerPayload {
  type SaveDefaultIntegerAnswerPayload {
    answer: Answer
    clientMutationId: String
  }

  input SaveDefaultListAnswerInput {
    question: ID!
    meta: JSONString
    value: [String]
    clientMutationId: String
  }

  type SaveDefaultListAnswerPayload {
    answer: Answer
    clientMutationId: String
  }

  input SaveDefaultStringAnswerInput {
    question: ID!
    meta: JSONString
    value: String
    clientMutationId: String
  }

  type SaveDefaultStringAnswerPayload {
    answer: Answer
    clientMutationId: String
  }

  input SaveDefaultTableAnswerInput {
    question: ID!
    meta: JSONString
    value: [ID]
    clientMutationId: String
  }

  type SaveDefaultTableAnswerPayload {
    answer: Answer
    clientMutationId: String
  }

  input SaveDocumentDateAnswerInput {
    question: ID!
    document: ID!
    meta: JSONString
    value: Date
    clientMutationId: String
  }

  type SaveDocumentDateAnswerPayload {
    answer: Answer
    clientMutationId: String
  }

  input SaveDocumentFileAnswerInput {
    question: ID!
    document: ID!
    meta: JSONString
    value: String
    clientMutationId: String
  }

  type SaveDocumentFileAnswerPayload {
    answer: Answer
    clientMutationId: String
  }

  input SaveDocumentFloatAnswerInput {
    question: ID!
    document: ID!
    meta: JSONString
    value: Float
    clientMutationId: String
  }

  type SaveDocumentDateAnswerPayload {
  type SaveDocumentFloatAnswerPayload {
    answer: Answer
    clientMutationId: String
  }

  input SaveDocumentDateAnswerInput {
    question: ID!
    document: ID!
    meta: JSONString
    value: Date
    clientMutationId: String
  }

  type SaveDocumentListAnswerPayload {
  input SaveDocumentInput {
    id: String
    form: ID!
    meta: JSONString
    clientMutationId: String
  }

  input SaveDocumentIntegerAnswerInput {
    question: ID!
    document: ID!
    meta: JSONString
    value: Int
    clientMutationId: String
  }

  type SaveDocumentIntegerAnswerPayload {
    answer: Answer
    clientMutationId: String
  }

  input SaveDocumentListAnswerInput {
    question: ID!
    document: ID!
    meta: JSONString
    value: [String]
    clientMutationId: String
  }

  type SaveDocumentListAnswerPayload {
    answer: Answer
    clientMutationId: String
  }

  type SaveDocumentPayload {
    document: Document
    clientMutationId: String
  }

  input SaveDocumentStringAnswerInput {
    question: ID!
    document: ID!
    meta: JSONString
    value: String
    clientMutationId: String
  }

  type SaveDocumentStringAnswerPayload {
  type SaveDocumentTableAnswerPayload {
    answer: Answer
    clientMutationId: String
  }

  input SaveDocumentTableAnswerInput {
    question: ID!
    document: ID!
    meta: JSONString

    """List of document IDs representing the rows in the table."""
    value: [ID]
    clientMutationId: String
  }

  type SaveDocumentFileAnswerPayload {
  type SaveDocumentTableAnswerPayload {
    answer: Answer
    clientMutationId: String
  }

  input SaveDocumentFileAnswerInput {
    question: ID!
    document: ID!
    meta: JSONString
    value: String
    clientMutationId: String
  }

  type SaveDefaultStringAnswerPayload {
    answer: Answer
    clientMutationId: String
  }

  input SaveDefaultStringAnswerInput {
    question: ID!
    meta: JSONString
    value: String
    clientMutationId: String
  }

  type SaveDefaultIntegerAnswerPayload {
    answer: Answer
    clientMutationId: String
  }

  input SaveDefaultIntegerAnswerInput {
    question: ID!
    meta: JSONString
    value: Int
    clientMutationId: String
  }

  type SaveDefaultFloatAnswerPayload {
    answer: Answer
    clientMutationId: String
  }

  input SaveDefaultFloatAnswerInput {
    question: ID!
    meta: JSONString
    value: Float
    clientMutationId: String
  }

  type SaveDefaultDateAnswerPayload {
    answer: Answer
    clientMutationId: String
  }

  input SaveDefaultDateAnswerInput {
    question: ID!
    meta: JSONString
    value: Date
    clientMutationId: String
  }

  type SaveDefaultListAnswerPayload {
    answer: Answer
    clientMutationId: String
  }

  input SaveDefaultListAnswerInput {
    question: ID!
    meta: JSONString
    value: [String]
    clientMutationId: String
  }

  type SaveDefaultTableAnswerPayload {
    answer: Answer
    clientMutationId: String
  }

  input SaveDefaultTableAnswerInput {
    question: ID!
    meta: JSONString

    """List of document IDs representing the rows in the table."""
    value: [ID]
    clientMutationId: String
  }

  type RemoveAnswerPayload {
    answer: Answer
    clientMutationId: String
  }

  input RemoveAnswerInput {
    answer: ID!
    clientMutationId: String
  }

  type RemoveDefaultAnswerPayload {
    question: Question
    clientMutationId: String
  }

  input RemoveDefaultAnswerInput {
    question: ID!
    clientMutationId: String
  }

  type RemoveDocumentPayload {
    document: Document
    clientMutationId: String
  }

  input RemoveDocumentInput {
    document: ID!
    clientMutationId: String
  input SaveDynamicChoiceQuestionInput {
    slug: String!
    label: String!
    infoText: String
    isRequired: QuestionJexl
    isHidden: QuestionJexl
    meta: JSONString
    isArchived: Boolean
    dataSource: String!
    hintText: String
    clientMutationId: String
  }

  type SaveDynamicChoiceQuestionPayload {
    question: Question
    clientMutationId: String
  }

  input SaveDynamicMultipleChoiceQuestionInput {
    slug: String!
    label: String!
    infoText: String
    isRequired: QuestionJexl
    isHidden: QuestionJexl
    meta: JSONString
    isArchived: Boolean
    dataSource: String!
    hintText: String
    clientMutationId: String
  }

  type SaveDynamicMultipleChoiceQuestionPayload {
    question: Question
    clientMutationId: String
  }

  input SaveFileQuestionInput {
    slug: String!
    label: String!
    infoText: String
    isRequired: QuestionJexl
    isHidden: QuestionJexl
    meta: JSONString
    isArchived: Boolean
    hintText: String
    clientMutationId: String
  }

  type SaveFileQuestionPayload {
    question: Question
    clientMutationId: String
  }

  input SaveFloatQuestionInput {
    slug: String!
    label: String!
    infoText: String
    isRequired: QuestionJexl
    isHidden: QuestionJexl
    meta: JSONString
    isArchived: Boolean
    minValue: Float
    maxValue: Float
    placeholder: String
    hintText: String
    clientMutationId: String
  }

  type SaveFloatQuestionPayload {
    question: Question
    clientMutationId: String
  }

  input SaveFormInput {
    slug: String!
    name: String!
    description: String
    meta: JSONString
    isArchived: Boolean
    isPublished: Boolean
    clientMutationId: String
  }

  type SaveFormPayload {
    form: Form
    clientMutationId: String
  }

  input SaveFormQuestionInput {
    slug: String!
    label: String!
    infoText: String
    isRequired: QuestionJexl
    isHidden: QuestionJexl
    meta: JSONString
    isArchived: Boolean
    subForm: ID!
    clientMutationId: String
  }

  type SaveFormQuestionPayload {
    question: Question
    clientMutationId: String
  }

  input SaveIntegerQuestionInput {
    slug: String!
    label: String!
    infoText: String
    isRequired: QuestionJexl
    isHidden: QuestionJexl
    meta: JSONString
    isArchived: Boolean
    minValue: Int
    maxValue: Int
    placeholder: String
    hintText: String
    clientMutationId: String
  }

  type SaveIntegerQuestionPayload {
    question: Question
    clientMutationId: String
  }

  input SaveMultipleChoiceQuestionInput {
    slug: String!
    label: String!
    infoText: String
    isRequired: QuestionJexl
    isHidden: QuestionJexl
    meta: JSONString
    isArchived: Boolean
    options: [ID]!
    hintText: String
    clientMutationId: String
  }

  type SaveMultipleChoiceQuestionPayload {
    question: Question
    clientMutationId: String
  }

  input SaveOptionInput {
    slug: String!
    label: String!
    isArchived: Boolean
    meta: JSONString
    clientMutationId: String
  }

  type SaveOptionPayload {
    option: Option
    clientMutationId: String
  }

  input SaveSimpleTaskInput {
    slug: String!
    name: String!
    description: String
    meta: JSONString
    addressGroups: GroupJexl
    controlGroups: GroupJexl
    isArchived: Boolean
    leadTime: Int
    isMultipleInstance: Boolean
    clientMutationId: String
  }

  type SaveSimpleTaskPayload {
    task: Task
    clientMutationId: String
  }

  input SaveStaticQuestionInput {
    label: String!
    slug: String!
    infoText: String
    isHidden: QuestionJexl
    meta: JSONString
    isArchived: Boolean
    staticContent: String
    clientMutationId: String
  }

  type SaveStaticQuestionPayload {
    question: Question
    clientMutationId: String
  }

  input SaveTableQuestionInput {
    slug: String!
    label: String!
    infoText: String
    isRequired: QuestionJexl
    isHidden: QuestionJexl
    meta: JSONString
    isArchived: Boolean
    rowForm: ID!
    hintText: String
    clientMutationId: String
  }

  type SaveTableQuestionPayload {
    question: Question
    clientMutationId: String
  }

  input SaveTextQuestionInput {
    slug: String!
    label: String!
    infoText: String
    isRequired: QuestionJexl
    isHidden: QuestionJexl
    meta: JSONString
    isArchived: Boolean
    minLength: Int
    maxLength: Int
    placeholder: String
    hintText: String
    formatValidators: [String]
    clientMutationId: String
  }

  type SaveTextQuestionPayload {
    question: Question
    clientMutationId: String
  }

  input SaveTextareaQuestionInput {
    slug: String!
    label: String!
    infoText: String
    isRequired: QuestionJexl
    isHidden: QuestionJexl
    meta: JSONString
    isArchived: Boolean
    minLength: Int
    maxLength: Int
    placeholder: String
    hintText: String
    formatValidators: [String]
    clientMutationId: String
  }

  type SaveTextareaQuestionPayload {
    question: Question
    clientMutationId: String
  }

  input SaveWorkItemInput {
    workItem: ID!
    name: String
    description: String
    assignedUsers: [String]
    deadline: DateTime
    meta: JSONString
    context: JSONString
    clientMutationId: String
  }

  type SaveWorkItemPayload {
    workItem: WorkItem
    clientMutationId: String
  }

  input SaveWorkflowInput {
    slug: String!
    name: String!
    description: String
    meta: JSONString
    startTasks: [ID]!
    allowAllForms: Boolean
    allowForms: [ID]
    isArchived: Boolean
    isPublished: Boolean
    clientMutationId: String
  }

  type SaveWorkflowPayload {
    workflow: Workflow
    clientMutationId: String
  }

  input SearchAnswersFilterType {
    questions: [ID]
    value: GenericScalar!
    lookup: SearchLookupMode
  }

  enum SearchLookupMode {
    STARTSWITH
    CONTAINS
    TEXT
  }

  type SelectedOption {
    label: String!
    slug: String!
  }

  type SelectedOptionConnection {
    pageInfo: PageInfo!
    edges: [SelectedOptionEdge]!
    totalCount: Int
  }

  type SelectedOptionEdge {
    node: SelectedOption
    cursor: String!
  }

  type SimpleTask implements Task, Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    slug: String!
    name: String!
    description: String
    type: TaskType!
    meta: GenericScalar!
    addressGroups: GroupJexl
    controlGroups: GroupJexl
    isArchived: Boolean!
    leadTime: Int
    isMultipleInstance: Boolean!
    id: ID!
  }

  input SkipWorkItemInput {
    id: ID!
    context: JSONString
    clientMutationId: String
  }

  type SkipWorkItemPayload {
    workItem: WorkItem
    clientMutationId: String
  }

  enum SortableAnalyticsTableAttributes {
    CREATED_AT
    MODIFIED_AT
    CREATED_BY_USER
    CREATED_BY_GROUP
    MODIFIED_BY_USER
    MODIFIED_BY_GROUP
    SLUG
    NAME
  }

  enum SortableAnswerAttributes {
    CREATED_AT
    MODIFIED_AT
    CREATED_BY_USER
    CREATED_BY_GROUP
    MODIFIED_BY_USER
    MODIFIED_BY_GROUP
    QUESTION
    VALUE
    DOCUMENT
    DATE
    FILE
  }

  enum SortableCaseAttributes {
    ALLOW_ALL_FORMS
    CREATED_BY_GROUP
    CREATED_BY_USER
    DESCRIPTION
    IS_ARCHIVED
    IS_PUBLISHED
    NAME
    STATUS
    SLUG
  }

  enum SortableDocumentAttributes {
    CREATED_AT
    MODIFIED_AT
    CREATED_BY_USER
    CREATED_BY_GROUP
    MODIFIED_BY_USER
    MODIFIED_BY_GROUP
    FORM
    SOURCE
  }

  enum SortableFormAttributes {
    CREATED_AT
    MODIFIED_AT
    CREATED_BY_USER
    CREATED_BY_GROUP
    MODIFIED_BY_USER
    MODIFIED_BY_GROUP
    SLUG
    NAME
    DESCRIPTION
    IS_PUBLISHED
    IS_ARCHIVED
  }

  enum SortableQuestionAttributes {
    CREATED_AT
    MODIFIED_AT
    CREATED_BY_USER
    CREATED_BY_GROUP
    MODIFIED_BY_USER
    MODIFIED_BY_GROUP
    SLUG
    LABEL
    TYPE
    IS_REQUIRED
    IS_HIDDEN
    IS_ARCHIVED
    PLACEHOLDER
    INFO_TEXT
    HINT_TEXT
    CALC_EXPRESSION
  }

  enum SortableTaskAttributes {
    ALLOW_ALL_FORMS
    LEAD_TIME
    TYPE
    CREATED_BY_GROUP
    CREATED_BY_USER
    DESCRIPTION
    IS_ARCHIVED
    IS_PUBLISHED
    NAME
    SLUG
  }

  enum SortableWorkItemAttributes {
    ALLOW_ALL_FORMS
    CREATED_BY_GROUP
    CREATED_BY_USER
    DESCRIPTION
    CREATED_AT
    MODIFIED_AT
    CLOSED_AT
    IS_ARCHIVED
    IS_PUBLISHED
    NAME
    DEADLINE
    STATUS
    SLUG
  }

  enum SortableWorkflowAttributes {
    ALLOW_ALL_FORMS
    CREATED_BY_GROUP
    CREATED_BY_USER
    DESCRIPTION
    IS_ARCHIVED
    IS_PUBLISHED
    NAME
    SLUG
  }

  input StartCaseInput {
    workflow: ID!
    meta: JSONString
    parentWorkItem: ID
    form: ID
    context: JSONString
    clientMutationId: String
  }

  type StartCasePayload {
    case: Case
    clientMutationId: String
  }

  type StaticQuestion implements Question, Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    slug: String!
    label: String!
    isRequired: QuestionJexl!
    isHidden: QuestionJexl!
    isArchived: Boolean!
    infoText: String
    meta: GenericScalar!
    source: Question
    forms(before: String, after: String, first: Int, last: Int, metaValue: [JSONValueFilterType], orderBy: [FormOrdering], slug: String, name: String, description: String, isPublished: Boolean, isArchived: Boolean, questions: [String], createdByUser: String, createdByGroup: String, modifiedByUser: String, modifiedByGroup: String, createdBefore: DateTime, createdAfter: DateTime, metaHasKey: String, search: String, slugs: [String]): FormConnection
    staticContent: String
    dataSource: String
    id: ID!
  }

  enum Status {
    READY
    COMPLETED
    CANCELED
    SKIPPED
    SUSPENDED
    REDO
  }

  type StringAnswer implements Answer, Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    id: ID!
    question: Question!
    value: String
    meta: GenericScalar!
    selectedOption: SelectedOption
  }

  input SuspendCaseInput {
    id: ID!
    context: JSONString
    clientMutationId: String
  }

  type SuspendCasePayload {
    case: Case
    clientMutationId: String
  }

  input SuspendWorkItemInput {
    id: ID!
    context: JSONString
    clientMutationId: String
  }

  type SuspendWorkItemPayload {
    workItem: WorkItem
    clientMutationId: String
  }

  type TableAnswer implements Answer, Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    id: ID!
    question: Question!
    value: [Document]
    meta: GenericScalar!
    document: Document
  }

  type TableQuestion implements Question, Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    slug: String!
    label: String!
    isRequired: QuestionJexl!
    isHidden: QuestionJexl!
    isArchived: Boolean!
    infoText: String
    hintText: String
    meta: GenericScalar!
    source: Question
    defaultAnswer: TableAnswer
    forms(before: String, after: String, first: Int, last: Int, metaValue: [JSONValueFilterType], orderBy: [FormOrdering], slug: String, name: String, description: String, isPublished: Boolean, isArchived: Boolean, questions: [String], createdByUser: String, createdByGroup: String, modifiedByUser: String, modifiedByGroup: String, createdBefore: DateTime, createdAfter: DateTime, metaHasKey: String, search: String, slugs: [String]): FormConnection
    rowForm: Form
    id: ID!
  }

  interface Task {
    id: ID!
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    slug: String!
    name: String!
    description: String
    isArchived: Boolean!
    addressGroups: GroupJexl
    controlGroups: GroupJexl
    meta: GenericScalar!
    isMultipleInstance: Boolean!
  }

  type TaskConnection {
    pageInfo: PageInfo!
    edges: [TaskEdge]!
    totalCount: Int
  }

  type TaskEdge {
    node: Task
    cursor: String!
  }

  input TaskFilterSetType {
    slug: String
    name: String
    description: String
    type: Type
    isArchived: Boolean
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    createdBefore: DateTime
    createdAfter: DateTime
    metaHasKey: String
    metaValue: [JSONValueFilterType]
    search: String
    orderBy: [TaskOrdering]
    invert: Boolean
  }

  input TaskOrderSetType {
    meta: String
    attribute: SortableTaskAttributes
    direction: AscDesc
  }

  enum TaskOrdering {
    NAME_ASC
    NAME_DESC
    DESCRIPTION_ASC
    DESCRIPTION_DESC
    TYPE_ASC
    TYPE_DESC
    CREATED_AT_ASC
    CREATED_AT_DESC
    MODIFIED_AT_ASC
    MODIFIED_AT_DESC
    CREATED_BY_USER_ASC
    CREATED_BY_USER_DESC
    CREATED_BY_GROUP_ASC
    CREATED_BY_GROUP_DESC
    MODIFIED_BY_USER_ASC
    MODIFIED_BY_USER_DESC
    MODIFIED_BY_GROUP_ASC
    MODIFIED_BY_GROUP_DESC
    META_TEST_KEY_ASC
    META_TEST_KEY_DESC
    META_FOOBAR_ASC
    META_FOOBAR_DESC
  }

  enum TaskType {
    SIMPLE
    COMPLETE_WORKFLOW_FORM
    COMPLETE_TASK_FORM
  }

  enum TaskTypeArgument {
    SIMPLE
    COMPLETE_WORKFLOW_FORM
    COMPLETE_TASK_FORM
  }

  type TextQuestion implements Question, Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    slug: String!
    label: String!
    isRequired: QuestionJexl!
    isHidden: QuestionJexl!
    isArchived: Boolean!
    placeholder: String
    infoText: String
    hintText: String
    meta: GenericScalar!
    source: Question
    formatValidators(before: String, after: String, first: Int, last: Int): FormatValidatorConnection
    defaultAnswer: StringAnswer
    forms(before: String, after: String, first: Int, last: Int, metaValue: [JSONValueFilterType], orderBy: [FormOrdering], slug: String, name: String, description: String, isPublished: Boolean, isArchived: Boolean, questions: [String], createdByUser: String, createdByGroup: String, modifiedByUser: String, modifiedByGroup: String, createdBefore: DateTime, createdAfter: DateTime, metaHasKey: String, search: String, slugs: [String]): FormConnection
    id: ID!
    minLength: Int
    maxLength: Int
  }

  type TextareaQuestion implements Question, Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    slug: String!
    label: String!
    isRequired: QuestionJexl!
    isHidden: QuestionJexl!
    isArchived: Boolean!
    placeholder: String
    infoText: String
    hintText: String
    meta: GenericScalar!
    source: Question
    formatValidators(before: String, after: String, first: Int, last: Int): FormatValidatorConnection
    defaultAnswer: StringAnswer
    forms(before: String, after: String, first: Int, last: Int, metaValue: [JSONValueFilterType], orderBy: [FormOrdering], slug: String, name: String, description: String, isPublished: Boolean, isArchived: Boolean, questions: [String], createdByUser: String, createdByGroup: String, modifiedByUser: String, modifiedByGroup: String, createdBefore: DateTime, createdAfter: DateTime, metaHasKey: String, search: String, slugs: [String]): FormConnection
    id: ID!
    minLength: Int
    maxLength: Int
  }

  enum Type {
    SIMPLE
    COMPLETE_WORKFLOW_FORM
    COMPLETE_TASK_FORM
  }

  scalar UUID

  type ValidationEntry {
    slug: String!
    errorMsg: String!
  }

  type ValidationResult {
    id: ID
    isValid: Boolean
    errors: [ValidationEntry]
  }

  type WorkItem implements Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    id: ID!
    name: String!
    description: String
    closedAt: DateTime
    closedByUser: String
    closedByGroup: String
    deadline: DateTime
    task: Task!
    status: WorkItemStatus!
    meta: GenericScalar
    addressedGroups: [String!]!
    controllingGroups: [String!]!
    assignedUsers: [String!]!
    case: Case!
    childCase: Case
    document: Document
    previousWorkItem: WorkItem
    succeedingWorkItems(before: String, after: String, first: Int, last: Int): WorkItemConnection!
  }

  type WorkItemConnection {
    pageInfo: PageInfo!
    edges: [WorkItemEdge]!
    totalCount: Int
  }

  type WorkItemEdge {
    node: WorkItem
    cursor: String!
  }

  input WorkItemFilterSetType {
    status: Status
    name: String
    task: ID
    tasks: [String]
    case: ID
    createdAt: DateTime
    closedAt: DateTime
    modifiedAt: DateTime
    deadline: DateTime
    hasDeadline: Boolean
    caseFamily: ID
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    createdBefore: DateTime
    createdAfter: DateTime
    metaHasKey: String
    metaValue: [JSONValueFilterType]
    id: ID
    orderBy: [WorkItemOrdering]
    addressedGroups: [String]
    controllingGroups: [String]
    assignedUsers: [String]
    documentHasAnswer: [HasAnswerFilterType]
    caseDocumentHasAnswer: [HasAnswerFilterType]
    caseMetaValue: [JSONValueFilterType]
    rootCaseMetaValue: [JSONValueFilterType]
    invert: Boolean
  }

  input WorkItemOrderSetType {
    meta: String
    caseMeta: String
    attribute: SortableWorkItemAttributes
    documentAnswer: String
    caseDocumentAnswer: String
    direction: AscDesc
  }

  enum WorkItemOrdering {
    STATUS_ASC
    STATUS_DESC
    DEADLINE_ASC
    DEADLINE_DESC
    CREATED_AT_ASC
    CREATED_AT_DESC
    MODIFIED_AT_ASC
    MODIFIED_AT_DESC
    CREATED_BY_USER_ASC
    CREATED_BY_USER_DESC
    CREATED_BY_GROUP_ASC
    CREATED_BY_GROUP_DESC
    MODIFIED_BY_USER_ASC
    MODIFIED_BY_USER_DESC
    MODIFIED_BY_GROUP_ASC
    MODIFIED_BY_GROUP_DESC
    META_TEST_KEY_ASC
    META_TEST_KEY_DESC
    META_FOOBAR_ASC
    META_FOOBAR_DESC
  }

  enum WorkItemStatus {
    READY
    COMPLETED
    CANCELED
    SKIPPED
    SUSPENDED
    REDO
  }

  enum WorkItemStatusArgument {
    READY
    COMPLETED
    CANCELED
    SKIPPED
    SUSPENDED
    REDO
  }

  type Workflow implements Node {
    createdAt: DateTime!
    modifiedAt: DateTime!
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    slug: String!
    name: String!
    description: String
    meta: GenericScalar
    isPublished: Boolean!
    isArchived: Boolean!
    startTasks: [Task]!
    allowAllForms: Boolean!
    allowForms(before: String, after: String, first: Int, last: Int): FormConnection!
    id: ID!
    tasks: [Task]!
    flows(before: String, after: String, first: Int, last: Int, task: ID, filter: [FlowFilterSetType], createdByUser: String, createdByGroup: String, modifiedByUser: String, modifiedByGroup: String, createdBefore: DateTime, createdAfter: DateTime): FlowConnection
  }

  type WorkflowConnection {
    pageInfo: PageInfo!
    edges: [WorkflowEdge]!
    totalCount: Int
  }

  type WorkflowEdge {
    node: Workflow
    cursor: String!
  }

  input WorkflowFilterSetType {
    slug: String
    name: String
    description: String
    isPublished: Boolean
    isArchived: Boolean
    createdByUser: String
    createdByGroup: String
    modifiedByUser: String
    modifiedByGroup: String
    createdBefore: DateTime
    createdAfter: DateTime
    metaHasKey: String
    metaValue: [JSONValueFilterType]
    search: String
    orderBy: [WorkflowOrdering]
    invert: Boolean
  }

  input WorkflowOrderSetType {
    meta: String
    attribute: SortableWorkflowAttributes
    direction: AscDesc
  }

  enum WorkflowOrdering {
    NAME_ASC
    NAME_DESC
    DESCRIPTION_ASC
    DESCRIPTION_DESC
    CREATED_AT_ASC
    CREATED_AT_DESC
    MODIFIED_AT_ASC
    MODIFIED_AT_DESC
    CREATED_BY_USER_ASC
    CREATED_BY_USER_DESC
    CREATED_BY_GROUP_ASC
    CREATED_BY_GROUP_DESC
    MODIFIED_BY_USER_ASC
    MODIFIED_BY_USER_DESC
    MODIFIED_BY_GROUP_ASC
    MODIFIED_BY_GROUP_DESC
    META_TEST_KEY_ASC
    META_TEST_KEY_DESC
    META_FOOBAR_ASC
    META_FOOBAR_DESC
  }

  enum starting_object {
    CASES
  }

  '
---
